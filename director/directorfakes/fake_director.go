// Code generated by counterfeiter. DO NOT EDIT.
package directorfakes

import (
	"io"
	"sync"

	"github.com/cloudfoundry/bosh-cli/v6/director"
)

type FakeDirector struct {
	CancelTasksStub        func(director.TasksFilter) error
	cancelTasksMutex       sync.RWMutex
	cancelTasksArgsForCall []struct {
		arg1 director.TasksFilter
	}
	cancelTasksReturns struct {
		result1 error
	}
	cancelTasksReturnsOnCall map[int]struct {
		result1 error
	}
	CertificateExpiryStub        func() ([]director.CertificateExpiryInfo, error)
	certificateExpiryMutex       sync.RWMutex
	certificateExpiryArgsForCall []struct {
	}
	certificateExpiryReturns struct {
		result1 []director.CertificateExpiryInfo
		result2 error
	}
	certificateExpiryReturnsOnCall map[int]struct {
		result1 []director.CertificateExpiryInfo
		result2 error
	}
	CleanUpStub        func(bool, bool, bool) (director.CleanUp, error)
	cleanUpMutex       sync.RWMutex
	cleanUpArgsForCall []struct {
		arg1 bool
		arg2 bool
		arg3 bool
	}
	cleanUpReturns struct {
		result1 director.CleanUp
		result2 error
	}
	cleanUpReturnsOnCall map[int]struct {
		result1 director.CleanUp
		result2 error
	}
	CurrentTasksStub        func(director.TasksFilter) ([]director.Task, error)
	currentTasksMutex       sync.RWMutex
	currentTasksArgsForCall []struct {
		arg1 director.TasksFilter
	}
	currentTasksReturns struct {
		result1 []director.Task
		result2 error
	}
	currentTasksReturnsOnCall map[int]struct {
		result1 []director.Task
		result2 error
	}
	DeleteConfigStub        func(string, string) (bool, error)
	deleteConfigMutex       sync.RWMutex
	deleteConfigArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deleteConfigReturns struct {
		result1 bool
		result2 error
	}
	deleteConfigReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	DeleteConfigByIDStub        func(string) (bool, error)
	deleteConfigByIDMutex       sync.RWMutex
	deleteConfigByIDArgsForCall []struct {
		arg1 string
	}
	deleteConfigByIDReturns struct {
		result1 bool
		result2 error
	}
	deleteConfigByIDReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	DeploymentsStub        func() ([]director.Deployment, error)
	deploymentsMutex       sync.RWMutex
	deploymentsArgsForCall []struct {
	}
	deploymentsReturns struct {
		result1 []director.Deployment
		result2 error
	}
	deploymentsReturnsOnCall map[int]struct {
		result1 []director.Deployment
		result2 error
	}
	DiffCPIConfigStub        func([]byte, bool) (director.ConfigDiff, error)
	diffCPIConfigMutex       sync.RWMutex
	diffCPIConfigArgsForCall []struct {
		arg1 []byte
		arg2 bool
	}
	diffCPIConfigReturns struct {
		result1 director.ConfigDiff
		result2 error
	}
	diffCPIConfigReturnsOnCall map[int]struct {
		result1 director.ConfigDiff
		result2 error
	}
	DiffCloudConfigStub        func([]byte) (director.ConfigDiff, error)
	diffCloudConfigMutex       sync.RWMutex
	diffCloudConfigArgsForCall []struct {
		arg1 []byte
	}
	diffCloudConfigReturns struct {
		result1 director.ConfigDiff
		result2 error
	}
	diffCloudConfigReturnsOnCall map[int]struct {
		result1 director.ConfigDiff
		result2 error
	}
	DiffConfigStub        func(string, string, []byte) (director.ConfigDiff, error)
	diffConfigMutex       sync.RWMutex
	diffConfigArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []byte
	}
	diffConfigReturns struct {
		result1 director.ConfigDiff
		result2 error
	}
	diffConfigReturnsOnCall map[int]struct {
		result1 director.ConfigDiff
		result2 error
	}
	DiffConfigByIDOrContentStub        func(string, []byte, string, []byte) (director.ConfigDiff, error)
	diffConfigByIDOrContentMutex       sync.RWMutex
	diffConfigByIDOrContentArgsForCall []struct {
		arg1 string
		arg2 []byte
		arg3 string
		arg4 []byte
	}
	diffConfigByIDOrContentReturns struct {
		result1 director.ConfigDiff
		result2 error
	}
	diffConfigByIDOrContentReturnsOnCall map[int]struct {
		result1 director.ConfigDiff
		result2 error
	}
	DiffRuntimeConfigStub        func(string, []byte, bool) (director.ConfigDiff, error)
	diffRuntimeConfigMutex       sync.RWMutex
	diffRuntimeConfigArgsForCall []struct {
		arg1 string
		arg2 []byte
		arg3 bool
	}
	diffRuntimeConfigReturns struct {
		result1 director.ConfigDiff
		result2 error
	}
	diffRuntimeConfigReturnsOnCall map[int]struct {
		result1 director.ConfigDiff
		result2 error
	}
	DownloadResourceUncheckedStub        func(string, io.Writer) error
	downloadResourceUncheckedMutex       sync.RWMutex
	downloadResourceUncheckedArgsForCall []struct {
		arg1 string
		arg2 io.Writer
	}
	downloadResourceUncheckedReturns struct {
		result1 error
	}
	downloadResourceUncheckedReturnsOnCall map[int]struct {
		result1 error
	}
	EnableResurrectionStub        func(bool) error
	enableResurrectionMutex       sync.RWMutex
	enableResurrectionArgsForCall []struct {
		arg1 bool
	}
	enableResurrectionReturns struct {
		result1 error
	}
	enableResurrectionReturnsOnCall map[int]struct {
		result1 error
	}
	EventStub        func(string) (director.Event, error)
	eventMutex       sync.RWMutex
	eventArgsForCall []struct {
		arg1 string
	}
	eventReturns struct {
		result1 director.Event
		result2 error
	}
	eventReturnsOnCall map[int]struct {
		result1 director.Event
		result2 error
	}
	EventsStub        func(director.EventsFilter) ([]director.Event, error)
	eventsMutex       sync.RWMutex
	eventsArgsForCall []struct {
		arg1 director.EventsFilter
	}
	eventsReturns struct {
		result1 []director.Event
		result2 error
	}
	eventsReturnsOnCall map[int]struct {
		result1 []director.Event
		result2 error
	}
	FindDeploymentStub        func(string) (director.Deployment, error)
	findDeploymentMutex       sync.RWMutex
	findDeploymentArgsForCall []struct {
		arg1 string
	}
	findDeploymentReturns struct {
		result1 director.Deployment
		result2 error
	}
	findDeploymentReturnsOnCall map[int]struct {
		result1 director.Deployment
		result2 error
	}
	FindOrphanDiskStub        func(string) (director.OrphanDisk, error)
	findOrphanDiskMutex       sync.RWMutex
	findOrphanDiskArgsForCall []struct {
		arg1 string
	}
	findOrphanDiskReturns struct {
		result1 director.OrphanDisk
		result2 error
	}
	findOrphanDiskReturnsOnCall map[int]struct {
		result1 director.OrphanDisk
		result2 error
	}
	FindOrphanNetworkStub        func(string) (director.OrphanNetwork, error)
	findOrphanNetworkMutex       sync.RWMutex
	findOrphanNetworkArgsForCall []struct {
		arg1 string
	}
	findOrphanNetworkReturns struct {
		result1 director.OrphanNetwork
		result2 error
	}
	findOrphanNetworkReturnsOnCall map[int]struct {
		result1 director.OrphanNetwork
		result2 error
	}
	FindReleaseStub        func(director.ReleaseSlug) (director.Release, error)
	findReleaseMutex       sync.RWMutex
	findReleaseArgsForCall []struct {
		arg1 director.ReleaseSlug
	}
	findReleaseReturns struct {
		result1 director.Release
		result2 error
	}
	findReleaseReturnsOnCall map[int]struct {
		result1 director.Release
		result2 error
	}
	FindReleaseSeriesStub        func(director.ReleaseSeriesSlug) (director.ReleaseSeries, error)
	findReleaseSeriesMutex       sync.RWMutex
	findReleaseSeriesArgsForCall []struct {
		arg1 director.ReleaseSeriesSlug
	}
	findReleaseSeriesReturns struct {
		result1 director.ReleaseSeries
		result2 error
	}
	findReleaseSeriesReturnsOnCall map[int]struct {
		result1 director.ReleaseSeries
		result2 error
	}
	FindStemcellStub        func(director.StemcellSlug) (director.Stemcell, error)
	findStemcellMutex       sync.RWMutex
	findStemcellArgsForCall []struct {
		arg1 director.StemcellSlug
	}
	findStemcellReturns struct {
		result1 director.Stemcell
		result2 error
	}
	findStemcellReturnsOnCall map[int]struct {
		result1 director.Stemcell
		result2 error
	}
	FindTaskStub        func(int) (director.Task, error)
	findTaskMutex       sync.RWMutex
	findTaskArgsForCall []struct {
		arg1 int
	}
	findTaskReturns struct {
		result1 director.Task
		result2 error
	}
	findTaskReturnsOnCall map[int]struct {
		result1 director.Task
		result2 error
	}
	FindTasksByContextIdStub        func(string) ([]director.Task, error)
	findTasksByContextIdMutex       sync.RWMutex
	findTasksByContextIdArgsForCall []struct {
		arg1 string
	}
	findTasksByContextIdReturns struct {
		result1 []director.Task
		result2 error
	}
	findTasksByContextIdReturnsOnCall map[int]struct {
		result1 []director.Task
		result2 error
	}
	HasReleaseStub        func(string, string, director.OSVersionSlug) (bool, error)
	hasReleaseMutex       sync.RWMutex
	hasReleaseArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 director.OSVersionSlug
	}
	hasReleaseReturns struct {
		result1 bool
		result2 error
	}
	hasReleaseReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	InfoStub        func() (director.Info, error)
	infoMutex       sync.RWMutex
	infoArgsForCall []struct {
	}
	infoReturns struct {
		result1 director.Info
		result2 error
	}
	infoReturnsOnCall map[int]struct {
		result1 director.Info
		result2 error
	}
	IsAuthenticatedStub        func() (bool, error)
	isAuthenticatedMutex       sync.RWMutex
	isAuthenticatedArgsForCall []struct {
	}
	isAuthenticatedReturns struct {
		result1 bool
		result2 error
	}
	isAuthenticatedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	LatestCPIConfigStub        func() (director.CPIConfig, error)
	latestCPIConfigMutex       sync.RWMutex
	latestCPIConfigArgsForCall []struct {
	}
	latestCPIConfigReturns struct {
		result1 director.CPIConfig
		result2 error
	}
	latestCPIConfigReturnsOnCall map[int]struct {
		result1 director.CPIConfig
		result2 error
	}
	LatestCloudConfigStub        func() (director.CloudConfig, error)
	latestCloudConfigMutex       sync.RWMutex
	latestCloudConfigArgsForCall []struct {
	}
	latestCloudConfigReturns struct {
		result1 director.CloudConfig
		result2 error
	}
	latestCloudConfigReturnsOnCall map[int]struct {
		result1 director.CloudConfig
		result2 error
	}
	LatestConfigStub        func(string, string) (director.Config, error)
	latestConfigMutex       sync.RWMutex
	latestConfigArgsForCall []struct {
		arg1 string
		arg2 string
	}
	latestConfigReturns struct {
		result1 director.Config
		result2 error
	}
	latestConfigReturnsOnCall map[int]struct {
		result1 director.Config
		result2 error
	}
	LatestConfigByIDStub        func(string) (director.Config, error)
	latestConfigByIDMutex       sync.RWMutex
	latestConfigByIDArgsForCall []struct {
		arg1 string
	}
	latestConfigByIDReturns struct {
		result1 director.Config
		result2 error
	}
	latestConfigByIDReturnsOnCall map[int]struct {
		result1 director.Config
		result2 error
	}
	LatestRuntimeConfigStub        func(string) (director.RuntimeConfig, error)
	latestRuntimeConfigMutex       sync.RWMutex
	latestRuntimeConfigArgsForCall []struct {
		arg1 string
	}
	latestRuntimeConfigReturns struct {
		result1 director.RuntimeConfig
		result2 error
	}
	latestRuntimeConfigReturnsOnCall map[int]struct {
		result1 director.RuntimeConfig
		result2 error
	}
	ListConfigsStub        func(int, director.ConfigsFilter) ([]director.Config, error)
	listConfigsMutex       sync.RWMutex
	listConfigsArgsForCall []struct {
		arg1 int
		arg2 director.ConfigsFilter
	}
	listConfigsReturns struct {
		result1 []director.Config
		result2 error
	}
	listConfigsReturnsOnCall map[int]struct {
		result1 []director.Config
		result2 error
	}
	ListDeploymentConfigsStub        func(string) (director.DeploymentConfigs, error)
	listDeploymentConfigsMutex       sync.RWMutex
	listDeploymentConfigsArgsForCall []struct {
		arg1 string
	}
	listDeploymentConfigsReturns struct {
		result1 director.DeploymentConfigs
		result2 error
	}
	listDeploymentConfigsReturnsOnCall map[int]struct {
		result1 director.DeploymentConfigs
		result2 error
	}
	ListDeploymentsStub        func() ([]director.DeploymentResp, error)
	listDeploymentsMutex       sync.RWMutex
	listDeploymentsArgsForCall []struct {
	}
	listDeploymentsReturns struct {
		result1 []director.DeploymentResp
		result2 error
	}
	listDeploymentsReturnsOnCall map[int]struct {
		result1 []director.DeploymentResp
		result2 error
	}
	LocksStub        func() ([]director.Lock, error)
	locksMutex       sync.RWMutex
	locksArgsForCall []struct {
	}
	locksReturns struct {
		result1 []director.Lock
		result2 error
	}
	locksReturnsOnCall map[int]struct {
		result1 []director.Lock
		result2 error
	}
	MatchPackagesStub        func(interface{}, bool) ([]string, error)
	matchPackagesMutex       sync.RWMutex
	matchPackagesArgsForCall []struct {
		arg1 interface{}
		arg2 bool
	}
	matchPackagesReturns struct {
		result1 []string
		result2 error
	}
	matchPackagesReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	OrphanDiskStub        func(string) error
	orphanDiskMutex       sync.RWMutex
	orphanDiskArgsForCall []struct {
		arg1 string
	}
	orphanDiskReturns struct {
		result1 error
	}
	orphanDiskReturnsOnCall map[int]struct {
		result1 error
	}
	OrphanDisksStub        func() ([]director.OrphanDisk, error)
	orphanDisksMutex       sync.RWMutex
	orphanDisksArgsForCall []struct {
	}
	orphanDisksReturns struct {
		result1 []director.OrphanDisk
		result2 error
	}
	orphanDisksReturnsOnCall map[int]struct {
		result1 []director.OrphanDisk
		result2 error
	}
	OrphanNetworksStub        func() ([]director.OrphanNetwork, error)
	orphanNetworksMutex       sync.RWMutex
	orphanNetworksArgsForCall []struct {
	}
	orphanNetworksReturns struct {
		result1 []director.OrphanNetwork
		result2 error
	}
	orphanNetworksReturnsOnCall map[int]struct {
		result1 []director.OrphanNetwork
		result2 error
	}
	OrphanedVMsStub        func() ([]director.OrphanedVM, error)
	orphanedVMsMutex       sync.RWMutex
	orphanedVMsArgsForCall []struct {
	}
	orphanedVMsReturns struct {
		result1 []director.OrphanedVM
		result2 error
	}
	orphanedVMsReturnsOnCall map[int]struct {
		result1 []director.OrphanedVM
		result2 error
	}
	RecentTasksStub        func(int, director.TasksFilter) ([]director.Task, error)
	recentTasksMutex       sync.RWMutex
	recentTasksArgsForCall []struct {
		arg1 int
		arg2 director.TasksFilter
	}
	recentTasksReturns struct {
		result1 []director.Task
		result2 error
	}
	recentTasksReturnsOnCall map[int]struct {
		result1 []director.Task
		result2 error
	}
	ReleaseHasCompiledPackageStub        func(director.ReleaseSlug, director.OSVersionSlug) (bool, error)
	releaseHasCompiledPackageMutex       sync.RWMutex
	releaseHasCompiledPackageArgsForCall []struct {
		arg1 director.ReleaseSlug
		arg2 director.OSVersionSlug
	}
	releaseHasCompiledPackageReturns struct {
		result1 bool
		result2 error
	}
	releaseHasCompiledPackageReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ReleasesStub        func() ([]director.Release, error)
	releasesMutex       sync.RWMutex
	releasesArgsForCall []struct {
	}
	releasesReturns struct {
		result1 []director.Release
		result2 error
	}
	releasesReturnsOnCall map[int]struct {
		result1 []director.Release
		result2 error
	}
	StemcellNeedsUploadStub        func(director.StemcellInfo) (bool, error)
	stemcellNeedsUploadMutex       sync.RWMutex
	stemcellNeedsUploadArgsForCall []struct {
		arg1 director.StemcellInfo
	}
	stemcellNeedsUploadReturns struct {
		result1 bool
		result2 error
	}
	stemcellNeedsUploadReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	StemcellsStub        func() ([]director.Stemcell, error)
	stemcellsMutex       sync.RWMutex
	stemcellsArgsForCall []struct {
	}
	stemcellsReturns struct {
		result1 []director.Stemcell
		result2 error
	}
	stemcellsReturnsOnCall map[int]struct {
		result1 []director.Stemcell
		result2 error
	}
	UpdateCPIConfigStub        func([]byte) error
	updateCPIConfigMutex       sync.RWMutex
	updateCPIConfigArgsForCall []struct {
		arg1 []byte
	}
	updateCPIConfigReturns struct {
		result1 error
	}
	updateCPIConfigReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateCloudConfigStub        func([]byte) error
	updateCloudConfigMutex       sync.RWMutex
	updateCloudConfigArgsForCall []struct {
		arg1 []byte
	}
	updateCloudConfigReturns struct {
		result1 error
	}
	updateCloudConfigReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateConfigStub        func(string, string, string, []byte) (director.Config, error)
	updateConfigMutex       sync.RWMutex
	updateConfigArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []byte
	}
	updateConfigReturns struct {
		result1 director.Config
		result2 error
	}
	updateConfigReturnsOnCall map[int]struct {
		result1 director.Config
		result2 error
	}
	UpdateRuntimeConfigStub        func(string, []byte) error
	updateRuntimeConfigMutex       sync.RWMutex
	updateRuntimeConfigArgsForCall []struct {
		arg1 string
		arg2 []byte
	}
	updateRuntimeConfigReturns struct {
		result1 error
	}
	updateRuntimeConfigReturnsOnCall map[int]struct {
		result1 error
	}
	UploadReleaseFileStub        func(director.UploadFile, bool, bool) error
	uploadReleaseFileMutex       sync.RWMutex
	uploadReleaseFileArgsForCall []struct {
		arg1 director.UploadFile
		arg2 bool
		arg3 bool
	}
	uploadReleaseFileReturns struct {
		result1 error
	}
	uploadReleaseFileReturnsOnCall map[int]struct {
		result1 error
	}
	UploadReleaseURLStub        func(string, string, bool, bool) error
	uploadReleaseURLMutex       sync.RWMutex
	uploadReleaseURLArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 bool
		arg4 bool
	}
	uploadReleaseURLReturns struct {
		result1 error
	}
	uploadReleaseURLReturnsOnCall map[int]struct {
		result1 error
	}
	UploadStemcellFileStub        func(director.UploadFile, bool) error
	uploadStemcellFileMutex       sync.RWMutex
	uploadStemcellFileArgsForCall []struct {
		arg1 director.UploadFile
		arg2 bool
	}
	uploadStemcellFileReturns struct {
		result1 error
	}
	uploadStemcellFileReturnsOnCall map[int]struct {
		result1 error
	}
	UploadStemcellURLStub        func(string, string, bool) error
	uploadStemcellURLMutex       sync.RWMutex
	uploadStemcellURLArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 bool
	}
	uploadStemcellURLReturns struct {
		result1 error
	}
	uploadStemcellURLReturnsOnCall map[int]struct {
		result1 error
	}
	WithContextStub        func(string) director.Director
	withContextMutex       sync.RWMutex
	withContextArgsForCall []struct {
		arg1 string
	}
	withContextReturns struct {
		result1 director.Director
	}
	withContextReturnsOnCall map[int]struct {
		result1 director.Director
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDirector) CancelTasks(arg1 director.TasksFilter) error {
	fake.cancelTasksMutex.Lock()
	ret, specificReturn := fake.cancelTasksReturnsOnCall[len(fake.cancelTasksArgsForCall)]
	fake.cancelTasksArgsForCall = append(fake.cancelTasksArgsForCall, struct {
		arg1 director.TasksFilter
	}{arg1})
	stub := fake.CancelTasksStub
	fakeReturns := fake.cancelTasksReturns
	fake.recordInvocation("CancelTasks", []interface{}{arg1})
	fake.cancelTasksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDirector) CancelTasksCallCount() int {
	fake.cancelTasksMutex.RLock()
	defer fake.cancelTasksMutex.RUnlock()
	return len(fake.cancelTasksArgsForCall)
}

func (fake *FakeDirector) CancelTasksCalls(stub func(director.TasksFilter) error) {
	fake.cancelTasksMutex.Lock()
	defer fake.cancelTasksMutex.Unlock()
	fake.CancelTasksStub = stub
}

func (fake *FakeDirector) CancelTasksArgsForCall(i int) director.TasksFilter {
	fake.cancelTasksMutex.RLock()
	defer fake.cancelTasksMutex.RUnlock()
	argsForCall := fake.cancelTasksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) CancelTasksReturns(result1 error) {
	fake.cancelTasksMutex.Lock()
	defer fake.cancelTasksMutex.Unlock()
	fake.CancelTasksStub = nil
	fake.cancelTasksReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) CancelTasksReturnsOnCall(i int, result1 error) {
	fake.cancelTasksMutex.Lock()
	defer fake.cancelTasksMutex.Unlock()
	fake.CancelTasksStub = nil
	if fake.cancelTasksReturnsOnCall == nil {
		fake.cancelTasksReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelTasksReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) CertificateExpiry() ([]director.CertificateExpiryInfo, error) {
	fake.certificateExpiryMutex.Lock()
	ret, specificReturn := fake.certificateExpiryReturnsOnCall[len(fake.certificateExpiryArgsForCall)]
	fake.certificateExpiryArgsForCall = append(fake.certificateExpiryArgsForCall, struct {
	}{})
	stub := fake.CertificateExpiryStub
	fakeReturns := fake.certificateExpiryReturns
	fake.recordInvocation("CertificateExpiry", []interface{}{})
	fake.certificateExpiryMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) CertificateExpiryCallCount() int {
	fake.certificateExpiryMutex.RLock()
	defer fake.certificateExpiryMutex.RUnlock()
	return len(fake.certificateExpiryArgsForCall)
}

func (fake *FakeDirector) CertificateExpiryCalls(stub func() ([]director.CertificateExpiryInfo, error)) {
	fake.certificateExpiryMutex.Lock()
	defer fake.certificateExpiryMutex.Unlock()
	fake.CertificateExpiryStub = stub
}

func (fake *FakeDirector) CertificateExpiryReturns(result1 []director.CertificateExpiryInfo, result2 error) {
	fake.certificateExpiryMutex.Lock()
	defer fake.certificateExpiryMutex.Unlock()
	fake.CertificateExpiryStub = nil
	fake.certificateExpiryReturns = struct {
		result1 []director.CertificateExpiryInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) CertificateExpiryReturnsOnCall(i int, result1 []director.CertificateExpiryInfo, result2 error) {
	fake.certificateExpiryMutex.Lock()
	defer fake.certificateExpiryMutex.Unlock()
	fake.CertificateExpiryStub = nil
	if fake.certificateExpiryReturnsOnCall == nil {
		fake.certificateExpiryReturnsOnCall = make(map[int]struct {
			result1 []director.CertificateExpiryInfo
			result2 error
		})
	}
	fake.certificateExpiryReturnsOnCall[i] = struct {
		result1 []director.CertificateExpiryInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) CleanUp(arg1 bool, arg2 bool, arg3 bool) (director.CleanUp, error) {
	fake.cleanUpMutex.Lock()
	ret, specificReturn := fake.cleanUpReturnsOnCall[len(fake.cleanUpArgsForCall)]
	fake.cleanUpArgsForCall = append(fake.cleanUpArgsForCall, struct {
		arg1 bool
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.CleanUpStub
	fakeReturns := fake.cleanUpReturns
	fake.recordInvocation("CleanUp", []interface{}{arg1, arg2, arg3})
	fake.cleanUpMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) CleanUpCallCount() int {
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	return len(fake.cleanUpArgsForCall)
}

func (fake *FakeDirector) CleanUpCalls(stub func(bool, bool, bool) (director.CleanUp, error)) {
	fake.cleanUpMutex.Lock()
	defer fake.cleanUpMutex.Unlock()
	fake.CleanUpStub = stub
}

func (fake *FakeDirector) CleanUpArgsForCall(i int) (bool, bool, bool) {
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	argsForCall := fake.cleanUpArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDirector) CleanUpReturns(result1 director.CleanUp, result2 error) {
	fake.cleanUpMutex.Lock()
	defer fake.cleanUpMutex.Unlock()
	fake.CleanUpStub = nil
	fake.cleanUpReturns = struct {
		result1 director.CleanUp
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) CleanUpReturnsOnCall(i int, result1 director.CleanUp, result2 error) {
	fake.cleanUpMutex.Lock()
	defer fake.cleanUpMutex.Unlock()
	fake.CleanUpStub = nil
	if fake.cleanUpReturnsOnCall == nil {
		fake.cleanUpReturnsOnCall = make(map[int]struct {
			result1 director.CleanUp
			result2 error
		})
	}
	fake.cleanUpReturnsOnCall[i] = struct {
		result1 director.CleanUp
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) CurrentTasks(arg1 director.TasksFilter) ([]director.Task, error) {
	fake.currentTasksMutex.Lock()
	ret, specificReturn := fake.currentTasksReturnsOnCall[len(fake.currentTasksArgsForCall)]
	fake.currentTasksArgsForCall = append(fake.currentTasksArgsForCall, struct {
		arg1 director.TasksFilter
	}{arg1})
	stub := fake.CurrentTasksStub
	fakeReturns := fake.currentTasksReturns
	fake.recordInvocation("CurrentTasks", []interface{}{arg1})
	fake.currentTasksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) CurrentTasksCallCount() int {
	fake.currentTasksMutex.RLock()
	defer fake.currentTasksMutex.RUnlock()
	return len(fake.currentTasksArgsForCall)
}

func (fake *FakeDirector) CurrentTasksCalls(stub func(director.TasksFilter) ([]director.Task, error)) {
	fake.currentTasksMutex.Lock()
	defer fake.currentTasksMutex.Unlock()
	fake.CurrentTasksStub = stub
}

func (fake *FakeDirector) CurrentTasksArgsForCall(i int) director.TasksFilter {
	fake.currentTasksMutex.RLock()
	defer fake.currentTasksMutex.RUnlock()
	argsForCall := fake.currentTasksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) CurrentTasksReturns(result1 []director.Task, result2 error) {
	fake.currentTasksMutex.Lock()
	defer fake.currentTasksMutex.Unlock()
	fake.CurrentTasksStub = nil
	fake.currentTasksReturns = struct {
		result1 []director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) CurrentTasksReturnsOnCall(i int, result1 []director.Task, result2 error) {
	fake.currentTasksMutex.Lock()
	defer fake.currentTasksMutex.Unlock()
	fake.CurrentTasksStub = nil
	if fake.currentTasksReturnsOnCall == nil {
		fake.currentTasksReturnsOnCall = make(map[int]struct {
			result1 []director.Task
			result2 error
		})
	}
	fake.currentTasksReturnsOnCall[i] = struct {
		result1 []director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DeleteConfig(arg1 string, arg2 string) (bool, error) {
	fake.deleteConfigMutex.Lock()
	ret, specificReturn := fake.deleteConfigReturnsOnCall[len(fake.deleteConfigArgsForCall)]
	fake.deleteConfigArgsForCall = append(fake.deleteConfigArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteConfigStub
	fakeReturns := fake.deleteConfigReturns
	fake.recordInvocation("DeleteConfig", []interface{}{arg1, arg2})
	fake.deleteConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) DeleteConfigCallCount() int {
	fake.deleteConfigMutex.RLock()
	defer fake.deleteConfigMutex.RUnlock()
	return len(fake.deleteConfigArgsForCall)
}

func (fake *FakeDirector) DeleteConfigCalls(stub func(string, string) (bool, error)) {
	fake.deleteConfigMutex.Lock()
	defer fake.deleteConfigMutex.Unlock()
	fake.DeleteConfigStub = stub
}

func (fake *FakeDirector) DeleteConfigArgsForCall(i int) (string, string) {
	fake.deleteConfigMutex.RLock()
	defer fake.deleteConfigMutex.RUnlock()
	argsForCall := fake.deleteConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) DeleteConfigReturns(result1 bool, result2 error) {
	fake.deleteConfigMutex.Lock()
	defer fake.deleteConfigMutex.Unlock()
	fake.DeleteConfigStub = nil
	fake.deleteConfigReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DeleteConfigReturnsOnCall(i int, result1 bool, result2 error) {
	fake.deleteConfigMutex.Lock()
	defer fake.deleteConfigMutex.Unlock()
	fake.DeleteConfigStub = nil
	if fake.deleteConfigReturnsOnCall == nil {
		fake.deleteConfigReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deleteConfigReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DeleteConfigByID(arg1 string) (bool, error) {
	fake.deleteConfigByIDMutex.Lock()
	ret, specificReturn := fake.deleteConfigByIDReturnsOnCall[len(fake.deleteConfigByIDArgsForCall)]
	fake.deleteConfigByIDArgsForCall = append(fake.deleteConfigByIDArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteConfigByIDStub
	fakeReturns := fake.deleteConfigByIDReturns
	fake.recordInvocation("DeleteConfigByID", []interface{}{arg1})
	fake.deleteConfigByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) DeleteConfigByIDCallCount() int {
	fake.deleteConfigByIDMutex.RLock()
	defer fake.deleteConfigByIDMutex.RUnlock()
	return len(fake.deleteConfigByIDArgsForCall)
}

func (fake *FakeDirector) DeleteConfigByIDCalls(stub func(string) (bool, error)) {
	fake.deleteConfigByIDMutex.Lock()
	defer fake.deleteConfigByIDMutex.Unlock()
	fake.DeleteConfigByIDStub = stub
}

func (fake *FakeDirector) DeleteConfigByIDArgsForCall(i int) string {
	fake.deleteConfigByIDMutex.RLock()
	defer fake.deleteConfigByIDMutex.RUnlock()
	argsForCall := fake.deleteConfigByIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) DeleteConfigByIDReturns(result1 bool, result2 error) {
	fake.deleteConfigByIDMutex.Lock()
	defer fake.deleteConfigByIDMutex.Unlock()
	fake.DeleteConfigByIDStub = nil
	fake.deleteConfigByIDReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DeleteConfigByIDReturnsOnCall(i int, result1 bool, result2 error) {
	fake.deleteConfigByIDMutex.Lock()
	defer fake.deleteConfigByIDMutex.Unlock()
	fake.DeleteConfigByIDStub = nil
	if fake.deleteConfigByIDReturnsOnCall == nil {
		fake.deleteConfigByIDReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deleteConfigByIDReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Deployments() ([]director.Deployment, error) {
	fake.deploymentsMutex.Lock()
	ret, specificReturn := fake.deploymentsReturnsOnCall[len(fake.deploymentsArgsForCall)]
	fake.deploymentsArgsForCall = append(fake.deploymentsArgsForCall, struct {
	}{})
	stub := fake.DeploymentsStub
	fakeReturns := fake.deploymentsReturns
	fake.recordInvocation("Deployments", []interface{}{})
	fake.deploymentsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) DeploymentsCallCount() int {
	fake.deploymentsMutex.RLock()
	defer fake.deploymentsMutex.RUnlock()
	return len(fake.deploymentsArgsForCall)
}

func (fake *FakeDirector) DeploymentsCalls(stub func() ([]director.Deployment, error)) {
	fake.deploymentsMutex.Lock()
	defer fake.deploymentsMutex.Unlock()
	fake.DeploymentsStub = stub
}

func (fake *FakeDirector) DeploymentsReturns(result1 []director.Deployment, result2 error) {
	fake.deploymentsMutex.Lock()
	defer fake.deploymentsMutex.Unlock()
	fake.DeploymentsStub = nil
	fake.deploymentsReturns = struct {
		result1 []director.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DeploymentsReturnsOnCall(i int, result1 []director.Deployment, result2 error) {
	fake.deploymentsMutex.Lock()
	defer fake.deploymentsMutex.Unlock()
	fake.DeploymentsStub = nil
	if fake.deploymentsReturnsOnCall == nil {
		fake.deploymentsReturnsOnCall = make(map[int]struct {
			result1 []director.Deployment
			result2 error
		})
	}
	fake.deploymentsReturnsOnCall[i] = struct {
		result1 []director.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffCPIConfig(arg1 []byte, arg2 bool) (director.ConfigDiff, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.diffCPIConfigMutex.Lock()
	ret, specificReturn := fake.diffCPIConfigReturnsOnCall[len(fake.diffCPIConfigArgsForCall)]
	fake.diffCPIConfigArgsForCall = append(fake.diffCPIConfigArgsForCall, struct {
		arg1 []byte
		arg2 bool
	}{arg1Copy, arg2})
	stub := fake.DiffCPIConfigStub
	fakeReturns := fake.diffCPIConfigReturns
	fake.recordInvocation("DiffCPIConfig", []interface{}{arg1Copy, arg2})
	fake.diffCPIConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) DiffCPIConfigCallCount() int {
	fake.diffCPIConfigMutex.RLock()
	defer fake.diffCPIConfigMutex.RUnlock()
	return len(fake.diffCPIConfigArgsForCall)
}

func (fake *FakeDirector) DiffCPIConfigCalls(stub func([]byte, bool) (director.ConfigDiff, error)) {
	fake.diffCPIConfigMutex.Lock()
	defer fake.diffCPIConfigMutex.Unlock()
	fake.DiffCPIConfigStub = stub
}

func (fake *FakeDirector) DiffCPIConfigArgsForCall(i int) ([]byte, bool) {
	fake.diffCPIConfigMutex.RLock()
	defer fake.diffCPIConfigMutex.RUnlock()
	argsForCall := fake.diffCPIConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) DiffCPIConfigReturns(result1 director.ConfigDiff, result2 error) {
	fake.diffCPIConfigMutex.Lock()
	defer fake.diffCPIConfigMutex.Unlock()
	fake.DiffCPIConfigStub = nil
	fake.diffCPIConfigReturns = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffCPIConfigReturnsOnCall(i int, result1 director.ConfigDiff, result2 error) {
	fake.diffCPIConfigMutex.Lock()
	defer fake.diffCPIConfigMutex.Unlock()
	fake.DiffCPIConfigStub = nil
	if fake.diffCPIConfigReturnsOnCall == nil {
		fake.diffCPIConfigReturnsOnCall = make(map[int]struct {
			result1 director.ConfigDiff
			result2 error
		})
	}
	fake.diffCPIConfigReturnsOnCall[i] = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffCloudConfig(arg1 []byte) (director.ConfigDiff, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.diffCloudConfigMutex.Lock()
	ret, specificReturn := fake.diffCloudConfigReturnsOnCall[len(fake.diffCloudConfigArgsForCall)]
	fake.diffCloudConfigArgsForCall = append(fake.diffCloudConfigArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	stub := fake.DiffCloudConfigStub
	fakeReturns := fake.diffCloudConfigReturns
	fake.recordInvocation("DiffCloudConfig", []interface{}{arg1Copy})
	fake.diffCloudConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) DiffCloudConfigCallCount() int {
	fake.diffCloudConfigMutex.RLock()
	defer fake.diffCloudConfigMutex.RUnlock()
	return len(fake.diffCloudConfigArgsForCall)
}

func (fake *FakeDirector) DiffCloudConfigCalls(stub func([]byte) (director.ConfigDiff, error)) {
	fake.diffCloudConfigMutex.Lock()
	defer fake.diffCloudConfigMutex.Unlock()
	fake.DiffCloudConfigStub = stub
}

func (fake *FakeDirector) DiffCloudConfigArgsForCall(i int) []byte {
	fake.diffCloudConfigMutex.RLock()
	defer fake.diffCloudConfigMutex.RUnlock()
	argsForCall := fake.diffCloudConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) DiffCloudConfigReturns(result1 director.ConfigDiff, result2 error) {
	fake.diffCloudConfigMutex.Lock()
	defer fake.diffCloudConfigMutex.Unlock()
	fake.DiffCloudConfigStub = nil
	fake.diffCloudConfigReturns = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffCloudConfigReturnsOnCall(i int, result1 director.ConfigDiff, result2 error) {
	fake.diffCloudConfigMutex.Lock()
	defer fake.diffCloudConfigMutex.Unlock()
	fake.DiffCloudConfigStub = nil
	if fake.diffCloudConfigReturnsOnCall == nil {
		fake.diffCloudConfigReturnsOnCall = make(map[int]struct {
			result1 director.ConfigDiff
			result2 error
		})
	}
	fake.diffCloudConfigReturnsOnCall[i] = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffConfig(arg1 string, arg2 string, arg3 []byte) (director.ConfigDiff, error) {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.diffConfigMutex.Lock()
	ret, specificReturn := fake.diffConfigReturnsOnCall[len(fake.diffConfigArgsForCall)]
	fake.diffConfigArgsForCall = append(fake.diffConfigArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	stub := fake.DiffConfigStub
	fakeReturns := fake.diffConfigReturns
	fake.recordInvocation("DiffConfig", []interface{}{arg1, arg2, arg3Copy})
	fake.diffConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) DiffConfigCallCount() int {
	fake.diffConfigMutex.RLock()
	defer fake.diffConfigMutex.RUnlock()
	return len(fake.diffConfigArgsForCall)
}

func (fake *FakeDirector) DiffConfigCalls(stub func(string, string, []byte) (director.ConfigDiff, error)) {
	fake.diffConfigMutex.Lock()
	defer fake.diffConfigMutex.Unlock()
	fake.DiffConfigStub = stub
}

func (fake *FakeDirector) DiffConfigArgsForCall(i int) (string, string, []byte) {
	fake.diffConfigMutex.RLock()
	defer fake.diffConfigMutex.RUnlock()
	argsForCall := fake.diffConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDirector) DiffConfigReturns(result1 director.ConfigDiff, result2 error) {
	fake.diffConfigMutex.Lock()
	defer fake.diffConfigMutex.Unlock()
	fake.DiffConfigStub = nil
	fake.diffConfigReturns = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffConfigReturnsOnCall(i int, result1 director.ConfigDiff, result2 error) {
	fake.diffConfigMutex.Lock()
	defer fake.diffConfigMutex.Unlock()
	fake.DiffConfigStub = nil
	if fake.diffConfigReturnsOnCall == nil {
		fake.diffConfigReturnsOnCall = make(map[int]struct {
			result1 director.ConfigDiff
			result2 error
		})
	}
	fake.diffConfigReturnsOnCall[i] = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffConfigByIDOrContent(arg1 string, arg2 []byte, arg3 string, arg4 []byte) (director.ConfigDiff, error) {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	var arg4Copy []byte
	if arg4 != nil {
		arg4Copy = make([]byte, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.diffConfigByIDOrContentMutex.Lock()
	ret, specificReturn := fake.diffConfigByIDOrContentReturnsOnCall[len(fake.diffConfigByIDOrContentArgsForCall)]
	fake.diffConfigByIDOrContentArgsForCall = append(fake.diffConfigByIDOrContentArgsForCall, struct {
		arg1 string
		arg2 []byte
		arg3 string
		arg4 []byte
	}{arg1, arg2Copy, arg3, arg4Copy})
	stub := fake.DiffConfigByIDOrContentStub
	fakeReturns := fake.diffConfigByIDOrContentReturns
	fake.recordInvocation("DiffConfigByIDOrContent", []interface{}{arg1, arg2Copy, arg3, arg4Copy})
	fake.diffConfigByIDOrContentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) DiffConfigByIDOrContentCallCount() int {
	fake.diffConfigByIDOrContentMutex.RLock()
	defer fake.diffConfigByIDOrContentMutex.RUnlock()
	return len(fake.diffConfigByIDOrContentArgsForCall)
}

func (fake *FakeDirector) DiffConfigByIDOrContentCalls(stub func(string, []byte, string, []byte) (director.ConfigDiff, error)) {
	fake.diffConfigByIDOrContentMutex.Lock()
	defer fake.diffConfigByIDOrContentMutex.Unlock()
	fake.DiffConfigByIDOrContentStub = stub
}

func (fake *FakeDirector) DiffConfigByIDOrContentArgsForCall(i int) (string, []byte, string, []byte) {
	fake.diffConfigByIDOrContentMutex.RLock()
	defer fake.diffConfigByIDOrContentMutex.RUnlock()
	argsForCall := fake.diffConfigByIDOrContentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeDirector) DiffConfigByIDOrContentReturns(result1 director.ConfigDiff, result2 error) {
	fake.diffConfigByIDOrContentMutex.Lock()
	defer fake.diffConfigByIDOrContentMutex.Unlock()
	fake.DiffConfigByIDOrContentStub = nil
	fake.diffConfigByIDOrContentReturns = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffConfigByIDOrContentReturnsOnCall(i int, result1 director.ConfigDiff, result2 error) {
	fake.diffConfigByIDOrContentMutex.Lock()
	defer fake.diffConfigByIDOrContentMutex.Unlock()
	fake.DiffConfigByIDOrContentStub = nil
	if fake.diffConfigByIDOrContentReturnsOnCall == nil {
		fake.diffConfigByIDOrContentReturnsOnCall = make(map[int]struct {
			result1 director.ConfigDiff
			result2 error
		})
	}
	fake.diffConfigByIDOrContentReturnsOnCall[i] = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffRuntimeConfig(arg1 string, arg2 []byte, arg3 bool) (director.ConfigDiff, error) {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.diffRuntimeConfigMutex.Lock()
	ret, specificReturn := fake.diffRuntimeConfigReturnsOnCall[len(fake.diffRuntimeConfigArgsForCall)]
	fake.diffRuntimeConfigArgsForCall = append(fake.diffRuntimeConfigArgsForCall, struct {
		arg1 string
		arg2 []byte
		arg3 bool
	}{arg1, arg2Copy, arg3})
	stub := fake.DiffRuntimeConfigStub
	fakeReturns := fake.diffRuntimeConfigReturns
	fake.recordInvocation("DiffRuntimeConfig", []interface{}{arg1, arg2Copy, arg3})
	fake.diffRuntimeConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) DiffRuntimeConfigCallCount() int {
	fake.diffRuntimeConfigMutex.RLock()
	defer fake.diffRuntimeConfigMutex.RUnlock()
	return len(fake.diffRuntimeConfigArgsForCall)
}

func (fake *FakeDirector) DiffRuntimeConfigCalls(stub func(string, []byte, bool) (director.ConfigDiff, error)) {
	fake.diffRuntimeConfigMutex.Lock()
	defer fake.diffRuntimeConfigMutex.Unlock()
	fake.DiffRuntimeConfigStub = stub
}

func (fake *FakeDirector) DiffRuntimeConfigArgsForCall(i int) (string, []byte, bool) {
	fake.diffRuntimeConfigMutex.RLock()
	defer fake.diffRuntimeConfigMutex.RUnlock()
	argsForCall := fake.diffRuntimeConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDirector) DiffRuntimeConfigReturns(result1 director.ConfigDiff, result2 error) {
	fake.diffRuntimeConfigMutex.Lock()
	defer fake.diffRuntimeConfigMutex.Unlock()
	fake.DiffRuntimeConfigStub = nil
	fake.diffRuntimeConfigReturns = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffRuntimeConfigReturnsOnCall(i int, result1 director.ConfigDiff, result2 error) {
	fake.diffRuntimeConfigMutex.Lock()
	defer fake.diffRuntimeConfigMutex.Unlock()
	fake.DiffRuntimeConfigStub = nil
	if fake.diffRuntimeConfigReturnsOnCall == nil {
		fake.diffRuntimeConfigReturnsOnCall = make(map[int]struct {
			result1 director.ConfigDiff
			result2 error
		})
	}
	fake.diffRuntimeConfigReturnsOnCall[i] = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DownloadResourceUnchecked(arg1 string, arg2 io.Writer) error {
	fake.downloadResourceUncheckedMutex.Lock()
	ret, specificReturn := fake.downloadResourceUncheckedReturnsOnCall[len(fake.downloadResourceUncheckedArgsForCall)]
	fake.downloadResourceUncheckedArgsForCall = append(fake.downloadResourceUncheckedArgsForCall, struct {
		arg1 string
		arg2 io.Writer
	}{arg1, arg2})
	stub := fake.DownloadResourceUncheckedStub
	fakeReturns := fake.downloadResourceUncheckedReturns
	fake.recordInvocation("DownloadResourceUnchecked", []interface{}{arg1, arg2})
	fake.downloadResourceUncheckedMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDirector) DownloadResourceUncheckedCallCount() int {
	fake.downloadResourceUncheckedMutex.RLock()
	defer fake.downloadResourceUncheckedMutex.RUnlock()
	return len(fake.downloadResourceUncheckedArgsForCall)
}

func (fake *FakeDirector) DownloadResourceUncheckedCalls(stub func(string, io.Writer) error) {
	fake.downloadResourceUncheckedMutex.Lock()
	defer fake.downloadResourceUncheckedMutex.Unlock()
	fake.DownloadResourceUncheckedStub = stub
}

func (fake *FakeDirector) DownloadResourceUncheckedArgsForCall(i int) (string, io.Writer) {
	fake.downloadResourceUncheckedMutex.RLock()
	defer fake.downloadResourceUncheckedMutex.RUnlock()
	argsForCall := fake.downloadResourceUncheckedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) DownloadResourceUncheckedReturns(result1 error) {
	fake.downloadResourceUncheckedMutex.Lock()
	defer fake.downloadResourceUncheckedMutex.Unlock()
	fake.DownloadResourceUncheckedStub = nil
	fake.downloadResourceUncheckedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) DownloadResourceUncheckedReturnsOnCall(i int, result1 error) {
	fake.downloadResourceUncheckedMutex.Lock()
	defer fake.downloadResourceUncheckedMutex.Unlock()
	fake.DownloadResourceUncheckedStub = nil
	if fake.downloadResourceUncheckedReturnsOnCall == nil {
		fake.downloadResourceUncheckedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.downloadResourceUncheckedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) EnableResurrection(arg1 bool) error {
	fake.enableResurrectionMutex.Lock()
	ret, specificReturn := fake.enableResurrectionReturnsOnCall[len(fake.enableResurrectionArgsForCall)]
	fake.enableResurrectionArgsForCall = append(fake.enableResurrectionArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.EnableResurrectionStub
	fakeReturns := fake.enableResurrectionReturns
	fake.recordInvocation("EnableResurrection", []interface{}{arg1})
	fake.enableResurrectionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDirector) EnableResurrectionCallCount() int {
	fake.enableResurrectionMutex.RLock()
	defer fake.enableResurrectionMutex.RUnlock()
	return len(fake.enableResurrectionArgsForCall)
}

func (fake *FakeDirector) EnableResurrectionCalls(stub func(bool) error) {
	fake.enableResurrectionMutex.Lock()
	defer fake.enableResurrectionMutex.Unlock()
	fake.EnableResurrectionStub = stub
}

func (fake *FakeDirector) EnableResurrectionArgsForCall(i int) bool {
	fake.enableResurrectionMutex.RLock()
	defer fake.enableResurrectionMutex.RUnlock()
	argsForCall := fake.enableResurrectionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) EnableResurrectionReturns(result1 error) {
	fake.enableResurrectionMutex.Lock()
	defer fake.enableResurrectionMutex.Unlock()
	fake.EnableResurrectionStub = nil
	fake.enableResurrectionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) EnableResurrectionReturnsOnCall(i int, result1 error) {
	fake.enableResurrectionMutex.Lock()
	defer fake.enableResurrectionMutex.Unlock()
	fake.EnableResurrectionStub = nil
	if fake.enableResurrectionReturnsOnCall == nil {
		fake.enableResurrectionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.enableResurrectionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) Event(arg1 string) (director.Event, error) {
	fake.eventMutex.Lock()
	ret, specificReturn := fake.eventReturnsOnCall[len(fake.eventArgsForCall)]
	fake.eventArgsForCall = append(fake.eventArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.EventStub
	fakeReturns := fake.eventReturns
	fake.recordInvocation("Event", []interface{}{arg1})
	fake.eventMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) EventCallCount() int {
	fake.eventMutex.RLock()
	defer fake.eventMutex.RUnlock()
	return len(fake.eventArgsForCall)
}

func (fake *FakeDirector) EventCalls(stub func(string) (director.Event, error)) {
	fake.eventMutex.Lock()
	defer fake.eventMutex.Unlock()
	fake.EventStub = stub
}

func (fake *FakeDirector) EventArgsForCall(i int) string {
	fake.eventMutex.RLock()
	defer fake.eventMutex.RUnlock()
	argsForCall := fake.eventArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) EventReturns(result1 director.Event, result2 error) {
	fake.eventMutex.Lock()
	defer fake.eventMutex.Unlock()
	fake.EventStub = nil
	fake.eventReturns = struct {
		result1 director.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) EventReturnsOnCall(i int, result1 director.Event, result2 error) {
	fake.eventMutex.Lock()
	defer fake.eventMutex.Unlock()
	fake.EventStub = nil
	if fake.eventReturnsOnCall == nil {
		fake.eventReturnsOnCall = make(map[int]struct {
			result1 director.Event
			result2 error
		})
	}
	fake.eventReturnsOnCall[i] = struct {
		result1 director.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Events(arg1 director.EventsFilter) ([]director.Event, error) {
	fake.eventsMutex.Lock()
	ret, specificReturn := fake.eventsReturnsOnCall[len(fake.eventsArgsForCall)]
	fake.eventsArgsForCall = append(fake.eventsArgsForCall, struct {
		arg1 director.EventsFilter
	}{arg1})
	stub := fake.EventsStub
	fakeReturns := fake.eventsReturns
	fake.recordInvocation("Events", []interface{}{arg1})
	fake.eventsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) EventsCallCount() int {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	return len(fake.eventsArgsForCall)
}

func (fake *FakeDirector) EventsCalls(stub func(director.EventsFilter) ([]director.Event, error)) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = stub
}

func (fake *FakeDirector) EventsArgsForCall(i int) director.EventsFilter {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	argsForCall := fake.eventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) EventsReturns(result1 []director.Event, result2 error) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = nil
	fake.eventsReturns = struct {
		result1 []director.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) EventsReturnsOnCall(i int, result1 []director.Event, result2 error) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = nil
	if fake.eventsReturnsOnCall == nil {
		fake.eventsReturnsOnCall = make(map[int]struct {
			result1 []director.Event
			result2 error
		})
	}
	fake.eventsReturnsOnCall[i] = struct {
		result1 []director.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindDeployment(arg1 string) (director.Deployment, error) {
	fake.findDeploymentMutex.Lock()
	ret, specificReturn := fake.findDeploymentReturnsOnCall[len(fake.findDeploymentArgsForCall)]
	fake.findDeploymentArgsForCall = append(fake.findDeploymentArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FindDeploymentStub
	fakeReturns := fake.findDeploymentReturns
	fake.recordInvocation("FindDeployment", []interface{}{arg1})
	fake.findDeploymentMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) FindDeploymentCallCount() int {
	fake.findDeploymentMutex.RLock()
	defer fake.findDeploymentMutex.RUnlock()
	return len(fake.findDeploymentArgsForCall)
}

func (fake *FakeDirector) FindDeploymentCalls(stub func(string) (director.Deployment, error)) {
	fake.findDeploymentMutex.Lock()
	defer fake.findDeploymentMutex.Unlock()
	fake.FindDeploymentStub = stub
}

func (fake *FakeDirector) FindDeploymentArgsForCall(i int) string {
	fake.findDeploymentMutex.RLock()
	defer fake.findDeploymentMutex.RUnlock()
	argsForCall := fake.findDeploymentArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) FindDeploymentReturns(result1 director.Deployment, result2 error) {
	fake.findDeploymentMutex.Lock()
	defer fake.findDeploymentMutex.Unlock()
	fake.FindDeploymentStub = nil
	fake.findDeploymentReturns = struct {
		result1 director.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindDeploymentReturnsOnCall(i int, result1 director.Deployment, result2 error) {
	fake.findDeploymentMutex.Lock()
	defer fake.findDeploymentMutex.Unlock()
	fake.FindDeploymentStub = nil
	if fake.findDeploymentReturnsOnCall == nil {
		fake.findDeploymentReturnsOnCall = make(map[int]struct {
			result1 director.Deployment
			result2 error
		})
	}
	fake.findDeploymentReturnsOnCall[i] = struct {
		result1 director.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindOrphanDisk(arg1 string) (director.OrphanDisk, error) {
	fake.findOrphanDiskMutex.Lock()
	ret, specificReturn := fake.findOrphanDiskReturnsOnCall[len(fake.findOrphanDiskArgsForCall)]
	fake.findOrphanDiskArgsForCall = append(fake.findOrphanDiskArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FindOrphanDiskStub
	fakeReturns := fake.findOrphanDiskReturns
	fake.recordInvocation("FindOrphanDisk", []interface{}{arg1})
	fake.findOrphanDiskMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) FindOrphanDiskCallCount() int {
	fake.findOrphanDiskMutex.RLock()
	defer fake.findOrphanDiskMutex.RUnlock()
	return len(fake.findOrphanDiskArgsForCall)
}

func (fake *FakeDirector) FindOrphanDiskCalls(stub func(string) (director.OrphanDisk, error)) {
	fake.findOrphanDiskMutex.Lock()
	defer fake.findOrphanDiskMutex.Unlock()
	fake.FindOrphanDiskStub = stub
}

func (fake *FakeDirector) FindOrphanDiskArgsForCall(i int) string {
	fake.findOrphanDiskMutex.RLock()
	defer fake.findOrphanDiskMutex.RUnlock()
	argsForCall := fake.findOrphanDiskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) FindOrphanDiskReturns(result1 director.OrphanDisk, result2 error) {
	fake.findOrphanDiskMutex.Lock()
	defer fake.findOrphanDiskMutex.Unlock()
	fake.FindOrphanDiskStub = nil
	fake.findOrphanDiskReturns = struct {
		result1 director.OrphanDisk
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindOrphanDiskReturnsOnCall(i int, result1 director.OrphanDisk, result2 error) {
	fake.findOrphanDiskMutex.Lock()
	defer fake.findOrphanDiskMutex.Unlock()
	fake.FindOrphanDiskStub = nil
	if fake.findOrphanDiskReturnsOnCall == nil {
		fake.findOrphanDiskReturnsOnCall = make(map[int]struct {
			result1 director.OrphanDisk
			result2 error
		})
	}
	fake.findOrphanDiskReturnsOnCall[i] = struct {
		result1 director.OrphanDisk
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindOrphanNetwork(arg1 string) (director.OrphanNetwork, error) {
	fake.findOrphanNetworkMutex.Lock()
	ret, specificReturn := fake.findOrphanNetworkReturnsOnCall[len(fake.findOrphanNetworkArgsForCall)]
	fake.findOrphanNetworkArgsForCall = append(fake.findOrphanNetworkArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FindOrphanNetworkStub
	fakeReturns := fake.findOrphanNetworkReturns
	fake.recordInvocation("FindOrphanNetwork", []interface{}{arg1})
	fake.findOrphanNetworkMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) FindOrphanNetworkCallCount() int {
	fake.findOrphanNetworkMutex.RLock()
	defer fake.findOrphanNetworkMutex.RUnlock()
	return len(fake.findOrphanNetworkArgsForCall)
}

func (fake *FakeDirector) FindOrphanNetworkCalls(stub func(string) (director.OrphanNetwork, error)) {
	fake.findOrphanNetworkMutex.Lock()
	defer fake.findOrphanNetworkMutex.Unlock()
	fake.FindOrphanNetworkStub = stub
}

func (fake *FakeDirector) FindOrphanNetworkArgsForCall(i int) string {
	fake.findOrphanNetworkMutex.RLock()
	defer fake.findOrphanNetworkMutex.RUnlock()
	argsForCall := fake.findOrphanNetworkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) FindOrphanNetworkReturns(result1 director.OrphanNetwork, result2 error) {
	fake.findOrphanNetworkMutex.Lock()
	defer fake.findOrphanNetworkMutex.Unlock()
	fake.FindOrphanNetworkStub = nil
	fake.findOrphanNetworkReturns = struct {
		result1 director.OrphanNetwork
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindOrphanNetworkReturnsOnCall(i int, result1 director.OrphanNetwork, result2 error) {
	fake.findOrphanNetworkMutex.Lock()
	defer fake.findOrphanNetworkMutex.Unlock()
	fake.FindOrphanNetworkStub = nil
	if fake.findOrphanNetworkReturnsOnCall == nil {
		fake.findOrphanNetworkReturnsOnCall = make(map[int]struct {
			result1 director.OrphanNetwork
			result2 error
		})
	}
	fake.findOrphanNetworkReturnsOnCall[i] = struct {
		result1 director.OrphanNetwork
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindRelease(arg1 director.ReleaseSlug) (director.Release, error) {
	fake.findReleaseMutex.Lock()
	ret, specificReturn := fake.findReleaseReturnsOnCall[len(fake.findReleaseArgsForCall)]
	fake.findReleaseArgsForCall = append(fake.findReleaseArgsForCall, struct {
		arg1 director.ReleaseSlug
	}{arg1})
	stub := fake.FindReleaseStub
	fakeReturns := fake.findReleaseReturns
	fake.recordInvocation("FindRelease", []interface{}{arg1})
	fake.findReleaseMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) FindReleaseCallCount() int {
	fake.findReleaseMutex.RLock()
	defer fake.findReleaseMutex.RUnlock()
	return len(fake.findReleaseArgsForCall)
}

func (fake *FakeDirector) FindReleaseCalls(stub func(director.ReleaseSlug) (director.Release, error)) {
	fake.findReleaseMutex.Lock()
	defer fake.findReleaseMutex.Unlock()
	fake.FindReleaseStub = stub
}

func (fake *FakeDirector) FindReleaseArgsForCall(i int) director.ReleaseSlug {
	fake.findReleaseMutex.RLock()
	defer fake.findReleaseMutex.RUnlock()
	argsForCall := fake.findReleaseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) FindReleaseReturns(result1 director.Release, result2 error) {
	fake.findReleaseMutex.Lock()
	defer fake.findReleaseMutex.Unlock()
	fake.FindReleaseStub = nil
	fake.findReleaseReturns = struct {
		result1 director.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindReleaseReturnsOnCall(i int, result1 director.Release, result2 error) {
	fake.findReleaseMutex.Lock()
	defer fake.findReleaseMutex.Unlock()
	fake.FindReleaseStub = nil
	if fake.findReleaseReturnsOnCall == nil {
		fake.findReleaseReturnsOnCall = make(map[int]struct {
			result1 director.Release
			result2 error
		})
	}
	fake.findReleaseReturnsOnCall[i] = struct {
		result1 director.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindReleaseSeries(arg1 director.ReleaseSeriesSlug) (director.ReleaseSeries, error) {
	fake.findReleaseSeriesMutex.Lock()
	ret, specificReturn := fake.findReleaseSeriesReturnsOnCall[len(fake.findReleaseSeriesArgsForCall)]
	fake.findReleaseSeriesArgsForCall = append(fake.findReleaseSeriesArgsForCall, struct {
		arg1 director.ReleaseSeriesSlug
	}{arg1})
	stub := fake.FindReleaseSeriesStub
	fakeReturns := fake.findReleaseSeriesReturns
	fake.recordInvocation("FindReleaseSeries", []interface{}{arg1})
	fake.findReleaseSeriesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) FindReleaseSeriesCallCount() int {
	fake.findReleaseSeriesMutex.RLock()
	defer fake.findReleaseSeriesMutex.RUnlock()
	return len(fake.findReleaseSeriesArgsForCall)
}

func (fake *FakeDirector) FindReleaseSeriesCalls(stub func(director.ReleaseSeriesSlug) (director.ReleaseSeries, error)) {
	fake.findReleaseSeriesMutex.Lock()
	defer fake.findReleaseSeriesMutex.Unlock()
	fake.FindReleaseSeriesStub = stub
}

func (fake *FakeDirector) FindReleaseSeriesArgsForCall(i int) director.ReleaseSeriesSlug {
	fake.findReleaseSeriesMutex.RLock()
	defer fake.findReleaseSeriesMutex.RUnlock()
	argsForCall := fake.findReleaseSeriesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) FindReleaseSeriesReturns(result1 director.ReleaseSeries, result2 error) {
	fake.findReleaseSeriesMutex.Lock()
	defer fake.findReleaseSeriesMutex.Unlock()
	fake.FindReleaseSeriesStub = nil
	fake.findReleaseSeriesReturns = struct {
		result1 director.ReleaseSeries
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindReleaseSeriesReturnsOnCall(i int, result1 director.ReleaseSeries, result2 error) {
	fake.findReleaseSeriesMutex.Lock()
	defer fake.findReleaseSeriesMutex.Unlock()
	fake.FindReleaseSeriesStub = nil
	if fake.findReleaseSeriesReturnsOnCall == nil {
		fake.findReleaseSeriesReturnsOnCall = make(map[int]struct {
			result1 director.ReleaseSeries
			result2 error
		})
	}
	fake.findReleaseSeriesReturnsOnCall[i] = struct {
		result1 director.ReleaseSeries
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindStemcell(arg1 director.StemcellSlug) (director.Stemcell, error) {
	fake.findStemcellMutex.Lock()
	ret, specificReturn := fake.findStemcellReturnsOnCall[len(fake.findStemcellArgsForCall)]
	fake.findStemcellArgsForCall = append(fake.findStemcellArgsForCall, struct {
		arg1 director.StemcellSlug
	}{arg1})
	stub := fake.FindStemcellStub
	fakeReturns := fake.findStemcellReturns
	fake.recordInvocation("FindStemcell", []interface{}{arg1})
	fake.findStemcellMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) FindStemcellCallCount() int {
	fake.findStemcellMutex.RLock()
	defer fake.findStemcellMutex.RUnlock()
	return len(fake.findStemcellArgsForCall)
}

func (fake *FakeDirector) FindStemcellCalls(stub func(director.StemcellSlug) (director.Stemcell, error)) {
	fake.findStemcellMutex.Lock()
	defer fake.findStemcellMutex.Unlock()
	fake.FindStemcellStub = stub
}

func (fake *FakeDirector) FindStemcellArgsForCall(i int) director.StemcellSlug {
	fake.findStemcellMutex.RLock()
	defer fake.findStemcellMutex.RUnlock()
	argsForCall := fake.findStemcellArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) FindStemcellReturns(result1 director.Stemcell, result2 error) {
	fake.findStemcellMutex.Lock()
	defer fake.findStemcellMutex.Unlock()
	fake.FindStemcellStub = nil
	fake.findStemcellReturns = struct {
		result1 director.Stemcell
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindStemcellReturnsOnCall(i int, result1 director.Stemcell, result2 error) {
	fake.findStemcellMutex.Lock()
	defer fake.findStemcellMutex.Unlock()
	fake.FindStemcellStub = nil
	if fake.findStemcellReturnsOnCall == nil {
		fake.findStemcellReturnsOnCall = make(map[int]struct {
			result1 director.Stemcell
			result2 error
		})
	}
	fake.findStemcellReturnsOnCall[i] = struct {
		result1 director.Stemcell
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindTask(arg1 int) (director.Task, error) {
	fake.findTaskMutex.Lock()
	ret, specificReturn := fake.findTaskReturnsOnCall[len(fake.findTaskArgsForCall)]
	fake.findTaskArgsForCall = append(fake.findTaskArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.FindTaskStub
	fakeReturns := fake.findTaskReturns
	fake.recordInvocation("FindTask", []interface{}{arg1})
	fake.findTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) FindTaskCallCount() int {
	fake.findTaskMutex.RLock()
	defer fake.findTaskMutex.RUnlock()
	return len(fake.findTaskArgsForCall)
}

func (fake *FakeDirector) FindTaskCalls(stub func(int) (director.Task, error)) {
	fake.findTaskMutex.Lock()
	defer fake.findTaskMutex.Unlock()
	fake.FindTaskStub = stub
}

func (fake *FakeDirector) FindTaskArgsForCall(i int) int {
	fake.findTaskMutex.RLock()
	defer fake.findTaskMutex.RUnlock()
	argsForCall := fake.findTaskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) FindTaskReturns(result1 director.Task, result2 error) {
	fake.findTaskMutex.Lock()
	defer fake.findTaskMutex.Unlock()
	fake.FindTaskStub = nil
	fake.findTaskReturns = struct {
		result1 director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindTaskReturnsOnCall(i int, result1 director.Task, result2 error) {
	fake.findTaskMutex.Lock()
	defer fake.findTaskMutex.Unlock()
	fake.FindTaskStub = nil
	if fake.findTaskReturnsOnCall == nil {
		fake.findTaskReturnsOnCall = make(map[int]struct {
			result1 director.Task
			result2 error
		})
	}
	fake.findTaskReturnsOnCall[i] = struct {
		result1 director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindTasksByContextId(arg1 string) ([]director.Task, error) {
	fake.findTasksByContextIdMutex.Lock()
	ret, specificReturn := fake.findTasksByContextIdReturnsOnCall[len(fake.findTasksByContextIdArgsForCall)]
	fake.findTasksByContextIdArgsForCall = append(fake.findTasksByContextIdArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FindTasksByContextIdStub
	fakeReturns := fake.findTasksByContextIdReturns
	fake.recordInvocation("FindTasksByContextId", []interface{}{arg1})
	fake.findTasksByContextIdMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) FindTasksByContextIdCallCount() int {
	fake.findTasksByContextIdMutex.RLock()
	defer fake.findTasksByContextIdMutex.RUnlock()
	return len(fake.findTasksByContextIdArgsForCall)
}

func (fake *FakeDirector) FindTasksByContextIdCalls(stub func(string) ([]director.Task, error)) {
	fake.findTasksByContextIdMutex.Lock()
	defer fake.findTasksByContextIdMutex.Unlock()
	fake.FindTasksByContextIdStub = stub
}

func (fake *FakeDirector) FindTasksByContextIdArgsForCall(i int) string {
	fake.findTasksByContextIdMutex.RLock()
	defer fake.findTasksByContextIdMutex.RUnlock()
	argsForCall := fake.findTasksByContextIdArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) FindTasksByContextIdReturns(result1 []director.Task, result2 error) {
	fake.findTasksByContextIdMutex.Lock()
	defer fake.findTasksByContextIdMutex.Unlock()
	fake.FindTasksByContextIdStub = nil
	fake.findTasksByContextIdReturns = struct {
		result1 []director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindTasksByContextIdReturnsOnCall(i int, result1 []director.Task, result2 error) {
	fake.findTasksByContextIdMutex.Lock()
	defer fake.findTasksByContextIdMutex.Unlock()
	fake.FindTasksByContextIdStub = nil
	if fake.findTasksByContextIdReturnsOnCall == nil {
		fake.findTasksByContextIdReturnsOnCall = make(map[int]struct {
			result1 []director.Task
			result2 error
		})
	}
	fake.findTasksByContextIdReturnsOnCall[i] = struct {
		result1 []director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) HasRelease(arg1 string, arg2 string, arg3 director.OSVersionSlug) (bool, error) {
	fake.hasReleaseMutex.Lock()
	ret, specificReturn := fake.hasReleaseReturnsOnCall[len(fake.hasReleaseArgsForCall)]
	fake.hasReleaseArgsForCall = append(fake.hasReleaseArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 director.OSVersionSlug
	}{arg1, arg2, arg3})
	stub := fake.HasReleaseStub
	fakeReturns := fake.hasReleaseReturns
	fake.recordInvocation("HasRelease", []interface{}{arg1, arg2, arg3})
	fake.hasReleaseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) HasReleaseCallCount() int {
	fake.hasReleaseMutex.RLock()
	defer fake.hasReleaseMutex.RUnlock()
	return len(fake.hasReleaseArgsForCall)
}

func (fake *FakeDirector) HasReleaseCalls(stub func(string, string, director.OSVersionSlug) (bool, error)) {
	fake.hasReleaseMutex.Lock()
	defer fake.hasReleaseMutex.Unlock()
	fake.HasReleaseStub = stub
}

func (fake *FakeDirector) HasReleaseArgsForCall(i int) (string, string, director.OSVersionSlug) {
	fake.hasReleaseMutex.RLock()
	defer fake.hasReleaseMutex.RUnlock()
	argsForCall := fake.hasReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDirector) HasReleaseReturns(result1 bool, result2 error) {
	fake.hasReleaseMutex.Lock()
	defer fake.hasReleaseMutex.Unlock()
	fake.HasReleaseStub = nil
	fake.hasReleaseReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) HasReleaseReturnsOnCall(i int, result1 bool, result2 error) {
	fake.hasReleaseMutex.Lock()
	defer fake.hasReleaseMutex.Unlock()
	fake.HasReleaseStub = nil
	if fake.hasReleaseReturnsOnCall == nil {
		fake.hasReleaseReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.hasReleaseReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Info() (director.Info, error) {
	fake.infoMutex.Lock()
	ret, specificReturn := fake.infoReturnsOnCall[len(fake.infoArgsForCall)]
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct {
	}{})
	stub := fake.InfoStub
	fakeReturns := fake.infoReturns
	fake.recordInvocation("Info", []interface{}{})
	fake.infoMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

func (fake *FakeDirector) InfoCalls(stub func() (director.Info, error)) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = stub
}

func (fake *FakeDirector) InfoReturns(result1 director.Info, result2 error) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = nil
	fake.infoReturns = struct {
		result1 director.Info
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) InfoReturnsOnCall(i int, result1 director.Info, result2 error) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = nil
	if fake.infoReturnsOnCall == nil {
		fake.infoReturnsOnCall = make(map[int]struct {
			result1 director.Info
			result2 error
		})
	}
	fake.infoReturnsOnCall[i] = struct {
		result1 director.Info
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) IsAuthenticated() (bool, error) {
	fake.isAuthenticatedMutex.Lock()
	ret, specificReturn := fake.isAuthenticatedReturnsOnCall[len(fake.isAuthenticatedArgsForCall)]
	fake.isAuthenticatedArgsForCall = append(fake.isAuthenticatedArgsForCall, struct {
	}{})
	stub := fake.IsAuthenticatedStub
	fakeReturns := fake.isAuthenticatedReturns
	fake.recordInvocation("IsAuthenticated", []interface{}{})
	fake.isAuthenticatedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) IsAuthenticatedCallCount() int {
	fake.isAuthenticatedMutex.RLock()
	defer fake.isAuthenticatedMutex.RUnlock()
	return len(fake.isAuthenticatedArgsForCall)
}

func (fake *FakeDirector) IsAuthenticatedCalls(stub func() (bool, error)) {
	fake.isAuthenticatedMutex.Lock()
	defer fake.isAuthenticatedMutex.Unlock()
	fake.IsAuthenticatedStub = stub
}

func (fake *FakeDirector) IsAuthenticatedReturns(result1 bool, result2 error) {
	fake.isAuthenticatedMutex.Lock()
	defer fake.isAuthenticatedMutex.Unlock()
	fake.IsAuthenticatedStub = nil
	fake.isAuthenticatedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) IsAuthenticatedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isAuthenticatedMutex.Lock()
	defer fake.isAuthenticatedMutex.Unlock()
	fake.IsAuthenticatedStub = nil
	if fake.isAuthenticatedReturnsOnCall == nil {
		fake.isAuthenticatedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isAuthenticatedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestCPIConfig() (director.CPIConfig, error) {
	fake.latestCPIConfigMutex.Lock()
	ret, specificReturn := fake.latestCPIConfigReturnsOnCall[len(fake.latestCPIConfigArgsForCall)]
	fake.latestCPIConfigArgsForCall = append(fake.latestCPIConfigArgsForCall, struct {
	}{})
	stub := fake.LatestCPIConfigStub
	fakeReturns := fake.latestCPIConfigReturns
	fake.recordInvocation("LatestCPIConfig", []interface{}{})
	fake.latestCPIConfigMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) LatestCPIConfigCallCount() int {
	fake.latestCPIConfigMutex.RLock()
	defer fake.latestCPIConfigMutex.RUnlock()
	return len(fake.latestCPIConfigArgsForCall)
}

func (fake *FakeDirector) LatestCPIConfigCalls(stub func() (director.CPIConfig, error)) {
	fake.latestCPIConfigMutex.Lock()
	defer fake.latestCPIConfigMutex.Unlock()
	fake.LatestCPIConfigStub = stub
}

func (fake *FakeDirector) LatestCPIConfigReturns(result1 director.CPIConfig, result2 error) {
	fake.latestCPIConfigMutex.Lock()
	defer fake.latestCPIConfigMutex.Unlock()
	fake.LatestCPIConfigStub = nil
	fake.latestCPIConfigReturns = struct {
		result1 director.CPIConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestCPIConfigReturnsOnCall(i int, result1 director.CPIConfig, result2 error) {
	fake.latestCPIConfigMutex.Lock()
	defer fake.latestCPIConfigMutex.Unlock()
	fake.LatestCPIConfigStub = nil
	if fake.latestCPIConfigReturnsOnCall == nil {
		fake.latestCPIConfigReturnsOnCall = make(map[int]struct {
			result1 director.CPIConfig
			result2 error
		})
	}
	fake.latestCPIConfigReturnsOnCall[i] = struct {
		result1 director.CPIConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestCloudConfig() (director.CloudConfig, error) {
	fake.latestCloudConfigMutex.Lock()
	ret, specificReturn := fake.latestCloudConfigReturnsOnCall[len(fake.latestCloudConfigArgsForCall)]
	fake.latestCloudConfigArgsForCall = append(fake.latestCloudConfigArgsForCall, struct {
	}{})
	stub := fake.LatestCloudConfigStub
	fakeReturns := fake.latestCloudConfigReturns
	fake.recordInvocation("LatestCloudConfig", []interface{}{})
	fake.latestCloudConfigMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) LatestCloudConfigCallCount() int {
	fake.latestCloudConfigMutex.RLock()
	defer fake.latestCloudConfigMutex.RUnlock()
	return len(fake.latestCloudConfigArgsForCall)
}

func (fake *FakeDirector) LatestCloudConfigCalls(stub func() (director.CloudConfig, error)) {
	fake.latestCloudConfigMutex.Lock()
	defer fake.latestCloudConfigMutex.Unlock()
	fake.LatestCloudConfigStub = stub
}

func (fake *FakeDirector) LatestCloudConfigReturns(result1 director.CloudConfig, result2 error) {
	fake.latestCloudConfigMutex.Lock()
	defer fake.latestCloudConfigMutex.Unlock()
	fake.LatestCloudConfigStub = nil
	fake.latestCloudConfigReturns = struct {
		result1 director.CloudConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestCloudConfigReturnsOnCall(i int, result1 director.CloudConfig, result2 error) {
	fake.latestCloudConfigMutex.Lock()
	defer fake.latestCloudConfigMutex.Unlock()
	fake.LatestCloudConfigStub = nil
	if fake.latestCloudConfigReturnsOnCall == nil {
		fake.latestCloudConfigReturnsOnCall = make(map[int]struct {
			result1 director.CloudConfig
			result2 error
		})
	}
	fake.latestCloudConfigReturnsOnCall[i] = struct {
		result1 director.CloudConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestConfig(arg1 string, arg2 string) (director.Config, error) {
	fake.latestConfigMutex.Lock()
	ret, specificReturn := fake.latestConfigReturnsOnCall[len(fake.latestConfigArgsForCall)]
	fake.latestConfigArgsForCall = append(fake.latestConfigArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.LatestConfigStub
	fakeReturns := fake.latestConfigReturns
	fake.recordInvocation("LatestConfig", []interface{}{arg1, arg2})
	fake.latestConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) LatestConfigCallCount() int {
	fake.latestConfigMutex.RLock()
	defer fake.latestConfigMutex.RUnlock()
	return len(fake.latestConfigArgsForCall)
}

func (fake *FakeDirector) LatestConfigCalls(stub func(string, string) (director.Config, error)) {
	fake.latestConfigMutex.Lock()
	defer fake.latestConfigMutex.Unlock()
	fake.LatestConfigStub = stub
}

func (fake *FakeDirector) LatestConfigArgsForCall(i int) (string, string) {
	fake.latestConfigMutex.RLock()
	defer fake.latestConfigMutex.RUnlock()
	argsForCall := fake.latestConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) LatestConfigReturns(result1 director.Config, result2 error) {
	fake.latestConfigMutex.Lock()
	defer fake.latestConfigMutex.Unlock()
	fake.LatestConfigStub = nil
	fake.latestConfigReturns = struct {
		result1 director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestConfigReturnsOnCall(i int, result1 director.Config, result2 error) {
	fake.latestConfigMutex.Lock()
	defer fake.latestConfigMutex.Unlock()
	fake.LatestConfigStub = nil
	if fake.latestConfigReturnsOnCall == nil {
		fake.latestConfigReturnsOnCall = make(map[int]struct {
			result1 director.Config
			result2 error
		})
	}
	fake.latestConfigReturnsOnCall[i] = struct {
		result1 director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestConfigByID(arg1 string) (director.Config, error) {
	fake.latestConfigByIDMutex.Lock()
	ret, specificReturn := fake.latestConfigByIDReturnsOnCall[len(fake.latestConfigByIDArgsForCall)]
	fake.latestConfigByIDArgsForCall = append(fake.latestConfigByIDArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.LatestConfigByIDStub
	fakeReturns := fake.latestConfigByIDReturns
	fake.recordInvocation("LatestConfigByID", []interface{}{arg1})
	fake.latestConfigByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) LatestConfigByIDCallCount() int {
	fake.latestConfigByIDMutex.RLock()
	defer fake.latestConfigByIDMutex.RUnlock()
	return len(fake.latestConfigByIDArgsForCall)
}

func (fake *FakeDirector) LatestConfigByIDCalls(stub func(string) (director.Config, error)) {
	fake.latestConfigByIDMutex.Lock()
	defer fake.latestConfigByIDMutex.Unlock()
	fake.LatestConfigByIDStub = stub
}

func (fake *FakeDirector) LatestConfigByIDArgsForCall(i int) string {
	fake.latestConfigByIDMutex.RLock()
	defer fake.latestConfigByIDMutex.RUnlock()
	argsForCall := fake.latestConfigByIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) LatestConfigByIDReturns(result1 director.Config, result2 error) {
	fake.latestConfigByIDMutex.Lock()
	defer fake.latestConfigByIDMutex.Unlock()
	fake.LatestConfigByIDStub = nil
	fake.latestConfigByIDReturns = struct {
		result1 director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestConfigByIDReturnsOnCall(i int, result1 director.Config, result2 error) {
	fake.latestConfigByIDMutex.Lock()
	defer fake.latestConfigByIDMutex.Unlock()
	fake.LatestConfigByIDStub = nil
	if fake.latestConfigByIDReturnsOnCall == nil {
		fake.latestConfigByIDReturnsOnCall = make(map[int]struct {
			result1 director.Config
			result2 error
		})
	}
	fake.latestConfigByIDReturnsOnCall[i] = struct {
		result1 director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestRuntimeConfig(arg1 string) (director.RuntimeConfig, error) {
	fake.latestRuntimeConfigMutex.Lock()
	ret, specificReturn := fake.latestRuntimeConfigReturnsOnCall[len(fake.latestRuntimeConfigArgsForCall)]
	fake.latestRuntimeConfigArgsForCall = append(fake.latestRuntimeConfigArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.LatestRuntimeConfigStub
	fakeReturns := fake.latestRuntimeConfigReturns
	fake.recordInvocation("LatestRuntimeConfig", []interface{}{arg1})
	fake.latestRuntimeConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) LatestRuntimeConfigCallCount() int {
	fake.latestRuntimeConfigMutex.RLock()
	defer fake.latestRuntimeConfigMutex.RUnlock()
	return len(fake.latestRuntimeConfigArgsForCall)
}

func (fake *FakeDirector) LatestRuntimeConfigCalls(stub func(string) (director.RuntimeConfig, error)) {
	fake.latestRuntimeConfigMutex.Lock()
	defer fake.latestRuntimeConfigMutex.Unlock()
	fake.LatestRuntimeConfigStub = stub
}

func (fake *FakeDirector) LatestRuntimeConfigArgsForCall(i int) string {
	fake.latestRuntimeConfigMutex.RLock()
	defer fake.latestRuntimeConfigMutex.RUnlock()
	argsForCall := fake.latestRuntimeConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) LatestRuntimeConfigReturns(result1 director.RuntimeConfig, result2 error) {
	fake.latestRuntimeConfigMutex.Lock()
	defer fake.latestRuntimeConfigMutex.Unlock()
	fake.LatestRuntimeConfigStub = nil
	fake.latestRuntimeConfigReturns = struct {
		result1 director.RuntimeConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestRuntimeConfigReturnsOnCall(i int, result1 director.RuntimeConfig, result2 error) {
	fake.latestRuntimeConfigMutex.Lock()
	defer fake.latestRuntimeConfigMutex.Unlock()
	fake.LatestRuntimeConfigStub = nil
	if fake.latestRuntimeConfigReturnsOnCall == nil {
		fake.latestRuntimeConfigReturnsOnCall = make(map[int]struct {
			result1 director.RuntimeConfig
			result2 error
		})
	}
	fake.latestRuntimeConfigReturnsOnCall[i] = struct {
		result1 director.RuntimeConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) ListConfigs(arg1 int, arg2 director.ConfigsFilter) ([]director.Config, error) {
	fake.listConfigsMutex.Lock()
	ret, specificReturn := fake.listConfigsReturnsOnCall[len(fake.listConfigsArgsForCall)]
	fake.listConfigsArgsForCall = append(fake.listConfigsArgsForCall, struct {
		arg1 int
		arg2 director.ConfigsFilter
	}{arg1, arg2})
	stub := fake.ListConfigsStub
	fakeReturns := fake.listConfigsReturns
	fake.recordInvocation("ListConfigs", []interface{}{arg1, arg2})
	fake.listConfigsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) ListConfigsCallCount() int {
	fake.listConfigsMutex.RLock()
	defer fake.listConfigsMutex.RUnlock()
	return len(fake.listConfigsArgsForCall)
}

func (fake *FakeDirector) ListConfigsCalls(stub func(int, director.ConfigsFilter) ([]director.Config, error)) {
	fake.listConfigsMutex.Lock()
	defer fake.listConfigsMutex.Unlock()
	fake.ListConfigsStub = stub
}

func (fake *FakeDirector) ListConfigsArgsForCall(i int) (int, director.ConfigsFilter) {
	fake.listConfigsMutex.RLock()
	defer fake.listConfigsMutex.RUnlock()
	argsForCall := fake.listConfigsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) ListConfigsReturns(result1 []director.Config, result2 error) {
	fake.listConfigsMutex.Lock()
	defer fake.listConfigsMutex.Unlock()
	fake.ListConfigsStub = nil
	fake.listConfigsReturns = struct {
		result1 []director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) ListConfigsReturnsOnCall(i int, result1 []director.Config, result2 error) {
	fake.listConfigsMutex.Lock()
	defer fake.listConfigsMutex.Unlock()
	fake.ListConfigsStub = nil
	if fake.listConfigsReturnsOnCall == nil {
		fake.listConfigsReturnsOnCall = make(map[int]struct {
			result1 []director.Config
			result2 error
		})
	}
	fake.listConfigsReturnsOnCall[i] = struct {
		result1 []director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) ListDeploymentConfigs(arg1 string) (director.DeploymentConfigs, error) {
	fake.listDeploymentConfigsMutex.Lock()
	ret, specificReturn := fake.listDeploymentConfigsReturnsOnCall[len(fake.listDeploymentConfigsArgsForCall)]
	fake.listDeploymentConfigsArgsForCall = append(fake.listDeploymentConfigsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ListDeploymentConfigsStub
	fakeReturns := fake.listDeploymentConfigsReturns
	fake.recordInvocation("ListDeploymentConfigs", []interface{}{arg1})
	fake.listDeploymentConfigsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) ListDeploymentConfigsCallCount() int {
	fake.listDeploymentConfigsMutex.RLock()
	defer fake.listDeploymentConfigsMutex.RUnlock()
	return len(fake.listDeploymentConfigsArgsForCall)
}

func (fake *FakeDirector) ListDeploymentConfigsCalls(stub func(string) (director.DeploymentConfigs, error)) {
	fake.listDeploymentConfigsMutex.Lock()
	defer fake.listDeploymentConfigsMutex.Unlock()
	fake.ListDeploymentConfigsStub = stub
}

func (fake *FakeDirector) ListDeploymentConfigsArgsForCall(i int) string {
	fake.listDeploymentConfigsMutex.RLock()
	defer fake.listDeploymentConfigsMutex.RUnlock()
	argsForCall := fake.listDeploymentConfigsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) ListDeploymentConfigsReturns(result1 director.DeploymentConfigs, result2 error) {
	fake.listDeploymentConfigsMutex.Lock()
	defer fake.listDeploymentConfigsMutex.Unlock()
	fake.ListDeploymentConfigsStub = nil
	fake.listDeploymentConfigsReturns = struct {
		result1 director.DeploymentConfigs
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) ListDeploymentConfigsReturnsOnCall(i int, result1 director.DeploymentConfigs, result2 error) {
	fake.listDeploymentConfigsMutex.Lock()
	defer fake.listDeploymentConfigsMutex.Unlock()
	fake.ListDeploymentConfigsStub = nil
	if fake.listDeploymentConfigsReturnsOnCall == nil {
		fake.listDeploymentConfigsReturnsOnCall = make(map[int]struct {
			result1 director.DeploymentConfigs
			result2 error
		})
	}
	fake.listDeploymentConfigsReturnsOnCall[i] = struct {
		result1 director.DeploymentConfigs
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) ListDeployments() ([]director.DeploymentResp, error) {
	fake.listDeploymentsMutex.Lock()
	ret, specificReturn := fake.listDeploymentsReturnsOnCall[len(fake.listDeploymentsArgsForCall)]
	fake.listDeploymentsArgsForCall = append(fake.listDeploymentsArgsForCall, struct {
	}{})
	stub := fake.ListDeploymentsStub
	fakeReturns := fake.listDeploymentsReturns
	fake.recordInvocation("ListDeployments", []interface{}{})
	fake.listDeploymentsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) ListDeploymentsCallCount() int {
	fake.listDeploymentsMutex.RLock()
	defer fake.listDeploymentsMutex.RUnlock()
	return len(fake.listDeploymentsArgsForCall)
}

func (fake *FakeDirector) ListDeploymentsCalls(stub func() ([]director.DeploymentResp, error)) {
	fake.listDeploymentsMutex.Lock()
	defer fake.listDeploymentsMutex.Unlock()
	fake.ListDeploymentsStub = stub
}

func (fake *FakeDirector) ListDeploymentsReturns(result1 []director.DeploymentResp, result2 error) {
	fake.listDeploymentsMutex.Lock()
	defer fake.listDeploymentsMutex.Unlock()
	fake.ListDeploymentsStub = nil
	fake.listDeploymentsReturns = struct {
		result1 []director.DeploymentResp
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) ListDeploymentsReturnsOnCall(i int, result1 []director.DeploymentResp, result2 error) {
	fake.listDeploymentsMutex.Lock()
	defer fake.listDeploymentsMutex.Unlock()
	fake.ListDeploymentsStub = nil
	if fake.listDeploymentsReturnsOnCall == nil {
		fake.listDeploymentsReturnsOnCall = make(map[int]struct {
			result1 []director.DeploymentResp
			result2 error
		})
	}
	fake.listDeploymentsReturnsOnCall[i] = struct {
		result1 []director.DeploymentResp
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Locks() ([]director.Lock, error) {
	fake.locksMutex.Lock()
	ret, specificReturn := fake.locksReturnsOnCall[len(fake.locksArgsForCall)]
	fake.locksArgsForCall = append(fake.locksArgsForCall, struct {
	}{})
	stub := fake.LocksStub
	fakeReturns := fake.locksReturns
	fake.recordInvocation("Locks", []interface{}{})
	fake.locksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) LocksCallCount() int {
	fake.locksMutex.RLock()
	defer fake.locksMutex.RUnlock()
	return len(fake.locksArgsForCall)
}

func (fake *FakeDirector) LocksCalls(stub func() ([]director.Lock, error)) {
	fake.locksMutex.Lock()
	defer fake.locksMutex.Unlock()
	fake.LocksStub = stub
}

func (fake *FakeDirector) LocksReturns(result1 []director.Lock, result2 error) {
	fake.locksMutex.Lock()
	defer fake.locksMutex.Unlock()
	fake.LocksStub = nil
	fake.locksReturns = struct {
		result1 []director.Lock
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LocksReturnsOnCall(i int, result1 []director.Lock, result2 error) {
	fake.locksMutex.Lock()
	defer fake.locksMutex.Unlock()
	fake.LocksStub = nil
	if fake.locksReturnsOnCall == nil {
		fake.locksReturnsOnCall = make(map[int]struct {
			result1 []director.Lock
			result2 error
		})
	}
	fake.locksReturnsOnCall[i] = struct {
		result1 []director.Lock
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) MatchPackages(arg1 interface{}, arg2 bool) ([]string, error) {
	fake.matchPackagesMutex.Lock()
	ret, specificReturn := fake.matchPackagesReturnsOnCall[len(fake.matchPackagesArgsForCall)]
	fake.matchPackagesArgsForCall = append(fake.matchPackagesArgsForCall, struct {
		arg1 interface{}
		arg2 bool
	}{arg1, arg2})
	stub := fake.MatchPackagesStub
	fakeReturns := fake.matchPackagesReturns
	fake.recordInvocation("MatchPackages", []interface{}{arg1, arg2})
	fake.matchPackagesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) MatchPackagesCallCount() int {
	fake.matchPackagesMutex.RLock()
	defer fake.matchPackagesMutex.RUnlock()
	return len(fake.matchPackagesArgsForCall)
}

func (fake *FakeDirector) MatchPackagesCalls(stub func(interface{}, bool) ([]string, error)) {
	fake.matchPackagesMutex.Lock()
	defer fake.matchPackagesMutex.Unlock()
	fake.MatchPackagesStub = stub
}

func (fake *FakeDirector) MatchPackagesArgsForCall(i int) (interface{}, bool) {
	fake.matchPackagesMutex.RLock()
	defer fake.matchPackagesMutex.RUnlock()
	argsForCall := fake.matchPackagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) MatchPackagesReturns(result1 []string, result2 error) {
	fake.matchPackagesMutex.Lock()
	defer fake.matchPackagesMutex.Unlock()
	fake.MatchPackagesStub = nil
	fake.matchPackagesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) MatchPackagesReturnsOnCall(i int, result1 []string, result2 error) {
	fake.matchPackagesMutex.Lock()
	defer fake.matchPackagesMutex.Unlock()
	fake.MatchPackagesStub = nil
	if fake.matchPackagesReturnsOnCall == nil {
		fake.matchPackagesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.matchPackagesReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) OrphanDisk(arg1 string) error {
	fake.orphanDiskMutex.Lock()
	ret, specificReturn := fake.orphanDiskReturnsOnCall[len(fake.orphanDiskArgsForCall)]
	fake.orphanDiskArgsForCall = append(fake.orphanDiskArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.OrphanDiskStub
	fakeReturns := fake.orphanDiskReturns
	fake.recordInvocation("OrphanDisk", []interface{}{arg1})
	fake.orphanDiskMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDirector) OrphanDiskCallCount() int {
	fake.orphanDiskMutex.RLock()
	defer fake.orphanDiskMutex.RUnlock()
	return len(fake.orphanDiskArgsForCall)
}

func (fake *FakeDirector) OrphanDiskCalls(stub func(string) error) {
	fake.orphanDiskMutex.Lock()
	defer fake.orphanDiskMutex.Unlock()
	fake.OrphanDiskStub = stub
}

func (fake *FakeDirector) OrphanDiskArgsForCall(i int) string {
	fake.orphanDiskMutex.RLock()
	defer fake.orphanDiskMutex.RUnlock()
	argsForCall := fake.orphanDiskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) OrphanDiskReturns(result1 error) {
	fake.orphanDiskMutex.Lock()
	defer fake.orphanDiskMutex.Unlock()
	fake.OrphanDiskStub = nil
	fake.orphanDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) OrphanDiskReturnsOnCall(i int, result1 error) {
	fake.orphanDiskMutex.Lock()
	defer fake.orphanDiskMutex.Unlock()
	fake.OrphanDiskStub = nil
	if fake.orphanDiskReturnsOnCall == nil {
		fake.orphanDiskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.orphanDiskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) OrphanDisks() ([]director.OrphanDisk, error) {
	fake.orphanDisksMutex.Lock()
	ret, specificReturn := fake.orphanDisksReturnsOnCall[len(fake.orphanDisksArgsForCall)]
	fake.orphanDisksArgsForCall = append(fake.orphanDisksArgsForCall, struct {
	}{})
	stub := fake.OrphanDisksStub
	fakeReturns := fake.orphanDisksReturns
	fake.recordInvocation("OrphanDisks", []interface{}{})
	fake.orphanDisksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) OrphanDisksCallCount() int {
	fake.orphanDisksMutex.RLock()
	defer fake.orphanDisksMutex.RUnlock()
	return len(fake.orphanDisksArgsForCall)
}

func (fake *FakeDirector) OrphanDisksCalls(stub func() ([]director.OrphanDisk, error)) {
	fake.orphanDisksMutex.Lock()
	defer fake.orphanDisksMutex.Unlock()
	fake.OrphanDisksStub = stub
}

func (fake *FakeDirector) OrphanDisksReturns(result1 []director.OrphanDisk, result2 error) {
	fake.orphanDisksMutex.Lock()
	defer fake.orphanDisksMutex.Unlock()
	fake.OrphanDisksStub = nil
	fake.orphanDisksReturns = struct {
		result1 []director.OrphanDisk
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) OrphanDisksReturnsOnCall(i int, result1 []director.OrphanDisk, result2 error) {
	fake.orphanDisksMutex.Lock()
	defer fake.orphanDisksMutex.Unlock()
	fake.OrphanDisksStub = nil
	if fake.orphanDisksReturnsOnCall == nil {
		fake.orphanDisksReturnsOnCall = make(map[int]struct {
			result1 []director.OrphanDisk
			result2 error
		})
	}
	fake.orphanDisksReturnsOnCall[i] = struct {
		result1 []director.OrphanDisk
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) OrphanNetworks() ([]director.OrphanNetwork, error) {
	fake.orphanNetworksMutex.Lock()
	ret, specificReturn := fake.orphanNetworksReturnsOnCall[len(fake.orphanNetworksArgsForCall)]
	fake.orphanNetworksArgsForCall = append(fake.orphanNetworksArgsForCall, struct {
	}{})
	stub := fake.OrphanNetworksStub
	fakeReturns := fake.orphanNetworksReturns
	fake.recordInvocation("OrphanNetworks", []interface{}{})
	fake.orphanNetworksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) OrphanNetworksCallCount() int {
	fake.orphanNetworksMutex.RLock()
	defer fake.orphanNetworksMutex.RUnlock()
	return len(fake.orphanNetworksArgsForCall)
}

func (fake *FakeDirector) OrphanNetworksCalls(stub func() ([]director.OrphanNetwork, error)) {
	fake.orphanNetworksMutex.Lock()
	defer fake.orphanNetworksMutex.Unlock()
	fake.OrphanNetworksStub = stub
}

func (fake *FakeDirector) OrphanNetworksReturns(result1 []director.OrphanNetwork, result2 error) {
	fake.orphanNetworksMutex.Lock()
	defer fake.orphanNetworksMutex.Unlock()
	fake.OrphanNetworksStub = nil
	fake.orphanNetworksReturns = struct {
		result1 []director.OrphanNetwork
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) OrphanNetworksReturnsOnCall(i int, result1 []director.OrphanNetwork, result2 error) {
	fake.orphanNetworksMutex.Lock()
	defer fake.orphanNetworksMutex.Unlock()
	fake.OrphanNetworksStub = nil
	if fake.orphanNetworksReturnsOnCall == nil {
		fake.orphanNetworksReturnsOnCall = make(map[int]struct {
			result1 []director.OrphanNetwork
			result2 error
		})
	}
	fake.orphanNetworksReturnsOnCall[i] = struct {
		result1 []director.OrphanNetwork
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) OrphanedVMs() ([]director.OrphanedVM, error) {
	fake.orphanedVMsMutex.Lock()
	ret, specificReturn := fake.orphanedVMsReturnsOnCall[len(fake.orphanedVMsArgsForCall)]
	fake.orphanedVMsArgsForCall = append(fake.orphanedVMsArgsForCall, struct {
	}{})
	stub := fake.OrphanedVMsStub
	fakeReturns := fake.orphanedVMsReturns
	fake.recordInvocation("OrphanedVMs", []interface{}{})
	fake.orphanedVMsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) OrphanedVMsCallCount() int {
	fake.orphanedVMsMutex.RLock()
	defer fake.orphanedVMsMutex.RUnlock()
	return len(fake.orphanedVMsArgsForCall)
}

func (fake *FakeDirector) OrphanedVMsCalls(stub func() ([]director.OrphanedVM, error)) {
	fake.orphanedVMsMutex.Lock()
	defer fake.orphanedVMsMutex.Unlock()
	fake.OrphanedVMsStub = stub
}

func (fake *FakeDirector) OrphanedVMsReturns(result1 []director.OrphanedVM, result2 error) {
	fake.orphanedVMsMutex.Lock()
	defer fake.orphanedVMsMutex.Unlock()
	fake.OrphanedVMsStub = nil
	fake.orphanedVMsReturns = struct {
		result1 []director.OrphanedVM
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) OrphanedVMsReturnsOnCall(i int, result1 []director.OrphanedVM, result2 error) {
	fake.orphanedVMsMutex.Lock()
	defer fake.orphanedVMsMutex.Unlock()
	fake.OrphanedVMsStub = nil
	if fake.orphanedVMsReturnsOnCall == nil {
		fake.orphanedVMsReturnsOnCall = make(map[int]struct {
			result1 []director.OrphanedVM
			result2 error
		})
	}
	fake.orphanedVMsReturnsOnCall[i] = struct {
		result1 []director.OrphanedVM
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) RecentTasks(arg1 int, arg2 director.TasksFilter) ([]director.Task, error) {
	fake.recentTasksMutex.Lock()
	ret, specificReturn := fake.recentTasksReturnsOnCall[len(fake.recentTasksArgsForCall)]
	fake.recentTasksArgsForCall = append(fake.recentTasksArgsForCall, struct {
		arg1 int
		arg2 director.TasksFilter
	}{arg1, arg2})
	stub := fake.RecentTasksStub
	fakeReturns := fake.recentTasksReturns
	fake.recordInvocation("RecentTasks", []interface{}{arg1, arg2})
	fake.recentTasksMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) RecentTasksCallCount() int {
	fake.recentTasksMutex.RLock()
	defer fake.recentTasksMutex.RUnlock()
	return len(fake.recentTasksArgsForCall)
}

func (fake *FakeDirector) RecentTasksCalls(stub func(int, director.TasksFilter) ([]director.Task, error)) {
	fake.recentTasksMutex.Lock()
	defer fake.recentTasksMutex.Unlock()
	fake.RecentTasksStub = stub
}

func (fake *FakeDirector) RecentTasksArgsForCall(i int) (int, director.TasksFilter) {
	fake.recentTasksMutex.RLock()
	defer fake.recentTasksMutex.RUnlock()
	argsForCall := fake.recentTasksArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) RecentTasksReturns(result1 []director.Task, result2 error) {
	fake.recentTasksMutex.Lock()
	defer fake.recentTasksMutex.Unlock()
	fake.RecentTasksStub = nil
	fake.recentTasksReturns = struct {
		result1 []director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) RecentTasksReturnsOnCall(i int, result1 []director.Task, result2 error) {
	fake.recentTasksMutex.Lock()
	defer fake.recentTasksMutex.Unlock()
	fake.RecentTasksStub = nil
	if fake.recentTasksReturnsOnCall == nil {
		fake.recentTasksReturnsOnCall = make(map[int]struct {
			result1 []director.Task
			result2 error
		})
	}
	fake.recentTasksReturnsOnCall[i] = struct {
		result1 []director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) ReleaseHasCompiledPackage(arg1 director.ReleaseSlug, arg2 director.OSVersionSlug) (bool, error) {
	fake.releaseHasCompiledPackageMutex.Lock()
	ret, specificReturn := fake.releaseHasCompiledPackageReturnsOnCall[len(fake.releaseHasCompiledPackageArgsForCall)]
	fake.releaseHasCompiledPackageArgsForCall = append(fake.releaseHasCompiledPackageArgsForCall, struct {
		arg1 director.ReleaseSlug
		arg2 director.OSVersionSlug
	}{arg1, arg2})
	stub := fake.ReleaseHasCompiledPackageStub
	fakeReturns := fake.releaseHasCompiledPackageReturns
	fake.recordInvocation("ReleaseHasCompiledPackage", []interface{}{arg1, arg2})
	fake.releaseHasCompiledPackageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) ReleaseHasCompiledPackageCallCount() int {
	fake.releaseHasCompiledPackageMutex.RLock()
	defer fake.releaseHasCompiledPackageMutex.RUnlock()
	return len(fake.releaseHasCompiledPackageArgsForCall)
}

func (fake *FakeDirector) ReleaseHasCompiledPackageCalls(stub func(director.ReleaseSlug, director.OSVersionSlug) (bool, error)) {
	fake.releaseHasCompiledPackageMutex.Lock()
	defer fake.releaseHasCompiledPackageMutex.Unlock()
	fake.ReleaseHasCompiledPackageStub = stub
}

func (fake *FakeDirector) ReleaseHasCompiledPackageArgsForCall(i int) (director.ReleaseSlug, director.OSVersionSlug) {
	fake.releaseHasCompiledPackageMutex.RLock()
	defer fake.releaseHasCompiledPackageMutex.RUnlock()
	argsForCall := fake.releaseHasCompiledPackageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) ReleaseHasCompiledPackageReturns(result1 bool, result2 error) {
	fake.releaseHasCompiledPackageMutex.Lock()
	defer fake.releaseHasCompiledPackageMutex.Unlock()
	fake.ReleaseHasCompiledPackageStub = nil
	fake.releaseHasCompiledPackageReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) ReleaseHasCompiledPackageReturnsOnCall(i int, result1 bool, result2 error) {
	fake.releaseHasCompiledPackageMutex.Lock()
	defer fake.releaseHasCompiledPackageMutex.Unlock()
	fake.ReleaseHasCompiledPackageStub = nil
	if fake.releaseHasCompiledPackageReturnsOnCall == nil {
		fake.releaseHasCompiledPackageReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.releaseHasCompiledPackageReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Releases() ([]director.Release, error) {
	fake.releasesMutex.Lock()
	ret, specificReturn := fake.releasesReturnsOnCall[len(fake.releasesArgsForCall)]
	fake.releasesArgsForCall = append(fake.releasesArgsForCall, struct {
	}{})
	stub := fake.ReleasesStub
	fakeReturns := fake.releasesReturns
	fake.recordInvocation("Releases", []interface{}{})
	fake.releasesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) ReleasesCallCount() int {
	fake.releasesMutex.RLock()
	defer fake.releasesMutex.RUnlock()
	return len(fake.releasesArgsForCall)
}

func (fake *FakeDirector) ReleasesCalls(stub func() ([]director.Release, error)) {
	fake.releasesMutex.Lock()
	defer fake.releasesMutex.Unlock()
	fake.ReleasesStub = stub
}

func (fake *FakeDirector) ReleasesReturns(result1 []director.Release, result2 error) {
	fake.releasesMutex.Lock()
	defer fake.releasesMutex.Unlock()
	fake.ReleasesStub = nil
	fake.releasesReturns = struct {
		result1 []director.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) ReleasesReturnsOnCall(i int, result1 []director.Release, result2 error) {
	fake.releasesMutex.Lock()
	defer fake.releasesMutex.Unlock()
	fake.ReleasesStub = nil
	if fake.releasesReturnsOnCall == nil {
		fake.releasesReturnsOnCall = make(map[int]struct {
			result1 []director.Release
			result2 error
		})
	}
	fake.releasesReturnsOnCall[i] = struct {
		result1 []director.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) StemcellNeedsUpload(arg1 director.StemcellInfo) (bool, error) {
	fake.stemcellNeedsUploadMutex.Lock()
	ret, specificReturn := fake.stemcellNeedsUploadReturnsOnCall[len(fake.stemcellNeedsUploadArgsForCall)]
	fake.stemcellNeedsUploadArgsForCall = append(fake.stemcellNeedsUploadArgsForCall, struct {
		arg1 director.StemcellInfo
	}{arg1})
	stub := fake.StemcellNeedsUploadStub
	fakeReturns := fake.stemcellNeedsUploadReturns
	fake.recordInvocation("StemcellNeedsUpload", []interface{}{arg1})
	fake.stemcellNeedsUploadMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) StemcellNeedsUploadCallCount() int {
	fake.stemcellNeedsUploadMutex.RLock()
	defer fake.stemcellNeedsUploadMutex.RUnlock()
	return len(fake.stemcellNeedsUploadArgsForCall)
}

func (fake *FakeDirector) StemcellNeedsUploadCalls(stub func(director.StemcellInfo) (bool, error)) {
	fake.stemcellNeedsUploadMutex.Lock()
	defer fake.stemcellNeedsUploadMutex.Unlock()
	fake.StemcellNeedsUploadStub = stub
}

func (fake *FakeDirector) StemcellNeedsUploadArgsForCall(i int) director.StemcellInfo {
	fake.stemcellNeedsUploadMutex.RLock()
	defer fake.stemcellNeedsUploadMutex.RUnlock()
	argsForCall := fake.stemcellNeedsUploadArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) StemcellNeedsUploadReturns(result1 bool, result2 error) {
	fake.stemcellNeedsUploadMutex.Lock()
	defer fake.stemcellNeedsUploadMutex.Unlock()
	fake.StemcellNeedsUploadStub = nil
	fake.stemcellNeedsUploadReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) StemcellNeedsUploadReturnsOnCall(i int, result1 bool, result2 error) {
	fake.stemcellNeedsUploadMutex.Lock()
	defer fake.stemcellNeedsUploadMutex.Unlock()
	fake.StemcellNeedsUploadStub = nil
	if fake.stemcellNeedsUploadReturnsOnCall == nil {
		fake.stemcellNeedsUploadReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.stemcellNeedsUploadReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Stemcells() ([]director.Stemcell, error) {
	fake.stemcellsMutex.Lock()
	ret, specificReturn := fake.stemcellsReturnsOnCall[len(fake.stemcellsArgsForCall)]
	fake.stemcellsArgsForCall = append(fake.stemcellsArgsForCall, struct {
	}{})
	stub := fake.StemcellsStub
	fakeReturns := fake.stemcellsReturns
	fake.recordInvocation("Stemcells", []interface{}{})
	fake.stemcellsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) StemcellsCallCount() int {
	fake.stemcellsMutex.RLock()
	defer fake.stemcellsMutex.RUnlock()
	return len(fake.stemcellsArgsForCall)
}

func (fake *FakeDirector) StemcellsCalls(stub func() ([]director.Stemcell, error)) {
	fake.stemcellsMutex.Lock()
	defer fake.stemcellsMutex.Unlock()
	fake.StemcellsStub = stub
}

func (fake *FakeDirector) StemcellsReturns(result1 []director.Stemcell, result2 error) {
	fake.stemcellsMutex.Lock()
	defer fake.stemcellsMutex.Unlock()
	fake.StemcellsStub = nil
	fake.stemcellsReturns = struct {
		result1 []director.Stemcell
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) StemcellsReturnsOnCall(i int, result1 []director.Stemcell, result2 error) {
	fake.stemcellsMutex.Lock()
	defer fake.stemcellsMutex.Unlock()
	fake.StemcellsStub = nil
	if fake.stemcellsReturnsOnCall == nil {
		fake.stemcellsReturnsOnCall = make(map[int]struct {
			result1 []director.Stemcell
			result2 error
		})
	}
	fake.stemcellsReturnsOnCall[i] = struct {
		result1 []director.Stemcell
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) UpdateCPIConfig(arg1 []byte) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.updateCPIConfigMutex.Lock()
	ret, specificReturn := fake.updateCPIConfigReturnsOnCall[len(fake.updateCPIConfigArgsForCall)]
	fake.updateCPIConfigArgsForCall = append(fake.updateCPIConfigArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	stub := fake.UpdateCPIConfigStub
	fakeReturns := fake.updateCPIConfigReturns
	fake.recordInvocation("UpdateCPIConfig", []interface{}{arg1Copy})
	fake.updateCPIConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDirector) UpdateCPIConfigCallCount() int {
	fake.updateCPIConfigMutex.RLock()
	defer fake.updateCPIConfigMutex.RUnlock()
	return len(fake.updateCPIConfigArgsForCall)
}

func (fake *FakeDirector) UpdateCPIConfigCalls(stub func([]byte) error) {
	fake.updateCPIConfigMutex.Lock()
	defer fake.updateCPIConfigMutex.Unlock()
	fake.UpdateCPIConfigStub = stub
}

func (fake *FakeDirector) UpdateCPIConfigArgsForCall(i int) []byte {
	fake.updateCPIConfigMutex.RLock()
	defer fake.updateCPIConfigMutex.RUnlock()
	argsForCall := fake.updateCPIConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) UpdateCPIConfigReturns(result1 error) {
	fake.updateCPIConfigMutex.Lock()
	defer fake.updateCPIConfigMutex.Unlock()
	fake.UpdateCPIConfigStub = nil
	fake.updateCPIConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UpdateCPIConfigReturnsOnCall(i int, result1 error) {
	fake.updateCPIConfigMutex.Lock()
	defer fake.updateCPIConfigMutex.Unlock()
	fake.UpdateCPIConfigStub = nil
	if fake.updateCPIConfigReturnsOnCall == nil {
		fake.updateCPIConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateCPIConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UpdateCloudConfig(arg1 []byte) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.updateCloudConfigMutex.Lock()
	ret, specificReturn := fake.updateCloudConfigReturnsOnCall[len(fake.updateCloudConfigArgsForCall)]
	fake.updateCloudConfigArgsForCall = append(fake.updateCloudConfigArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	stub := fake.UpdateCloudConfigStub
	fakeReturns := fake.updateCloudConfigReturns
	fake.recordInvocation("UpdateCloudConfig", []interface{}{arg1Copy})
	fake.updateCloudConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDirector) UpdateCloudConfigCallCount() int {
	fake.updateCloudConfigMutex.RLock()
	defer fake.updateCloudConfigMutex.RUnlock()
	return len(fake.updateCloudConfigArgsForCall)
}

func (fake *FakeDirector) UpdateCloudConfigCalls(stub func([]byte) error) {
	fake.updateCloudConfigMutex.Lock()
	defer fake.updateCloudConfigMutex.Unlock()
	fake.UpdateCloudConfigStub = stub
}

func (fake *FakeDirector) UpdateCloudConfigArgsForCall(i int) []byte {
	fake.updateCloudConfigMutex.RLock()
	defer fake.updateCloudConfigMutex.RUnlock()
	argsForCall := fake.updateCloudConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) UpdateCloudConfigReturns(result1 error) {
	fake.updateCloudConfigMutex.Lock()
	defer fake.updateCloudConfigMutex.Unlock()
	fake.UpdateCloudConfigStub = nil
	fake.updateCloudConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UpdateCloudConfigReturnsOnCall(i int, result1 error) {
	fake.updateCloudConfigMutex.Lock()
	defer fake.updateCloudConfigMutex.Unlock()
	fake.UpdateCloudConfigStub = nil
	if fake.updateCloudConfigReturnsOnCall == nil {
		fake.updateCloudConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateCloudConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UpdateConfig(arg1 string, arg2 string, arg3 string, arg4 []byte) (director.Config, error) {
	var arg4Copy []byte
	if arg4 != nil {
		arg4Copy = make([]byte, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.updateConfigMutex.Lock()
	ret, specificReturn := fake.updateConfigReturnsOnCall[len(fake.updateConfigArgsForCall)]
	fake.updateConfigArgsForCall = append(fake.updateConfigArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []byte
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.UpdateConfigStub
	fakeReturns := fake.updateConfigReturns
	fake.recordInvocation("UpdateConfig", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.updateConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) UpdateConfigCallCount() int {
	fake.updateConfigMutex.RLock()
	defer fake.updateConfigMutex.RUnlock()
	return len(fake.updateConfigArgsForCall)
}

func (fake *FakeDirector) UpdateConfigCalls(stub func(string, string, string, []byte) (director.Config, error)) {
	fake.updateConfigMutex.Lock()
	defer fake.updateConfigMutex.Unlock()
	fake.UpdateConfigStub = stub
}

func (fake *FakeDirector) UpdateConfigArgsForCall(i int) (string, string, string, []byte) {
	fake.updateConfigMutex.RLock()
	defer fake.updateConfigMutex.RUnlock()
	argsForCall := fake.updateConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeDirector) UpdateConfigReturns(result1 director.Config, result2 error) {
	fake.updateConfigMutex.Lock()
	defer fake.updateConfigMutex.Unlock()
	fake.UpdateConfigStub = nil
	fake.updateConfigReturns = struct {
		result1 director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) UpdateConfigReturnsOnCall(i int, result1 director.Config, result2 error) {
	fake.updateConfigMutex.Lock()
	defer fake.updateConfigMutex.Unlock()
	fake.UpdateConfigStub = nil
	if fake.updateConfigReturnsOnCall == nil {
		fake.updateConfigReturnsOnCall = make(map[int]struct {
			result1 director.Config
			result2 error
		})
	}
	fake.updateConfigReturnsOnCall[i] = struct {
		result1 director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) UpdateRuntimeConfig(arg1 string, arg2 []byte) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.updateRuntimeConfigMutex.Lock()
	ret, specificReturn := fake.updateRuntimeConfigReturnsOnCall[len(fake.updateRuntimeConfigArgsForCall)]
	fake.updateRuntimeConfigArgsForCall = append(fake.updateRuntimeConfigArgsForCall, struct {
		arg1 string
		arg2 []byte
	}{arg1, arg2Copy})
	stub := fake.UpdateRuntimeConfigStub
	fakeReturns := fake.updateRuntimeConfigReturns
	fake.recordInvocation("UpdateRuntimeConfig", []interface{}{arg1, arg2Copy})
	fake.updateRuntimeConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDirector) UpdateRuntimeConfigCallCount() int {
	fake.updateRuntimeConfigMutex.RLock()
	defer fake.updateRuntimeConfigMutex.RUnlock()
	return len(fake.updateRuntimeConfigArgsForCall)
}

func (fake *FakeDirector) UpdateRuntimeConfigCalls(stub func(string, []byte) error) {
	fake.updateRuntimeConfigMutex.Lock()
	defer fake.updateRuntimeConfigMutex.Unlock()
	fake.UpdateRuntimeConfigStub = stub
}

func (fake *FakeDirector) UpdateRuntimeConfigArgsForCall(i int) (string, []byte) {
	fake.updateRuntimeConfigMutex.RLock()
	defer fake.updateRuntimeConfigMutex.RUnlock()
	argsForCall := fake.updateRuntimeConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) UpdateRuntimeConfigReturns(result1 error) {
	fake.updateRuntimeConfigMutex.Lock()
	defer fake.updateRuntimeConfigMutex.Unlock()
	fake.UpdateRuntimeConfigStub = nil
	fake.updateRuntimeConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UpdateRuntimeConfigReturnsOnCall(i int, result1 error) {
	fake.updateRuntimeConfigMutex.Lock()
	defer fake.updateRuntimeConfigMutex.Unlock()
	fake.UpdateRuntimeConfigStub = nil
	if fake.updateRuntimeConfigReturnsOnCall == nil {
		fake.updateRuntimeConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateRuntimeConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadReleaseFile(arg1 director.UploadFile, arg2 bool, arg3 bool) error {
	fake.uploadReleaseFileMutex.Lock()
	ret, specificReturn := fake.uploadReleaseFileReturnsOnCall[len(fake.uploadReleaseFileArgsForCall)]
	fake.uploadReleaseFileArgsForCall = append(fake.uploadReleaseFileArgsForCall, struct {
		arg1 director.UploadFile
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.UploadReleaseFileStub
	fakeReturns := fake.uploadReleaseFileReturns
	fake.recordInvocation("UploadReleaseFile", []interface{}{arg1, arg2, arg3})
	fake.uploadReleaseFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDirector) UploadReleaseFileCallCount() int {
	fake.uploadReleaseFileMutex.RLock()
	defer fake.uploadReleaseFileMutex.RUnlock()
	return len(fake.uploadReleaseFileArgsForCall)
}

func (fake *FakeDirector) UploadReleaseFileCalls(stub func(director.UploadFile, bool, bool) error) {
	fake.uploadReleaseFileMutex.Lock()
	defer fake.uploadReleaseFileMutex.Unlock()
	fake.UploadReleaseFileStub = stub
}

func (fake *FakeDirector) UploadReleaseFileArgsForCall(i int) (director.UploadFile, bool, bool) {
	fake.uploadReleaseFileMutex.RLock()
	defer fake.uploadReleaseFileMutex.RUnlock()
	argsForCall := fake.uploadReleaseFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDirector) UploadReleaseFileReturns(result1 error) {
	fake.uploadReleaseFileMutex.Lock()
	defer fake.uploadReleaseFileMutex.Unlock()
	fake.UploadReleaseFileStub = nil
	fake.uploadReleaseFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadReleaseFileReturnsOnCall(i int, result1 error) {
	fake.uploadReleaseFileMutex.Lock()
	defer fake.uploadReleaseFileMutex.Unlock()
	fake.UploadReleaseFileStub = nil
	if fake.uploadReleaseFileReturnsOnCall == nil {
		fake.uploadReleaseFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadReleaseFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadReleaseURL(arg1 string, arg2 string, arg3 bool, arg4 bool) error {
	fake.uploadReleaseURLMutex.Lock()
	ret, specificReturn := fake.uploadReleaseURLReturnsOnCall[len(fake.uploadReleaseURLArgsForCall)]
	fake.uploadReleaseURLArgsForCall = append(fake.uploadReleaseURLArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 bool
		arg4 bool
	}{arg1, arg2, arg3, arg4})
	stub := fake.UploadReleaseURLStub
	fakeReturns := fake.uploadReleaseURLReturns
	fake.recordInvocation("UploadReleaseURL", []interface{}{arg1, arg2, arg3, arg4})
	fake.uploadReleaseURLMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDirector) UploadReleaseURLCallCount() int {
	fake.uploadReleaseURLMutex.RLock()
	defer fake.uploadReleaseURLMutex.RUnlock()
	return len(fake.uploadReleaseURLArgsForCall)
}

func (fake *FakeDirector) UploadReleaseURLCalls(stub func(string, string, bool, bool) error) {
	fake.uploadReleaseURLMutex.Lock()
	defer fake.uploadReleaseURLMutex.Unlock()
	fake.UploadReleaseURLStub = stub
}

func (fake *FakeDirector) UploadReleaseURLArgsForCall(i int) (string, string, bool, bool) {
	fake.uploadReleaseURLMutex.RLock()
	defer fake.uploadReleaseURLMutex.RUnlock()
	argsForCall := fake.uploadReleaseURLArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeDirector) UploadReleaseURLReturns(result1 error) {
	fake.uploadReleaseURLMutex.Lock()
	defer fake.uploadReleaseURLMutex.Unlock()
	fake.UploadReleaseURLStub = nil
	fake.uploadReleaseURLReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadReleaseURLReturnsOnCall(i int, result1 error) {
	fake.uploadReleaseURLMutex.Lock()
	defer fake.uploadReleaseURLMutex.Unlock()
	fake.UploadReleaseURLStub = nil
	if fake.uploadReleaseURLReturnsOnCall == nil {
		fake.uploadReleaseURLReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadReleaseURLReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadStemcellFile(arg1 director.UploadFile, arg2 bool) error {
	fake.uploadStemcellFileMutex.Lock()
	ret, specificReturn := fake.uploadStemcellFileReturnsOnCall[len(fake.uploadStemcellFileArgsForCall)]
	fake.uploadStemcellFileArgsForCall = append(fake.uploadStemcellFileArgsForCall, struct {
		arg1 director.UploadFile
		arg2 bool
	}{arg1, arg2})
	stub := fake.UploadStemcellFileStub
	fakeReturns := fake.uploadStemcellFileReturns
	fake.recordInvocation("UploadStemcellFile", []interface{}{arg1, arg2})
	fake.uploadStemcellFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDirector) UploadStemcellFileCallCount() int {
	fake.uploadStemcellFileMutex.RLock()
	defer fake.uploadStemcellFileMutex.RUnlock()
	return len(fake.uploadStemcellFileArgsForCall)
}

func (fake *FakeDirector) UploadStemcellFileCalls(stub func(director.UploadFile, bool) error) {
	fake.uploadStemcellFileMutex.Lock()
	defer fake.uploadStemcellFileMutex.Unlock()
	fake.UploadStemcellFileStub = stub
}

func (fake *FakeDirector) UploadStemcellFileArgsForCall(i int) (director.UploadFile, bool) {
	fake.uploadStemcellFileMutex.RLock()
	defer fake.uploadStemcellFileMutex.RUnlock()
	argsForCall := fake.uploadStemcellFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) UploadStemcellFileReturns(result1 error) {
	fake.uploadStemcellFileMutex.Lock()
	defer fake.uploadStemcellFileMutex.Unlock()
	fake.UploadStemcellFileStub = nil
	fake.uploadStemcellFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadStemcellFileReturnsOnCall(i int, result1 error) {
	fake.uploadStemcellFileMutex.Lock()
	defer fake.uploadStemcellFileMutex.Unlock()
	fake.UploadStemcellFileStub = nil
	if fake.uploadStemcellFileReturnsOnCall == nil {
		fake.uploadStemcellFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadStemcellFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadStemcellURL(arg1 string, arg2 string, arg3 bool) error {
	fake.uploadStemcellURLMutex.Lock()
	ret, specificReturn := fake.uploadStemcellURLReturnsOnCall[len(fake.uploadStemcellURLArgsForCall)]
	fake.uploadStemcellURLArgsForCall = append(fake.uploadStemcellURLArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.UploadStemcellURLStub
	fakeReturns := fake.uploadStemcellURLReturns
	fake.recordInvocation("UploadStemcellURL", []interface{}{arg1, arg2, arg3})
	fake.uploadStemcellURLMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDirector) UploadStemcellURLCallCount() int {
	fake.uploadStemcellURLMutex.RLock()
	defer fake.uploadStemcellURLMutex.RUnlock()
	return len(fake.uploadStemcellURLArgsForCall)
}

func (fake *FakeDirector) UploadStemcellURLCalls(stub func(string, string, bool) error) {
	fake.uploadStemcellURLMutex.Lock()
	defer fake.uploadStemcellURLMutex.Unlock()
	fake.UploadStemcellURLStub = stub
}

func (fake *FakeDirector) UploadStemcellURLArgsForCall(i int) (string, string, bool) {
	fake.uploadStemcellURLMutex.RLock()
	defer fake.uploadStemcellURLMutex.RUnlock()
	argsForCall := fake.uploadStemcellURLArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDirector) UploadStemcellURLReturns(result1 error) {
	fake.uploadStemcellURLMutex.Lock()
	defer fake.uploadStemcellURLMutex.Unlock()
	fake.UploadStemcellURLStub = nil
	fake.uploadStemcellURLReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadStemcellURLReturnsOnCall(i int, result1 error) {
	fake.uploadStemcellURLMutex.Lock()
	defer fake.uploadStemcellURLMutex.Unlock()
	fake.UploadStemcellURLStub = nil
	if fake.uploadStemcellURLReturnsOnCall == nil {
		fake.uploadStemcellURLReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadStemcellURLReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) WithContext(arg1 string) director.Director {
	fake.withContextMutex.Lock()
	ret, specificReturn := fake.withContextReturnsOnCall[len(fake.withContextArgsForCall)]
	fake.withContextArgsForCall = append(fake.withContextArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.WithContextStub
	fakeReturns := fake.withContextReturns
	fake.recordInvocation("WithContext", []interface{}{arg1})
	fake.withContextMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDirector) WithContextCallCount() int {
	fake.withContextMutex.RLock()
	defer fake.withContextMutex.RUnlock()
	return len(fake.withContextArgsForCall)
}

func (fake *FakeDirector) WithContextCalls(stub func(string) director.Director) {
	fake.withContextMutex.Lock()
	defer fake.withContextMutex.Unlock()
	fake.WithContextStub = stub
}

func (fake *FakeDirector) WithContextArgsForCall(i int) string {
	fake.withContextMutex.RLock()
	defer fake.withContextMutex.RUnlock()
	argsForCall := fake.withContextArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) WithContextReturns(result1 director.Director) {
	fake.withContextMutex.Lock()
	defer fake.withContextMutex.Unlock()
	fake.WithContextStub = nil
	fake.withContextReturns = struct {
		result1 director.Director
	}{result1}
}

func (fake *FakeDirector) WithContextReturnsOnCall(i int, result1 director.Director) {
	fake.withContextMutex.Lock()
	defer fake.withContextMutex.Unlock()
	fake.WithContextStub = nil
	if fake.withContextReturnsOnCall == nil {
		fake.withContextReturnsOnCall = make(map[int]struct {
			result1 director.Director
		})
	}
	fake.withContextReturnsOnCall[i] = struct {
		result1 director.Director
	}{result1}
}

func (fake *FakeDirector) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cancelTasksMutex.RLock()
	defer fake.cancelTasksMutex.RUnlock()
	fake.certificateExpiryMutex.RLock()
	defer fake.certificateExpiryMutex.RUnlock()
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	fake.currentTasksMutex.RLock()
	defer fake.currentTasksMutex.RUnlock()
	fake.deleteConfigMutex.RLock()
	defer fake.deleteConfigMutex.RUnlock()
	fake.deleteConfigByIDMutex.RLock()
	defer fake.deleteConfigByIDMutex.RUnlock()
	fake.deploymentsMutex.RLock()
	defer fake.deploymentsMutex.RUnlock()
	fake.diffCPIConfigMutex.RLock()
	defer fake.diffCPIConfigMutex.RUnlock()
	fake.diffCloudConfigMutex.RLock()
	defer fake.diffCloudConfigMutex.RUnlock()
	fake.diffConfigMutex.RLock()
	defer fake.diffConfigMutex.RUnlock()
	fake.diffConfigByIDOrContentMutex.RLock()
	defer fake.diffConfigByIDOrContentMutex.RUnlock()
	fake.diffRuntimeConfigMutex.RLock()
	defer fake.diffRuntimeConfigMutex.RUnlock()
	fake.downloadResourceUncheckedMutex.RLock()
	defer fake.downloadResourceUncheckedMutex.RUnlock()
	fake.enableResurrectionMutex.RLock()
	defer fake.enableResurrectionMutex.RUnlock()
	fake.eventMutex.RLock()
	defer fake.eventMutex.RUnlock()
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	fake.findDeploymentMutex.RLock()
	defer fake.findDeploymentMutex.RUnlock()
	fake.findOrphanDiskMutex.RLock()
	defer fake.findOrphanDiskMutex.RUnlock()
	fake.findOrphanNetworkMutex.RLock()
	defer fake.findOrphanNetworkMutex.RUnlock()
	fake.findReleaseMutex.RLock()
	defer fake.findReleaseMutex.RUnlock()
	fake.findReleaseSeriesMutex.RLock()
	defer fake.findReleaseSeriesMutex.RUnlock()
	fake.findStemcellMutex.RLock()
	defer fake.findStemcellMutex.RUnlock()
	fake.findTaskMutex.RLock()
	defer fake.findTaskMutex.RUnlock()
	fake.findTasksByContextIdMutex.RLock()
	defer fake.findTasksByContextIdMutex.RUnlock()
	fake.hasReleaseMutex.RLock()
	defer fake.hasReleaseMutex.RUnlock()
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	fake.isAuthenticatedMutex.RLock()
	defer fake.isAuthenticatedMutex.RUnlock()
	fake.latestCPIConfigMutex.RLock()
	defer fake.latestCPIConfigMutex.RUnlock()
	fake.latestCloudConfigMutex.RLock()
	defer fake.latestCloudConfigMutex.RUnlock()
	fake.latestConfigMutex.RLock()
	defer fake.latestConfigMutex.RUnlock()
	fake.latestConfigByIDMutex.RLock()
	defer fake.latestConfigByIDMutex.RUnlock()
	fake.latestRuntimeConfigMutex.RLock()
	defer fake.latestRuntimeConfigMutex.RUnlock()
	fake.listConfigsMutex.RLock()
	defer fake.listConfigsMutex.RUnlock()
	fake.listDeploymentConfigsMutex.RLock()
	defer fake.listDeploymentConfigsMutex.RUnlock()
	fake.listDeploymentsMutex.RLock()
	defer fake.listDeploymentsMutex.RUnlock()
	fake.locksMutex.RLock()
	defer fake.locksMutex.RUnlock()
	fake.matchPackagesMutex.RLock()
	defer fake.matchPackagesMutex.RUnlock()
	fake.orphanDiskMutex.RLock()
	defer fake.orphanDiskMutex.RUnlock()
	fake.orphanDisksMutex.RLock()
	defer fake.orphanDisksMutex.RUnlock()
	fake.orphanNetworksMutex.RLock()
	defer fake.orphanNetworksMutex.RUnlock()
	fake.orphanedVMsMutex.RLock()
	defer fake.orphanedVMsMutex.RUnlock()
	fake.recentTasksMutex.RLock()
	defer fake.recentTasksMutex.RUnlock()
	fake.releaseHasCompiledPackageMutex.RLock()
	defer fake.releaseHasCompiledPackageMutex.RUnlock()
	fake.releasesMutex.RLock()
	defer fake.releasesMutex.RUnlock()
	fake.stemcellNeedsUploadMutex.RLock()
	defer fake.stemcellNeedsUploadMutex.RUnlock()
	fake.stemcellsMutex.RLock()
	defer fake.stemcellsMutex.RUnlock()
	fake.updateCPIConfigMutex.RLock()
	defer fake.updateCPIConfigMutex.RUnlock()
	fake.updateCloudConfigMutex.RLock()
	defer fake.updateCloudConfigMutex.RUnlock()
	fake.updateConfigMutex.RLock()
	defer fake.updateConfigMutex.RUnlock()
	fake.updateRuntimeConfigMutex.RLock()
	defer fake.updateRuntimeConfigMutex.RUnlock()
	fake.uploadReleaseFileMutex.RLock()
	defer fake.uploadReleaseFileMutex.RUnlock()
	fake.uploadReleaseURLMutex.RLock()
	defer fake.uploadReleaseURLMutex.RUnlock()
	fake.uploadStemcellFileMutex.RLock()
	defer fake.uploadStemcellFileMutex.RUnlock()
	fake.uploadStemcellURLMutex.RLock()
	defer fake.uploadStemcellURLMutex.RUnlock()
	fake.withContextMutex.RLock()
	defer fake.withContextMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDirector) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ director.Director = new(FakeDirector)
