// Code generated by counterfeiter. DO NOT EDIT.
package directorfakes

import (
	"io"
	"sync"

	"github.com/cloudfoundry/bosh-cli/director"
)

type FakeDirector struct {
	CancelTasksStub        func(director.TasksFilter) error
	cancelTasksMutex       sync.RWMutex
	cancelTasksArgsForCall []struct {
		arg1 director.TasksFilter
	}
	cancelTasksReturns struct {
		result1 error
	}
	cancelTasksReturnsOnCall map[int]struct {
		result1 error
	}
	CertificateExpiryStub        func() ([]director.CertificateExpiryInfo, error)
	certificateExpiryMutex       sync.RWMutex
	certificateExpiryArgsForCall []struct {
	}
	certificateExpiryReturns struct {
		result1 []director.CertificateExpiryInfo
		result2 error
	}
	certificateExpiryReturnsOnCall map[int]struct {
		result1 []director.CertificateExpiryInfo
		result2 error
	}
	CleanUpStub        func(bool) error
	cleanUpMutex       sync.RWMutex
	cleanUpArgsForCall []struct {
		arg1 bool
	}
	cleanUpReturns struct {
		result1 error
	}
	cleanUpReturnsOnCall map[int]struct {
		result1 error
	}
	CurrentTasksStub        func(director.TasksFilter) ([]director.Task, error)
	currentTasksMutex       sync.RWMutex
	currentTasksArgsForCall []struct {
		arg1 director.TasksFilter
	}
	currentTasksReturns struct {
		result1 []director.Task
		result2 error
	}
	currentTasksReturnsOnCall map[int]struct {
		result1 []director.Task
		result2 error
	}
	DeleteConfigStub        func(string, string) (bool, error)
	deleteConfigMutex       sync.RWMutex
	deleteConfigArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deleteConfigReturns struct {
		result1 bool
		result2 error
	}
	deleteConfigReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	DeleteConfigByIDStub        func(string) (bool, error)
	deleteConfigByIDMutex       sync.RWMutex
	deleteConfigByIDArgsForCall []struct {
		arg1 string
	}
	deleteConfigByIDReturns struct {
		result1 bool
		result2 error
	}
	deleteConfigByIDReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	DeploymentsStub        func() ([]director.Deployment, error)
	deploymentsMutex       sync.RWMutex
	deploymentsArgsForCall []struct {
	}
	deploymentsReturns struct {
		result1 []director.Deployment
		result2 error
	}
	deploymentsReturnsOnCall map[int]struct {
		result1 []director.Deployment
		result2 error
	}
	DiffCPIConfigStub        func([]byte, bool) (director.ConfigDiff, error)
	diffCPIConfigMutex       sync.RWMutex
	diffCPIConfigArgsForCall []struct {
		arg1 []byte
		arg2 bool
	}
	diffCPIConfigReturns struct {
		result1 director.ConfigDiff
		result2 error
	}
	diffCPIConfigReturnsOnCall map[int]struct {
		result1 director.ConfigDiff
		result2 error
	}
	DiffCloudConfigStub        func([]byte) (director.ConfigDiff, error)
	diffCloudConfigMutex       sync.RWMutex
	diffCloudConfigArgsForCall []struct {
		arg1 []byte
	}
	diffCloudConfigReturns struct {
		result1 director.ConfigDiff
		result2 error
	}
	diffCloudConfigReturnsOnCall map[int]struct {
		result1 director.ConfigDiff
		result2 error
	}
	DiffConfigStub        func(string, string, []byte) (director.ConfigDiff, error)
	diffConfigMutex       sync.RWMutex
	diffConfigArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []byte
	}
	diffConfigReturns struct {
		result1 director.ConfigDiff
		result2 error
	}
	diffConfigReturnsOnCall map[int]struct {
		result1 director.ConfigDiff
		result2 error
	}
	DiffConfigByIDOrContentStub        func(string, []byte, string, []byte) (director.ConfigDiff, error)
	diffConfigByIDOrContentMutex       sync.RWMutex
	diffConfigByIDOrContentArgsForCall []struct {
		arg1 string
		arg2 []byte
		arg3 string
		arg4 []byte
	}
	diffConfigByIDOrContentReturns struct {
		result1 director.ConfigDiff
		result2 error
	}
	diffConfigByIDOrContentReturnsOnCall map[int]struct {
		result1 director.ConfigDiff
		result2 error
	}
	DiffRuntimeConfigStub        func(string, []byte, bool) (director.ConfigDiff, error)
	diffRuntimeConfigMutex       sync.RWMutex
	diffRuntimeConfigArgsForCall []struct {
		arg1 string
		arg2 []byte
		arg3 bool
	}
	diffRuntimeConfigReturns struct {
		result1 director.ConfigDiff
		result2 error
	}
	diffRuntimeConfigReturnsOnCall map[int]struct {
		result1 director.ConfigDiff
		result2 error
	}
	DownloadResourceUncheckedStub        func(string, io.Writer) error
	downloadResourceUncheckedMutex       sync.RWMutex
	downloadResourceUncheckedArgsForCall []struct {
		arg1 string
		arg2 io.Writer
	}
	downloadResourceUncheckedReturns struct {
		result1 error
	}
	downloadResourceUncheckedReturnsOnCall map[int]struct {
		result1 error
	}
	EnableResurrectionStub        func(bool) error
	enableResurrectionMutex       sync.RWMutex
	enableResurrectionArgsForCall []struct {
		arg1 bool
	}
	enableResurrectionReturns struct {
		result1 error
	}
	enableResurrectionReturnsOnCall map[int]struct {
		result1 error
	}
	EventStub        func(string) (director.Event, error)
	eventMutex       sync.RWMutex
	eventArgsForCall []struct {
		arg1 string
	}
	eventReturns struct {
		result1 director.Event
		result2 error
	}
	eventReturnsOnCall map[int]struct {
		result1 director.Event
		result2 error
	}
	EventsStub        func(director.EventsFilter) ([]director.Event, error)
	eventsMutex       sync.RWMutex
	eventsArgsForCall []struct {
		arg1 director.EventsFilter
	}
	eventsReturns struct {
		result1 []director.Event
		result2 error
	}
	eventsReturnsOnCall map[int]struct {
		result1 []director.Event
		result2 error
	}
	FindDeploymentStub        func(string) (director.Deployment, error)
	findDeploymentMutex       sync.RWMutex
	findDeploymentArgsForCall []struct {
		arg1 string
	}
	findDeploymentReturns struct {
		result1 director.Deployment
		result2 error
	}
	findDeploymentReturnsOnCall map[int]struct {
		result1 director.Deployment
		result2 error
	}
	FindOrphanDiskStub        func(string) (director.OrphanDisk, error)
	findOrphanDiskMutex       sync.RWMutex
	findOrphanDiskArgsForCall []struct {
		arg1 string
	}
	findOrphanDiskReturns struct {
		result1 director.OrphanDisk
		result2 error
	}
	findOrphanDiskReturnsOnCall map[int]struct {
		result1 director.OrphanDisk
		result2 error
	}
	FindOrphanNetworkStub        func(string) (director.OrphanNetwork, error)
	findOrphanNetworkMutex       sync.RWMutex
	findOrphanNetworkArgsForCall []struct {
		arg1 string
	}
	findOrphanNetworkReturns struct {
		result1 director.OrphanNetwork
		result2 error
	}
	findOrphanNetworkReturnsOnCall map[int]struct {
		result1 director.OrphanNetwork
		result2 error
	}
	FindReleaseStub        func(director.ReleaseSlug) (director.Release, error)
	findReleaseMutex       sync.RWMutex
	findReleaseArgsForCall []struct {
		arg1 director.ReleaseSlug
	}
	findReleaseReturns struct {
		result1 director.Release
		result2 error
	}
	findReleaseReturnsOnCall map[int]struct {
		result1 director.Release
		result2 error
	}
	FindReleaseSeriesStub        func(director.ReleaseSeriesSlug) (director.ReleaseSeries, error)
	findReleaseSeriesMutex       sync.RWMutex
	findReleaseSeriesArgsForCall []struct {
		arg1 director.ReleaseSeriesSlug
	}
	findReleaseSeriesReturns struct {
		result1 director.ReleaseSeries
		result2 error
	}
	findReleaseSeriesReturnsOnCall map[int]struct {
		result1 director.ReleaseSeries
		result2 error
	}
	FindStemcellStub        func(director.StemcellSlug) (director.Stemcell, error)
	findStemcellMutex       sync.RWMutex
	findStemcellArgsForCall []struct {
		arg1 director.StemcellSlug
	}
	findStemcellReturns struct {
		result1 director.Stemcell
		result2 error
	}
	findStemcellReturnsOnCall map[int]struct {
		result1 director.Stemcell
		result2 error
	}
	FindTaskStub        func(int) (director.Task, error)
	findTaskMutex       sync.RWMutex
	findTaskArgsForCall []struct {
		arg1 int
	}
	findTaskReturns struct {
		result1 director.Task
		result2 error
	}
	findTaskReturnsOnCall map[int]struct {
		result1 director.Task
		result2 error
	}
	FindTasksByContextIdStub        func(string) ([]director.Task, error)
	findTasksByContextIdMutex       sync.RWMutex
	findTasksByContextIdArgsForCall []struct {
		arg1 string
	}
	findTasksByContextIdReturns struct {
		result1 []director.Task
		result2 error
	}
	findTasksByContextIdReturnsOnCall map[int]struct {
		result1 []director.Task
		result2 error
	}
	HasReleaseStub        func(string, string, director.OSVersionSlug) (bool, error)
	hasReleaseMutex       sync.RWMutex
	hasReleaseArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 director.OSVersionSlug
	}
	hasReleaseReturns struct {
		result1 bool
		result2 error
	}
	hasReleaseReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	HasStemcellStub        func(string, string) (bool, error)
	hasStemcellMutex       sync.RWMutex
	hasStemcellArgsForCall []struct {
		arg1 string
		arg2 string
	}
	hasStemcellReturns struct {
		result1 bool
		result2 error
	}
	hasStemcellReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	InfoStub        func() (director.Info, error)
	infoMutex       sync.RWMutex
	infoArgsForCall []struct {
	}
	infoReturns struct {
		result1 director.Info
		result2 error
	}
	infoReturnsOnCall map[int]struct {
		result1 director.Info
		result2 error
	}
	IsAuthenticatedStub        func() (bool, error)
	isAuthenticatedMutex       sync.RWMutex
	isAuthenticatedArgsForCall []struct {
	}
	isAuthenticatedReturns struct {
		result1 bool
		result2 error
	}
	isAuthenticatedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	LatestCPIConfigStub        func() (director.CPIConfig, error)
	latestCPIConfigMutex       sync.RWMutex
	latestCPIConfigArgsForCall []struct {
	}
	latestCPIConfigReturns struct {
		result1 director.CPIConfig
		result2 error
	}
	latestCPIConfigReturnsOnCall map[int]struct {
		result1 director.CPIConfig
		result2 error
	}
	LatestCloudConfigStub        func() (director.CloudConfig, error)
	latestCloudConfigMutex       sync.RWMutex
	latestCloudConfigArgsForCall []struct {
	}
	latestCloudConfigReturns struct {
		result1 director.CloudConfig
		result2 error
	}
	latestCloudConfigReturnsOnCall map[int]struct {
		result1 director.CloudConfig
		result2 error
	}
	LatestConfigStub        func(string, string) (director.Config, error)
	latestConfigMutex       sync.RWMutex
	latestConfigArgsForCall []struct {
		arg1 string
		arg2 string
	}
	latestConfigReturns struct {
		result1 director.Config
		result2 error
	}
	latestConfigReturnsOnCall map[int]struct {
		result1 director.Config
		result2 error
	}
	LatestConfigByIDStub        func(string) (director.Config, error)
	latestConfigByIDMutex       sync.RWMutex
	latestConfigByIDArgsForCall []struct {
		arg1 string
	}
	latestConfigByIDReturns struct {
		result1 director.Config
		result2 error
	}
	latestConfigByIDReturnsOnCall map[int]struct {
		result1 director.Config
		result2 error
	}
	LatestRuntimeConfigStub        func(string) (director.RuntimeConfig, error)
	latestRuntimeConfigMutex       sync.RWMutex
	latestRuntimeConfigArgsForCall []struct {
		arg1 string
	}
	latestRuntimeConfigReturns struct {
		result1 director.RuntimeConfig
		result2 error
	}
	latestRuntimeConfigReturnsOnCall map[int]struct {
		result1 director.RuntimeConfig
		result2 error
	}
	ListConfigsStub        func(int, director.ConfigsFilter) ([]director.Config, error)
	listConfigsMutex       sync.RWMutex
	listConfigsArgsForCall []struct {
		arg1 int
		arg2 director.ConfigsFilter
	}
	listConfigsReturns struct {
		result1 []director.Config
		result2 error
	}
	listConfigsReturnsOnCall map[int]struct {
		result1 []director.Config
		result2 error
	}
	ListDeploymentConfigsStub        func(string) (director.DeploymentConfigs, error)
	listDeploymentConfigsMutex       sync.RWMutex
	listDeploymentConfigsArgsForCall []struct {
		arg1 string
	}
	listDeploymentConfigsReturns struct {
		result1 director.DeploymentConfigs
		result2 error
	}
	listDeploymentConfigsReturnsOnCall map[int]struct {
		result1 director.DeploymentConfigs
		result2 error
	}
	ListDeploymentsStub        func() ([]director.DeploymentResp, error)
	listDeploymentsMutex       sync.RWMutex
	listDeploymentsArgsForCall []struct {
	}
	listDeploymentsReturns struct {
		result1 []director.DeploymentResp
		result2 error
	}
	listDeploymentsReturnsOnCall map[int]struct {
		result1 []director.DeploymentResp
		result2 error
	}
	LocksStub        func() ([]director.Lock, error)
	locksMutex       sync.RWMutex
	locksArgsForCall []struct {
	}
	locksReturns struct {
		result1 []director.Lock
		result2 error
	}
	locksReturnsOnCall map[int]struct {
		result1 []director.Lock
		result2 error
	}
	MatchPackagesStub        func(interface{}, bool) ([]string, error)
	matchPackagesMutex       sync.RWMutex
	matchPackagesArgsForCall []struct {
		arg1 interface{}
		arg2 bool
	}
	matchPackagesReturns struct {
		result1 []string
		result2 error
	}
	matchPackagesReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	OrphanDiskStub        func(string) error
	orphanDiskMutex       sync.RWMutex
	orphanDiskArgsForCall []struct {
		arg1 string
	}
	orphanDiskReturns struct {
		result1 error
	}
	orphanDiskReturnsOnCall map[int]struct {
		result1 error
	}
	OrphanDisksStub        func() ([]director.OrphanDisk, error)
	orphanDisksMutex       sync.RWMutex
	orphanDisksArgsForCall []struct {
	}
	orphanDisksReturns struct {
		result1 []director.OrphanDisk
		result2 error
	}
	orphanDisksReturnsOnCall map[int]struct {
		result1 []director.OrphanDisk
		result2 error
	}
	OrphanNetworksStub        func() ([]director.OrphanNetwork, error)
	orphanNetworksMutex       sync.RWMutex
	orphanNetworksArgsForCall []struct {
	}
	orphanNetworksReturns struct {
		result1 []director.OrphanNetwork
		result2 error
	}
	orphanNetworksReturnsOnCall map[int]struct {
		result1 []director.OrphanNetwork
		result2 error
	}
	OrphanedVMsStub        func() ([]director.OrphanedVM, error)
	orphanedVMsMutex       sync.RWMutex
	orphanedVMsArgsForCall []struct {
	}
	orphanedVMsReturns struct {
		result1 []director.OrphanedVM
		result2 error
	}
	orphanedVMsReturnsOnCall map[int]struct {
		result1 []director.OrphanedVM
		result2 error
	}
	RecentTasksStub        func(int, director.TasksFilter) ([]director.Task, error)
	recentTasksMutex       sync.RWMutex
	recentTasksArgsForCall []struct {
		arg1 int
		arg2 director.TasksFilter
	}
	recentTasksReturns struct {
		result1 []director.Task
		result2 error
	}
	recentTasksReturnsOnCall map[int]struct {
		result1 []director.Task
		result2 error
	}
	ReleasesStub        func() ([]director.Release, error)
	releasesMutex       sync.RWMutex
	releasesArgsForCall []struct {
	}
	releasesReturns struct {
		result1 []director.Release
		result2 error
	}
	releasesReturnsOnCall map[int]struct {
		result1 []director.Release
		result2 error
	}
	StemcellNeedsUploadStub        func(director.StemcellInfo) (bool, bool, error)
	stemcellNeedsUploadMutex       sync.RWMutex
	stemcellNeedsUploadArgsForCall []struct {
		arg1 director.StemcellInfo
	}
	stemcellNeedsUploadReturns struct {
		result1 bool
		result2 bool
		result3 error
	}
	stemcellNeedsUploadReturnsOnCall map[int]struct {
		result1 bool
		result2 bool
		result3 error
	}
	StemcellsStub        func() ([]director.Stemcell, error)
	stemcellsMutex       sync.RWMutex
	stemcellsArgsForCall []struct {
	}
	stemcellsReturns struct {
		result1 []director.Stemcell
		result2 error
	}
	stemcellsReturnsOnCall map[int]struct {
		result1 []director.Stemcell
		result2 error
	}
	UpdateCPIConfigStub        func([]byte) error
	updateCPIConfigMutex       sync.RWMutex
	updateCPIConfigArgsForCall []struct {
		arg1 []byte
	}
	updateCPIConfigReturns struct {
		result1 error
	}
	updateCPIConfigReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateCloudConfigStub        func([]byte) error
	updateCloudConfigMutex       sync.RWMutex
	updateCloudConfigArgsForCall []struct {
		arg1 []byte
	}
	updateCloudConfigReturns struct {
		result1 error
	}
	updateCloudConfigReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateConfigStub        func(string, string, string, []byte) (director.Config, error)
	updateConfigMutex       sync.RWMutex
	updateConfigArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []byte
	}
	updateConfigReturns struct {
		result1 director.Config
		result2 error
	}
	updateConfigReturnsOnCall map[int]struct {
		result1 director.Config
		result2 error
	}
	UpdateRuntimeConfigStub        func(string, []byte) error
	updateRuntimeConfigMutex       sync.RWMutex
	updateRuntimeConfigArgsForCall []struct {
		arg1 string
		arg2 []byte
	}
	updateRuntimeConfigReturns struct {
		result1 error
	}
	updateRuntimeConfigReturnsOnCall map[int]struct {
		result1 error
	}
	UploadReleaseFileStub        func(director.UploadFile, bool, bool) error
	uploadReleaseFileMutex       sync.RWMutex
	uploadReleaseFileArgsForCall []struct {
		arg1 director.UploadFile
		arg2 bool
		arg3 bool
	}
	uploadReleaseFileReturns struct {
		result1 error
	}
	uploadReleaseFileReturnsOnCall map[int]struct {
		result1 error
	}
	UploadReleaseURLStub        func(string, string, bool, bool) error
	uploadReleaseURLMutex       sync.RWMutex
	uploadReleaseURLArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 bool
		arg4 bool
	}
	uploadReleaseURLReturns struct {
		result1 error
	}
	uploadReleaseURLReturnsOnCall map[int]struct {
		result1 error
	}
	UploadStemcellFileStub        func(director.UploadFile, bool) error
	uploadStemcellFileMutex       sync.RWMutex
	uploadStemcellFileArgsForCall []struct {
		arg1 director.UploadFile
		arg2 bool
	}
	uploadStemcellFileReturns struct {
		result1 error
	}
	uploadStemcellFileReturnsOnCall map[int]struct {
		result1 error
	}
	UploadStemcellURLStub        func(string, string, bool) error
	uploadStemcellURLMutex       sync.RWMutex
	uploadStemcellURLArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 bool
	}
	uploadStemcellURLReturns struct {
		result1 error
	}
	uploadStemcellURLReturnsOnCall map[int]struct {
		result1 error
	}
	WithContextStub        func(string) director.Director
	withContextMutex       sync.RWMutex
	withContextArgsForCall []struct {
		arg1 string
	}
	withContextReturns struct {
		result1 director.Director
	}
	withContextReturnsOnCall map[int]struct {
		result1 director.Director
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDirector) CancelTasks(arg1 director.TasksFilter) error {
	fake.cancelTasksMutex.Lock()
	ret, specificReturn := fake.cancelTasksReturnsOnCall[len(fake.cancelTasksArgsForCall)]
	fake.cancelTasksArgsForCall = append(fake.cancelTasksArgsForCall, struct {
		arg1 director.TasksFilter
	}{arg1})
	fake.recordInvocation("CancelTasks", []interface{}{arg1})
	fake.cancelTasksMutex.Unlock()
	if fake.CancelTasksStub != nil {
		return fake.CancelTasksStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cancelTasksReturns
	return fakeReturns.result1
}

func (fake *FakeDirector) CancelTasksCallCount() int {
	fake.cancelTasksMutex.RLock()
	defer fake.cancelTasksMutex.RUnlock()
	return len(fake.cancelTasksArgsForCall)
}

func (fake *FakeDirector) CancelTasksCalls(stub func(director.TasksFilter) error) {
	fake.cancelTasksMutex.Lock()
	defer fake.cancelTasksMutex.Unlock()
	fake.CancelTasksStub = stub
}

func (fake *FakeDirector) CancelTasksArgsForCall(i int) director.TasksFilter {
	fake.cancelTasksMutex.RLock()
	defer fake.cancelTasksMutex.RUnlock()
	argsForCall := fake.cancelTasksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) CancelTasksReturns(result1 error) {
	fake.cancelTasksMutex.Lock()
	defer fake.cancelTasksMutex.Unlock()
	fake.CancelTasksStub = nil
	fake.cancelTasksReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) CancelTasksReturnsOnCall(i int, result1 error) {
	fake.cancelTasksMutex.Lock()
	defer fake.cancelTasksMutex.Unlock()
	fake.CancelTasksStub = nil
	if fake.cancelTasksReturnsOnCall == nil {
		fake.cancelTasksReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelTasksReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) CertificateExpiry() ([]director.CertificateExpiryInfo, error) {
	fake.certificateExpiryMutex.Lock()
	ret, specificReturn := fake.certificateExpiryReturnsOnCall[len(fake.certificateExpiryArgsForCall)]
	fake.certificateExpiryArgsForCall = append(fake.certificateExpiryArgsForCall, struct {
	}{})
	fake.recordInvocation("CertificateExpiry", []interface{}{})
	fake.certificateExpiryMutex.Unlock()
	if fake.CertificateExpiryStub != nil {
		return fake.CertificateExpiryStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.certificateExpiryReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) CertificateExpiryCallCount() int {
	fake.certificateExpiryMutex.RLock()
	defer fake.certificateExpiryMutex.RUnlock()
	return len(fake.certificateExpiryArgsForCall)
}

func (fake *FakeDirector) CertificateExpiryCalls(stub func() ([]director.CertificateExpiryInfo, error)) {
	fake.certificateExpiryMutex.Lock()
	defer fake.certificateExpiryMutex.Unlock()
	fake.CertificateExpiryStub = stub
}

func (fake *FakeDirector) CertificateExpiryReturns(result1 []director.CertificateExpiryInfo, result2 error) {
	fake.certificateExpiryMutex.Lock()
	defer fake.certificateExpiryMutex.Unlock()
	fake.CertificateExpiryStub = nil
	fake.certificateExpiryReturns = struct {
		result1 []director.CertificateExpiryInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) CertificateExpiryReturnsOnCall(i int, result1 []director.CertificateExpiryInfo, result2 error) {
	fake.certificateExpiryMutex.Lock()
	defer fake.certificateExpiryMutex.Unlock()
	fake.CertificateExpiryStub = nil
	if fake.certificateExpiryReturnsOnCall == nil {
		fake.certificateExpiryReturnsOnCall = make(map[int]struct {
			result1 []director.CertificateExpiryInfo
			result2 error
		})
	}
	fake.certificateExpiryReturnsOnCall[i] = struct {
		result1 []director.CertificateExpiryInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) CleanUp(arg1 bool) error {
	fake.cleanUpMutex.Lock()
	ret, specificReturn := fake.cleanUpReturnsOnCall[len(fake.cleanUpArgsForCall)]
	fake.cleanUpArgsForCall = append(fake.cleanUpArgsForCall, struct {
		arg1 bool
	}{arg1})
	fake.recordInvocation("CleanUp", []interface{}{arg1})
	fake.cleanUpMutex.Unlock()
	if fake.CleanUpStub != nil {
		return fake.CleanUpStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cleanUpReturns
	return fakeReturns.result1
}

func (fake *FakeDirector) CleanUpCallCount() int {
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	return len(fake.cleanUpArgsForCall)
}

func (fake *FakeDirector) CleanUpCalls(stub func(bool) error) {
	fake.cleanUpMutex.Lock()
	defer fake.cleanUpMutex.Unlock()
	fake.CleanUpStub = stub
}

func (fake *FakeDirector) CleanUpArgsForCall(i int) bool {
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	argsForCall := fake.cleanUpArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) CleanUpReturns(result1 error) {
	fake.cleanUpMutex.Lock()
	defer fake.cleanUpMutex.Unlock()
	fake.CleanUpStub = nil
	fake.cleanUpReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) CleanUpReturnsOnCall(i int, result1 error) {
	fake.cleanUpMutex.Lock()
	defer fake.cleanUpMutex.Unlock()
	fake.CleanUpStub = nil
	if fake.cleanUpReturnsOnCall == nil {
		fake.cleanUpReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cleanUpReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) CurrentTasks(arg1 director.TasksFilter) ([]director.Task, error) {
	fake.currentTasksMutex.Lock()
	ret, specificReturn := fake.currentTasksReturnsOnCall[len(fake.currentTasksArgsForCall)]
	fake.currentTasksArgsForCall = append(fake.currentTasksArgsForCall, struct {
		arg1 director.TasksFilter
	}{arg1})
	fake.recordInvocation("CurrentTasks", []interface{}{arg1})
	fake.currentTasksMutex.Unlock()
	if fake.CurrentTasksStub != nil {
		return fake.CurrentTasksStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.currentTasksReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) CurrentTasksCallCount() int {
	fake.currentTasksMutex.RLock()
	defer fake.currentTasksMutex.RUnlock()
	return len(fake.currentTasksArgsForCall)
}

func (fake *FakeDirector) CurrentTasksCalls(stub func(director.TasksFilter) ([]director.Task, error)) {
	fake.currentTasksMutex.Lock()
	defer fake.currentTasksMutex.Unlock()
	fake.CurrentTasksStub = stub
}

func (fake *FakeDirector) CurrentTasksArgsForCall(i int) director.TasksFilter {
	fake.currentTasksMutex.RLock()
	defer fake.currentTasksMutex.RUnlock()
	argsForCall := fake.currentTasksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) CurrentTasksReturns(result1 []director.Task, result2 error) {
	fake.currentTasksMutex.Lock()
	defer fake.currentTasksMutex.Unlock()
	fake.CurrentTasksStub = nil
	fake.currentTasksReturns = struct {
		result1 []director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) CurrentTasksReturnsOnCall(i int, result1 []director.Task, result2 error) {
	fake.currentTasksMutex.Lock()
	defer fake.currentTasksMutex.Unlock()
	fake.CurrentTasksStub = nil
	if fake.currentTasksReturnsOnCall == nil {
		fake.currentTasksReturnsOnCall = make(map[int]struct {
			result1 []director.Task
			result2 error
		})
	}
	fake.currentTasksReturnsOnCall[i] = struct {
		result1 []director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DeleteConfig(arg1 string, arg2 string) (bool, error) {
	fake.deleteConfigMutex.Lock()
	ret, specificReturn := fake.deleteConfigReturnsOnCall[len(fake.deleteConfigArgsForCall)]
	fake.deleteConfigArgsForCall = append(fake.deleteConfigArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("DeleteConfig", []interface{}{arg1, arg2})
	fake.deleteConfigMutex.Unlock()
	if fake.DeleteConfigStub != nil {
		return fake.DeleteConfigStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteConfigReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) DeleteConfigCallCount() int {
	fake.deleteConfigMutex.RLock()
	defer fake.deleteConfigMutex.RUnlock()
	return len(fake.deleteConfigArgsForCall)
}

func (fake *FakeDirector) DeleteConfigCalls(stub func(string, string) (bool, error)) {
	fake.deleteConfigMutex.Lock()
	defer fake.deleteConfigMutex.Unlock()
	fake.DeleteConfigStub = stub
}

func (fake *FakeDirector) DeleteConfigArgsForCall(i int) (string, string) {
	fake.deleteConfigMutex.RLock()
	defer fake.deleteConfigMutex.RUnlock()
	argsForCall := fake.deleteConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) DeleteConfigReturns(result1 bool, result2 error) {
	fake.deleteConfigMutex.Lock()
	defer fake.deleteConfigMutex.Unlock()
	fake.DeleteConfigStub = nil
	fake.deleteConfigReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DeleteConfigReturnsOnCall(i int, result1 bool, result2 error) {
	fake.deleteConfigMutex.Lock()
	defer fake.deleteConfigMutex.Unlock()
	fake.DeleteConfigStub = nil
	if fake.deleteConfigReturnsOnCall == nil {
		fake.deleteConfigReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deleteConfigReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DeleteConfigByID(arg1 string) (bool, error) {
	fake.deleteConfigByIDMutex.Lock()
	ret, specificReturn := fake.deleteConfigByIDReturnsOnCall[len(fake.deleteConfigByIDArgsForCall)]
	fake.deleteConfigByIDArgsForCall = append(fake.deleteConfigByIDArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DeleteConfigByID", []interface{}{arg1})
	fake.deleteConfigByIDMutex.Unlock()
	if fake.DeleteConfigByIDStub != nil {
		return fake.DeleteConfigByIDStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteConfigByIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) DeleteConfigByIDCallCount() int {
	fake.deleteConfigByIDMutex.RLock()
	defer fake.deleteConfigByIDMutex.RUnlock()
	return len(fake.deleteConfigByIDArgsForCall)
}

func (fake *FakeDirector) DeleteConfigByIDCalls(stub func(string) (bool, error)) {
	fake.deleteConfigByIDMutex.Lock()
	defer fake.deleteConfigByIDMutex.Unlock()
	fake.DeleteConfigByIDStub = stub
}

func (fake *FakeDirector) DeleteConfigByIDArgsForCall(i int) string {
	fake.deleteConfigByIDMutex.RLock()
	defer fake.deleteConfigByIDMutex.RUnlock()
	argsForCall := fake.deleteConfigByIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) DeleteConfigByIDReturns(result1 bool, result2 error) {
	fake.deleteConfigByIDMutex.Lock()
	defer fake.deleteConfigByIDMutex.Unlock()
	fake.DeleteConfigByIDStub = nil
	fake.deleteConfigByIDReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DeleteConfigByIDReturnsOnCall(i int, result1 bool, result2 error) {
	fake.deleteConfigByIDMutex.Lock()
	defer fake.deleteConfigByIDMutex.Unlock()
	fake.DeleteConfigByIDStub = nil
	if fake.deleteConfigByIDReturnsOnCall == nil {
		fake.deleteConfigByIDReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deleteConfigByIDReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Deployments() ([]director.Deployment, error) {
	fake.deploymentsMutex.Lock()
	ret, specificReturn := fake.deploymentsReturnsOnCall[len(fake.deploymentsArgsForCall)]
	fake.deploymentsArgsForCall = append(fake.deploymentsArgsForCall, struct {
	}{})
	fake.recordInvocation("Deployments", []interface{}{})
	fake.deploymentsMutex.Unlock()
	if fake.DeploymentsStub != nil {
		return fake.DeploymentsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deploymentsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) DeploymentsCallCount() int {
	fake.deploymentsMutex.RLock()
	defer fake.deploymentsMutex.RUnlock()
	return len(fake.deploymentsArgsForCall)
}

func (fake *FakeDirector) DeploymentsCalls(stub func() ([]director.Deployment, error)) {
	fake.deploymentsMutex.Lock()
	defer fake.deploymentsMutex.Unlock()
	fake.DeploymentsStub = stub
}

func (fake *FakeDirector) DeploymentsReturns(result1 []director.Deployment, result2 error) {
	fake.deploymentsMutex.Lock()
	defer fake.deploymentsMutex.Unlock()
	fake.DeploymentsStub = nil
	fake.deploymentsReturns = struct {
		result1 []director.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DeploymentsReturnsOnCall(i int, result1 []director.Deployment, result2 error) {
	fake.deploymentsMutex.Lock()
	defer fake.deploymentsMutex.Unlock()
	fake.DeploymentsStub = nil
	if fake.deploymentsReturnsOnCall == nil {
		fake.deploymentsReturnsOnCall = make(map[int]struct {
			result1 []director.Deployment
			result2 error
		})
	}
	fake.deploymentsReturnsOnCall[i] = struct {
		result1 []director.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffCPIConfig(arg1 []byte, arg2 bool) (director.ConfigDiff, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.diffCPIConfigMutex.Lock()
	ret, specificReturn := fake.diffCPIConfigReturnsOnCall[len(fake.diffCPIConfigArgsForCall)]
	fake.diffCPIConfigArgsForCall = append(fake.diffCPIConfigArgsForCall, struct {
		arg1 []byte
		arg2 bool
	}{arg1Copy, arg2})
	fake.recordInvocation("DiffCPIConfig", []interface{}{arg1Copy, arg2})
	fake.diffCPIConfigMutex.Unlock()
	if fake.DiffCPIConfigStub != nil {
		return fake.DiffCPIConfigStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.diffCPIConfigReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) DiffCPIConfigCallCount() int {
	fake.diffCPIConfigMutex.RLock()
	defer fake.diffCPIConfigMutex.RUnlock()
	return len(fake.diffCPIConfigArgsForCall)
}

func (fake *FakeDirector) DiffCPIConfigCalls(stub func([]byte, bool) (director.ConfigDiff, error)) {
	fake.diffCPIConfigMutex.Lock()
	defer fake.diffCPIConfigMutex.Unlock()
	fake.DiffCPIConfigStub = stub
}

func (fake *FakeDirector) DiffCPIConfigArgsForCall(i int) ([]byte, bool) {
	fake.diffCPIConfigMutex.RLock()
	defer fake.diffCPIConfigMutex.RUnlock()
	argsForCall := fake.diffCPIConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) DiffCPIConfigReturns(result1 director.ConfigDiff, result2 error) {
	fake.diffCPIConfigMutex.Lock()
	defer fake.diffCPIConfigMutex.Unlock()
	fake.DiffCPIConfigStub = nil
	fake.diffCPIConfigReturns = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffCPIConfigReturnsOnCall(i int, result1 director.ConfigDiff, result2 error) {
	fake.diffCPIConfigMutex.Lock()
	defer fake.diffCPIConfigMutex.Unlock()
	fake.DiffCPIConfigStub = nil
	if fake.diffCPIConfigReturnsOnCall == nil {
		fake.diffCPIConfigReturnsOnCall = make(map[int]struct {
			result1 director.ConfigDiff
			result2 error
		})
	}
	fake.diffCPIConfigReturnsOnCall[i] = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffCloudConfig(arg1 []byte) (director.ConfigDiff, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.diffCloudConfigMutex.Lock()
	ret, specificReturn := fake.diffCloudConfigReturnsOnCall[len(fake.diffCloudConfigArgsForCall)]
	fake.diffCloudConfigArgsForCall = append(fake.diffCloudConfigArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	fake.recordInvocation("DiffCloudConfig", []interface{}{arg1Copy})
	fake.diffCloudConfigMutex.Unlock()
	if fake.DiffCloudConfigStub != nil {
		return fake.DiffCloudConfigStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.diffCloudConfigReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) DiffCloudConfigCallCount() int {
	fake.diffCloudConfigMutex.RLock()
	defer fake.diffCloudConfigMutex.RUnlock()
	return len(fake.diffCloudConfigArgsForCall)
}

func (fake *FakeDirector) DiffCloudConfigCalls(stub func([]byte) (director.ConfigDiff, error)) {
	fake.diffCloudConfigMutex.Lock()
	defer fake.diffCloudConfigMutex.Unlock()
	fake.DiffCloudConfigStub = stub
}

func (fake *FakeDirector) DiffCloudConfigArgsForCall(i int) []byte {
	fake.diffCloudConfigMutex.RLock()
	defer fake.diffCloudConfigMutex.RUnlock()
	argsForCall := fake.diffCloudConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) DiffCloudConfigReturns(result1 director.ConfigDiff, result2 error) {
	fake.diffCloudConfigMutex.Lock()
	defer fake.diffCloudConfigMutex.Unlock()
	fake.DiffCloudConfigStub = nil
	fake.diffCloudConfigReturns = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffCloudConfigReturnsOnCall(i int, result1 director.ConfigDiff, result2 error) {
	fake.diffCloudConfigMutex.Lock()
	defer fake.diffCloudConfigMutex.Unlock()
	fake.DiffCloudConfigStub = nil
	if fake.diffCloudConfigReturnsOnCall == nil {
		fake.diffCloudConfigReturnsOnCall = make(map[int]struct {
			result1 director.ConfigDiff
			result2 error
		})
	}
	fake.diffCloudConfigReturnsOnCall[i] = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffConfig(arg1 string, arg2 string, arg3 []byte) (director.ConfigDiff, error) {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.diffConfigMutex.Lock()
	ret, specificReturn := fake.diffConfigReturnsOnCall[len(fake.diffConfigArgsForCall)]
	fake.diffConfigArgsForCall = append(fake.diffConfigArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	fake.recordInvocation("DiffConfig", []interface{}{arg1, arg2, arg3Copy})
	fake.diffConfigMutex.Unlock()
	if fake.DiffConfigStub != nil {
		return fake.DiffConfigStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.diffConfigReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) DiffConfigCallCount() int {
	fake.diffConfigMutex.RLock()
	defer fake.diffConfigMutex.RUnlock()
	return len(fake.diffConfigArgsForCall)
}

func (fake *FakeDirector) DiffConfigCalls(stub func(string, string, []byte) (director.ConfigDiff, error)) {
	fake.diffConfigMutex.Lock()
	defer fake.diffConfigMutex.Unlock()
	fake.DiffConfigStub = stub
}

func (fake *FakeDirector) DiffConfigArgsForCall(i int) (string, string, []byte) {
	fake.diffConfigMutex.RLock()
	defer fake.diffConfigMutex.RUnlock()
	argsForCall := fake.diffConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDirector) DiffConfigReturns(result1 director.ConfigDiff, result2 error) {
	fake.diffConfigMutex.Lock()
	defer fake.diffConfigMutex.Unlock()
	fake.DiffConfigStub = nil
	fake.diffConfigReturns = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffConfigReturnsOnCall(i int, result1 director.ConfigDiff, result2 error) {
	fake.diffConfigMutex.Lock()
	defer fake.diffConfigMutex.Unlock()
	fake.DiffConfigStub = nil
	if fake.diffConfigReturnsOnCall == nil {
		fake.diffConfigReturnsOnCall = make(map[int]struct {
			result1 director.ConfigDiff
			result2 error
		})
	}
	fake.diffConfigReturnsOnCall[i] = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffConfigByIDOrContent(arg1 string, arg2 []byte, arg3 string, arg4 []byte) (director.ConfigDiff, error) {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	var arg4Copy []byte
	if arg4 != nil {
		arg4Copy = make([]byte, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.diffConfigByIDOrContentMutex.Lock()
	ret, specificReturn := fake.diffConfigByIDOrContentReturnsOnCall[len(fake.diffConfigByIDOrContentArgsForCall)]
	fake.diffConfigByIDOrContentArgsForCall = append(fake.diffConfigByIDOrContentArgsForCall, struct {
		arg1 string
		arg2 []byte
		arg3 string
		arg4 []byte
	}{arg1, arg2Copy, arg3, arg4Copy})
	fake.recordInvocation("DiffConfigByIDOrContent", []interface{}{arg1, arg2Copy, arg3, arg4Copy})
	fake.diffConfigByIDOrContentMutex.Unlock()
	if fake.DiffConfigByIDOrContentStub != nil {
		return fake.DiffConfigByIDOrContentStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.diffConfigByIDOrContentReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) DiffConfigByIDOrContentCallCount() int {
	fake.diffConfigByIDOrContentMutex.RLock()
	defer fake.diffConfigByIDOrContentMutex.RUnlock()
	return len(fake.diffConfigByIDOrContentArgsForCall)
}

func (fake *FakeDirector) DiffConfigByIDOrContentCalls(stub func(string, []byte, string, []byte) (director.ConfigDiff, error)) {
	fake.diffConfigByIDOrContentMutex.Lock()
	defer fake.diffConfigByIDOrContentMutex.Unlock()
	fake.DiffConfigByIDOrContentStub = stub
}

func (fake *FakeDirector) DiffConfigByIDOrContentArgsForCall(i int) (string, []byte, string, []byte) {
	fake.diffConfigByIDOrContentMutex.RLock()
	defer fake.diffConfigByIDOrContentMutex.RUnlock()
	argsForCall := fake.diffConfigByIDOrContentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeDirector) DiffConfigByIDOrContentReturns(result1 director.ConfigDiff, result2 error) {
	fake.diffConfigByIDOrContentMutex.Lock()
	defer fake.diffConfigByIDOrContentMutex.Unlock()
	fake.DiffConfigByIDOrContentStub = nil
	fake.diffConfigByIDOrContentReturns = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffConfigByIDOrContentReturnsOnCall(i int, result1 director.ConfigDiff, result2 error) {
	fake.diffConfigByIDOrContentMutex.Lock()
	defer fake.diffConfigByIDOrContentMutex.Unlock()
	fake.DiffConfigByIDOrContentStub = nil
	if fake.diffConfigByIDOrContentReturnsOnCall == nil {
		fake.diffConfigByIDOrContentReturnsOnCall = make(map[int]struct {
			result1 director.ConfigDiff
			result2 error
		})
	}
	fake.diffConfigByIDOrContentReturnsOnCall[i] = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffRuntimeConfig(arg1 string, arg2 []byte, arg3 bool) (director.ConfigDiff, error) {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.diffRuntimeConfigMutex.Lock()
	ret, specificReturn := fake.diffRuntimeConfigReturnsOnCall[len(fake.diffRuntimeConfigArgsForCall)]
	fake.diffRuntimeConfigArgsForCall = append(fake.diffRuntimeConfigArgsForCall, struct {
		arg1 string
		arg2 []byte
		arg3 bool
	}{arg1, arg2Copy, arg3})
	fake.recordInvocation("DiffRuntimeConfig", []interface{}{arg1, arg2Copy, arg3})
	fake.diffRuntimeConfigMutex.Unlock()
	if fake.DiffRuntimeConfigStub != nil {
		return fake.DiffRuntimeConfigStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.diffRuntimeConfigReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) DiffRuntimeConfigCallCount() int {
	fake.diffRuntimeConfigMutex.RLock()
	defer fake.diffRuntimeConfigMutex.RUnlock()
	return len(fake.diffRuntimeConfigArgsForCall)
}

func (fake *FakeDirector) DiffRuntimeConfigCalls(stub func(string, []byte, bool) (director.ConfigDiff, error)) {
	fake.diffRuntimeConfigMutex.Lock()
	defer fake.diffRuntimeConfigMutex.Unlock()
	fake.DiffRuntimeConfigStub = stub
}

func (fake *FakeDirector) DiffRuntimeConfigArgsForCall(i int) (string, []byte, bool) {
	fake.diffRuntimeConfigMutex.RLock()
	defer fake.diffRuntimeConfigMutex.RUnlock()
	argsForCall := fake.diffRuntimeConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDirector) DiffRuntimeConfigReturns(result1 director.ConfigDiff, result2 error) {
	fake.diffRuntimeConfigMutex.Lock()
	defer fake.diffRuntimeConfigMutex.Unlock()
	fake.DiffRuntimeConfigStub = nil
	fake.diffRuntimeConfigReturns = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DiffRuntimeConfigReturnsOnCall(i int, result1 director.ConfigDiff, result2 error) {
	fake.diffRuntimeConfigMutex.Lock()
	defer fake.diffRuntimeConfigMutex.Unlock()
	fake.DiffRuntimeConfigStub = nil
	if fake.diffRuntimeConfigReturnsOnCall == nil {
		fake.diffRuntimeConfigReturnsOnCall = make(map[int]struct {
			result1 director.ConfigDiff
			result2 error
		})
	}
	fake.diffRuntimeConfigReturnsOnCall[i] = struct {
		result1 director.ConfigDiff
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) DownloadResourceUnchecked(arg1 string, arg2 io.Writer) error {
	fake.downloadResourceUncheckedMutex.Lock()
	ret, specificReturn := fake.downloadResourceUncheckedReturnsOnCall[len(fake.downloadResourceUncheckedArgsForCall)]
	fake.downloadResourceUncheckedArgsForCall = append(fake.downloadResourceUncheckedArgsForCall, struct {
		arg1 string
		arg2 io.Writer
	}{arg1, arg2})
	fake.recordInvocation("DownloadResourceUnchecked", []interface{}{arg1, arg2})
	fake.downloadResourceUncheckedMutex.Unlock()
	if fake.DownloadResourceUncheckedStub != nil {
		return fake.DownloadResourceUncheckedStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.downloadResourceUncheckedReturns
	return fakeReturns.result1
}

func (fake *FakeDirector) DownloadResourceUncheckedCallCount() int {
	fake.downloadResourceUncheckedMutex.RLock()
	defer fake.downloadResourceUncheckedMutex.RUnlock()
	return len(fake.downloadResourceUncheckedArgsForCall)
}

func (fake *FakeDirector) DownloadResourceUncheckedCalls(stub func(string, io.Writer) error) {
	fake.downloadResourceUncheckedMutex.Lock()
	defer fake.downloadResourceUncheckedMutex.Unlock()
	fake.DownloadResourceUncheckedStub = stub
}

func (fake *FakeDirector) DownloadResourceUncheckedArgsForCall(i int) (string, io.Writer) {
	fake.downloadResourceUncheckedMutex.RLock()
	defer fake.downloadResourceUncheckedMutex.RUnlock()
	argsForCall := fake.downloadResourceUncheckedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) DownloadResourceUncheckedReturns(result1 error) {
	fake.downloadResourceUncheckedMutex.Lock()
	defer fake.downloadResourceUncheckedMutex.Unlock()
	fake.DownloadResourceUncheckedStub = nil
	fake.downloadResourceUncheckedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) DownloadResourceUncheckedReturnsOnCall(i int, result1 error) {
	fake.downloadResourceUncheckedMutex.Lock()
	defer fake.downloadResourceUncheckedMutex.Unlock()
	fake.DownloadResourceUncheckedStub = nil
	if fake.downloadResourceUncheckedReturnsOnCall == nil {
		fake.downloadResourceUncheckedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.downloadResourceUncheckedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) EnableResurrection(arg1 bool) error {
	fake.enableResurrectionMutex.Lock()
	ret, specificReturn := fake.enableResurrectionReturnsOnCall[len(fake.enableResurrectionArgsForCall)]
	fake.enableResurrectionArgsForCall = append(fake.enableResurrectionArgsForCall, struct {
		arg1 bool
	}{arg1})
	fake.recordInvocation("EnableResurrection", []interface{}{arg1})
	fake.enableResurrectionMutex.Unlock()
	if fake.EnableResurrectionStub != nil {
		return fake.EnableResurrectionStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.enableResurrectionReturns
	return fakeReturns.result1
}

func (fake *FakeDirector) EnableResurrectionCallCount() int {
	fake.enableResurrectionMutex.RLock()
	defer fake.enableResurrectionMutex.RUnlock()
	return len(fake.enableResurrectionArgsForCall)
}

func (fake *FakeDirector) EnableResurrectionCalls(stub func(bool) error) {
	fake.enableResurrectionMutex.Lock()
	defer fake.enableResurrectionMutex.Unlock()
	fake.EnableResurrectionStub = stub
}

func (fake *FakeDirector) EnableResurrectionArgsForCall(i int) bool {
	fake.enableResurrectionMutex.RLock()
	defer fake.enableResurrectionMutex.RUnlock()
	argsForCall := fake.enableResurrectionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) EnableResurrectionReturns(result1 error) {
	fake.enableResurrectionMutex.Lock()
	defer fake.enableResurrectionMutex.Unlock()
	fake.EnableResurrectionStub = nil
	fake.enableResurrectionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) EnableResurrectionReturnsOnCall(i int, result1 error) {
	fake.enableResurrectionMutex.Lock()
	defer fake.enableResurrectionMutex.Unlock()
	fake.EnableResurrectionStub = nil
	if fake.enableResurrectionReturnsOnCall == nil {
		fake.enableResurrectionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.enableResurrectionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) Event(arg1 string) (director.Event, error) {
	fake.eventMutex.Lock()
	ret, specificReturn := fake.eventReturnsOnCall[len(fake.eventArgsForCall)]
	fake.eventArgsForCall = append(fake.eventArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Event", []interface{}{arg1})
	fake.eventMutex.Unlock()
	if fake.EventStub != nil {
		return fake.EventStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.eventReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) EventCallCount() int {
	fake.eventMutex.RLock()
	defer fake.eventMutex.RUnlock()
	return len(fake.eventArgsForCall)
}

func (fake *FakeDirector) EventCalls(stub func(string) (director.Event, error)) {
	fake.eventMutex.Lock()
	defer fake.eventMutex.Unlock()
	fake.EventStub = stub
}

func (fake *FakeDirector) EventArgsForCall(i int) string {
	fake.eventMutex.RLock()
	defer fake.eventMutex.RUnlock()
	argsForCall := fake.eventArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) EventReturns(result1 director.Event, result2 error) {
	fake.eventMutex.Lock()
	defer fake.eventMutex.Unlock()
	fake.EventStub = nil
	fake.eventReturns = struct {
		result1 director.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) EventReturnsOnCall(i int, result1 director.Event, result2 error) {
	fake.eventMutex.Lock()
	defer fake.eventMutex.Unlock()
	fake.EventStub = nil
	if fake.eventReturnsOnCall == nil {
		fake.eventReturnsOnCall = make(map[int]struct {
			result1 director.Event
			result2 error
		})
	}
	fake.eventReturnsOnCall[i] = struct {
		result1 director.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Events(arg1 director.EventsFilter) ([]director.Event, error) {
	fake.eventsMutex.Lock()
	ret, specificReturn := fake.eventsReturnsOnCall[len(fake.eventsArgsForCall)]
	fake.eventsArgsForCall = append(fake.eventsArgsForCall, struct {
		arg1 director.EventsFilter
	}{arg1})
	fake.recordInvocation("Events", []interface{}{arg1})
	fake.eventsMutex.Unlock()
	if fake.EventsStub != nil {
		return fake.EventsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.eventsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) EventsCallCount() int {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	return len(fake.eventsArgsForCall)
}

func (fake *FakeDirector) EventsCalls(stub func(director.EventsFilter) ([]director.Event, error)) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = stub
}

func (fake *FakeDirector) EventsArgsForCall(i int) director.EventsFilter {
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	argsForCall := fake.eventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) EventsReturns(result1 []director.Event, result2 error) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = nil
	fake.eventsReturns = struct {
		result1 []director.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) EventsReturnsOnCall(i int, result1 []director.Event, result2 error) {
	fake.eventsMutex.Lock()
	defer fake.eventsMutex.Unlock()
	fake.EventsStub = nil
	if fake.eventsReturnsOnCall == nil {
		fake.eventsReturnsOnCall = make(map[int]struct {
			result1 []director.Event
			result2 error
		})
	}
	fake.eventsReturnsOnCall[i] = struct {
		result1 []director.Event
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindDeployment(arg1 string) (director.Deployment, error) {
	fake.findDeploymentMutex.Lock()
	ret, specificReturn := fake.findDeploymentReturnsOnCall[len(fake.findDeploymentArgsForCall)]
	fake.findDeploymentArgsForCall = append(fake.findDeploymentArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindDeployment", []interface{}{arg1})
	fake.findDeploymentMutex.Unlock()
	if fake.FindDeploymentStub != nil {
		return fake.FindDeploymentStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findDeploymentReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) FindDeploymentCallCount() int {
	fake.findDeploymentMutex.RLock()
	defer fake.findDeploymentMutex.RUnlock()
	return len(fake.findDeploymentArgsForCall)
}

func (fake *FakeDirector) FindDeploymentCalls(stub func(string) (director.Deployment, error)) {
	fake.findDeploymentMutex.Lock()
	defer fake.findDeploymentMutex.Unlock()
	fake.FindDeploymentStub = stub
}

func (fake *FakeDirector) FindDeploymentArgsForCall(i int) string {
	fake.findDeploymentMutex.RLock()
	defer fake.findDeploymentMutex.RUnlock()
	argsForCall := fake.findDeploymentArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) FindDeploymentReturns(result1 director.Deployment, result2 error) {
	fake.findDeploymentMutex.Lock()
	defer fake.findDeploymentMutex.Unlock()
	fake.FindDeploymentStub = nil
	fake.findDeploymentReturns = struct {
		result1 director.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindDeploymentReturnsOnCall(i int, result1 director.Deployment, result2 error) {
	fake.findDeploymentMutex.Lock()
	defer fake.findDeploymentMutex.Unlock()
	fake.FindDeploymentStub = nil
	if fake.findDeploymentReturnsOnCall == nil {
		fake.findDeploymentReturnsOnCall = make(map[int]struct {
			result1 director.Deployment
			result2 error
		})
	}
	fake.findDeploymentReturnsOnCall[i] = struct {
		result1 director.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindOrphanDisk(arg1 string) (director.OrphanDisk, error) {
	fake.findOrphanDiskMutex.Lock()
	ret, specificReturn := fake.findOrphanDiskReturnsOnCall[len(fake.findOrphanDiskArgsForCall)]
	fake.findOrphanDiskArgsForCall = append(fake.findOrphanDiskArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindOrphanDisk", []interface{}{arg1})
	fake.findOrphanDiskMutex.Unlock()
	if fake.FindOrphanDiskStub != nil {
		return fake.FindOrphanDiskStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findOrphanDiskReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) FindOrphanDiskCallCount() int {
	fake.findOrphanDiskMutex.RLock()
	defer fake.findOrphanDiskMutex.RUnlock()
	return len(fake.findOrphanDiskArgsForCall)
}

func (fake *FakeDirector) FindOrphanDiskCalls(stub func(string) (director.OrphanDisk, error)) {
	fake.findOrphanDiskMutex.Lock()
	defer fake.findOrphanDiskMutex.Unlock()
	fake.FindOrphanDiskStub = stub
}

func (fake *FakeDirector) FindOrphanDiskArgsForCall(i int) string {
	fake.findOrphanDiskMutex.RLock()
	defer fake.findOrphanDiskMutex.RUnlock()
	argsForCall := fake.findOrphanDiskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) FindOrphanDiskReturns(result1 director.OrphanDisk, result2 error) {
	fake.findOrphanDiskMutex.Lock()
	defer fake.findOrphanDiskMutex.Unlock()
	fake.FindOrphanDiskStub = nil
	fake.findOrphanDiskReturns = struct {
		result1 director.OrphanDisk
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindOrphanDiskReturnsOnCall(i int, result1 director.OrphanDisk, result2 error) {
	fake.findOrphanDiskMutex.Lock()
	defer fake.findOrphanDiskMutex.Unlock()
	fake.FindOrphanDiskStub = nil
	if fake.findOrphanDiskReturnsOnCall == nil {
		fake.findOrphanDiskReturnsOnCall = make(map[int]struct {
			result1 director.OrphanDisk
			result2 error
		})
	}
	fake.findOrphanDiskReturnsOnCall[i] = struct {
		result1 director.OrphanDisk
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindOrphanNetwork(arg1 string) (director.OrphanNetwork, error) {
	fake.findOrphanNetworkMutex.Lock()
	ret, specificReturn := fake.findOrphanNetworkReturnsOnCall[len(fake.findOrphanNetworkArgsForCall)]
	fake.findOrphanNetworkArgsForCall = append(fake.findOrphanNetworkArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindOrphanNetwork", []interface{}{arg1})
	fake.findOrphanNetworkMutex.Unlock()
	if fake.FindOrphanNetworkStub != nil {
		return fake.FindOrphanNetworkStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findOrphanNetworkReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) FindOrphanNetworkCallCount() int {
	fake.findOrphanNetworkMutex.RLock()
	defer fake.findOrphanNetworkMutex.RUnlock()
	return len(fake.findOrphanNetworkArgsForCall)
}

func (fake *FakeDirector) FindOrphanNetworkCalls(stub func(string) (director.OrphanNetwork, error)) {
	fake.findOrphanNetworkMutex.Lock()
	defer fake.findOrphanNetworkMutex.Unlock()
	fake.FindOrphanNetworkStub = stub
}

func (fake *FakeDirector) FindOrphanNetworkArgsForCall(i int) string {
	fake.findOrphanNetworkMutex.RLock()
	defer fake.findOrphanNetworkMutex.RUnlock()
	argsForCall := fake.findOrphanNetworkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) FindOrphanNetworkReturns(result1 director.OrphanNetwork, result2 error) {
	fake.findOrphanNetworkMutex.Lock()
	defer fake.findOrphanNetworkMutex.Unlock()
	fake.FindOrphanNetworkStub = nil
	fake.findOrphanNetworkReturns = struct {
		result1 director.OrphanNetwork
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindOrphanNetworkReturnsOnCall(i int, result1 director.OrphanNetwork, result2 error) {
	fake.findOrphanNetworkMutex.Lock()
	defer fake.findOrphanNetworkMutex.Unlock()
	fake.FindOrphanNetworkStub = nil
	if fake.findOrphanNetworkReturnsOnCall == nil {
		fake.findOrphanNetworkReturnsOnCall = make(map[int]struct {
			result1 director.OrphanNetwork
			result2 error
		})
	}
	fake.findOrphanNetworkReturnsOnCall[i] = struct {
		result1 director.OrphanNetwork
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindRelease(arg1 director.ReleaseSlug) (director.Release, error) {
	fake.findReleaseMutex.Lock()
	ret, specificReturn := fake.findReleaseReturnsOnCall[len(fake.findReleaseArgsForCall)]
	fake.findReleaseArgsForCall = append(fake.findReleaseArgsForCall, struct {
		arg1 director.ReleaseSlug
	}{arg1})
	fake.recordInvocation("FindRelease", []interface{}{arg1})
	fake.findReleaseMutex.Unlock()
	if fake.FindReleaseStub != nil {
		return fake.FindReleaseStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findReleaseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) FindReleaseCallCount() int {
	fake.findReleaseMutex.RLock()
	defer fake.findReleaseMutex.RUnlock()
	return len(fake.findReleaseArgsForCall)
}

func (fake *FakeDirector) FindReleaseCalls(stub func(director.ReleaseSlug) (director.Release, error)) {
	fake.findReleaseMutex.Lock()
	defer fake.findReleaseMutex.Unlock()
	fake.FindReleaseStub = stub
}

func (fake *FakeDirector) FindReleaseArgsForCall(i int) director.ReleaseSlug {
	fake.findReleaseMutex.RLock()
	defer fake.findReleaseMutex.RUnlock()
	argsForCall := fake.findReleaseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) FindReleaseReturns(result1 director.Release, result2 error) {
	fake.findReleaseMutex.Lock()
	defer fake.findReleaseMutex.Unlock()
	fake.FindReleaseStub = nil
	fake.findReleaseReturns = struct {
		result1 director.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindReleaseReturnsOnCall(i int, result1 director.Release, result2 error) {
	fake.findReleaseMutex.Lock()
	defer fake.findReleaseMutex.Unlock()
	fake.FindReleaseStub = nil
	if fake.findReleaseReturnsOnCall == nil {
		fake.findReleaseReturnsOnCall = make(map[int]struct {
			result1 director.Release
			result2 error
		})
	}
	fake.findReleaseReturnsOnCall[i] = struct {
		result1 director.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindReleaseSeries(arg1 director.ReleaseSeriesSlug) (director.ReleaseSeries, error) {
	fake.findReleaseSeriesMutex.Lock()
	ret, specificReturn := fake.findReleaseSeriesReturnsOnCall[len(fake.findReleaseSeriesArgsForCall)]
	fake.findReleaseSeriesArgsForCall = append(fake.findReleaseSeriesArgsForCall, struct {
		arg1 director.ReleaseSeriesSlug
	}{arg1})
	fake.recordInvocation("FindReleaseSeries", []interface{}{arg1})
	fake.findReleaseSeriesMutex.Unlock()
	if fake.FindReleaseSeriesStub != nil {
		return fake.FindReleaseSeriesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findReleaseSeriesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) FindReleaseSeriesCallCount() int {
	fake.findReleaseSeriesMutex.RLock()
	defer fake.findReleaseSeriesMutex.RUnlock()
	return len(fake.findReleaseSeriesArgsForCall)
}

func (fake *FakeDirector) FindReleaseSeriesCalls(stub func(director.ReleaseSeriesSlug) (director.ReleaseSeries, error)) {
	fake.findReleaseSeriesMutex.Lock()
	defer fake.findReleaseSeriesMutex.Unlock()
	fake.FindReleaseSeriesStub = stub
}

func (fake *FakeDirector) FindReleaseSeriesArgsForCall(i int) director.ReleaseSeriesSlug {
	fake.findReleaseSeriesMutex.RLock()
	defer fake.findReleaseSeriesMutex.RUnlock()
	argsForCall := fake.findReleaseSeriesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) FindReleaseSeriesReturns(result1 director.ReleaseSeries, result2 error) {
	fake.findReleaseSeriesMutex.Lock()
	defer fake.findReleaseSeriesMutex.Unlock()
	fake.FindReleaseSeriesStub = nil
	fake.findReleaseSeriesReturns = struct {
		result1 director.ReleaseSeries
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindReleaseSeriesReturnsOnCall(i int, result1 director.ReleaseSeries, result2 error) {
	fake.findReleaseSeriesMutex.Lock()
	defer fake.findReleaseSeriesMutex.Unlock()
	fake.FindReleaseSeriesStub = nil
	if fake.findReleaseSeriesReturnsOnCall == nil {
		fake.findReleaseSeriesReturnsOnCall = make(map[int]struct {
			result1 director.ReleaseSeries
			result2 error
		})
	}
	fake.findReleaseSeriesReturnsOnCall[i] = struct {
		result1 director.ReleaseSeries
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindStemcell(arg1 director.StemcellSlug) (director.Stemcell, error) {
	fake.findStemcellMutex.Lock()
	ret, specificReturn := fake.findStemcellReturnsOnCall[len(fake.findStemcellArgsForCall)]
	fake.findStemcellArgsForCall = append(fake.findStemcellArgsForCall, struct {
		arg1 director.StemcellSlug
	}{arg1})
	fake.recordInvocation("FindStemcell", []interface{}{arg1})
	fake.findStemcellMutex.Unlock()
	if fake.FindStemcellStub != nil {
		return fake.FindStemcellStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findStemcellReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) FindStemcellCallCount() int {
	fake.findStemcellMutex.RLock()
	defer fake.findStemcellMutex.RUnlock()
	return len(fake.findStemcellArgsForCall)
}

func (fake *FakeDirector) FindStemcellCalls(stub func(director.StemcellSlug) (director.Stemcell, error)) {
	fake.findStemcellMutex.Lock()
	defer fake.findStemcellMutex.Unlock()
	fake.FindStemcellStub = stub
}

func (fake *FakeDirector) FindStemcellArgsForCall(i int) director.StemcellSlug {
	fake.findStemcellMutex.RLock()
	defer fake.findStemcellMutex.RUnlock()
	argsForCall := fake.findStemcellArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) FindStemcellReturns(result1 director.Stemcell, result2 error) {
	fake.findStemcellMutex.Lock()
	defer fake.findStemcellMutex.Unlock()
	fake.FindStemcellStub = nil
	fake.findStemcellReturns = struct {
		result1 director.Stemcell
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindStemcellReturnsOnCall(i int, result1 director.Stemcell, result2 error) {
	fake.findStemcellMutex.Lock()
	defer fake.findStemcellMutex.Unlock()
	fake.FindStemcellStub = nil
	if fake.findStemcellReturnsOnCall == nil {
		fake.findStemcellReturnsOnCall = make(map[int]struct {
			result1 director.Stemcell
			result2 error
		})
	}
	fake.findStemcellReturnsOnCall[i] = struct {
		result1 director.Stemcell
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindTask(arg1 int) (director.Task, error) {
	fake.findTaskMutex.Lock()
	ret, specificReturn := fake.findTaskReturnsOnCall[len(fake.findTaskArgsForCall)]
	fake.findTaskArgsForCall = append(fake.findTaskArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("FindTask", []interface{}{arg1})
	fake.findTaskMutex.Unlock()
	if fake.FindTaskStub != nil {
		return fake.FindTaskStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findTaskReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) FindTaskCallCount() int {
	fake.findTaskMutex.RLock()
	defer fake.findTaskMutex.RUnlock()
	return len(fake.findTaskArgsForCall)
}

func (fake *FakeDirector) FindTaskCalls(stub func(int) (director.Task, error)) {
	fake.findTaskMutex.Lock()
	defer fake.findTaskMutex.Unlock()
	fake.FindTaskStub = stub
}

func (fake *FakeDirector) FindTaskArgsForCall(i int) int {
	fake.findTaskMutex.RLock()
	defer fake.findTaskMutex.RUnlock()
	argsForCall := fake.findTaskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) FindTaskReturns(result1 director.Task, result2 error) {
	fake.findTaskMutex.Lock()
	defer fake.findTaskMutex.Unlock()
	fake.FindTaskStub = nil
	fake.findTaskReturns = struct {
		result1 director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindTaskReturnsOnCall(i int, result1 director.Task, result2 error) {
	fake.findTaskMutex.Lock()
	defer fake.findTaskMutex.Unlock()
	fake.FindTaskStub = nil
	if fake.findTaskReturnsOnCall == nil {
		fake.findTaskReturnsOnCall = make(map[int]struct {
			result1 director.Task
			result2 error
		})
	}
	fake.findTaskReturnsOnCall[i] = struct {
		result1 director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindTasksByContextId(arg1 string) ([]director.Task, error) {
	fake.findTasksByContextIdMutex.Lock()
	ret, specificReturn := fake.findTasksByContextIdReturnsOnCall[len(fake.findTasksByContextIdArgsForCall)]
	fake.findTasksByContextIdArgsForCall = append(fake.findTasksByContextIdArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindTasksByContextId", []interface{}{arg1})
	fake.findTasksByContextIdMutex.Unlock()
	if fake.FindTasksByContextIdStub != nil {
		return fake.FindTasksByContextIdStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findTasksByContextIdReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) FindTasksByContextIdCallCount() int {
	fake.findTasksByContextIdMutex.RLock()
	defer fake.findTasksByContextIdMutex.RUnlock()
	return len(fake.findTasksByContextIdArgsForCall)
}

func (fake *FakeDirector) FindTasksByContextIdCalls(stub func(string) ([]director.Task, error)) {
	fake.findTasksByContextIdMutex.Lock()
	defer fake.findTasksByContextIdMutex.Unlock()
	fake.FindTasksByContextIdStub = stub
}

func (fake *FakeDirector) FindTasksByContextIdArgsForCall(i int) string {
	fake.findTasksByContextIdMutex.RLock()
	defer fake.findTasksByContextIdMutex.RUnlock()
	argsForCall := fake.findTasksByContextIdArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) FindTasksByContextIdReturns(result1 []director.Task, result2 error) {
	fake.findTasksByContextIdMutex.Lock()
	defer fake.findTasksByContextIdMutex.Unlock()
	fake.FindTasksByContextIdStub = nil
	fake.findTasksByContextIdReturns = struct {
		result1 []director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) FindTasksByContextIdReturnsOnCall(i int, result1 []director.Task, result2 error) {
	fake.findTasksByContextIdMutex.Lock()
	defer fake.findTasksByContextIdMutex.Unlock()
	fake.FindTasksByContextIdStub = nil
	if fake.findTasksByContextIdReturnsOnCall == nil {
		fake.findTasksByContextIdReturnsOnCall = make(map[int]struct {
			result1 []director.Task
			result2 error
		})
	}
	fake.findTasksByContextIdReturnsOnCall[i] = struct {
		result1 []director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) HasRelease(arg1 string, arg2 string, arg3 director.OSVersionSlug) (bool, error) {
	fake.hasReleaseMutex.Lock()
	ret, specificReturn := fake.hasReleaseReturnsOnCall[len(fake.hasReleaseArgsForCall)]
	fake.hasReleaseArgsForCall = append(fake.hasReleaseArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 director.OSVersionSlug
	}{arg1, arg2, arg3})
	fake.recordInvocation("HasRelease", []interface{}{arg1, arg2, arg3})
	fake.hasReleaseMutex.Unlock()
	if fake.HasReleaseStub != nil {
		return fake.HasReleaseStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.hasReleaseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) HasReleaseCallCount() int {
	fake.hasReleaseMutex.RLock()
	defer fake.hasReleaseMutex.RUnlock()
	return len(fake.hasReleaseArgsForCall)
}

func (fake *FakeDirector) HasReleaseCalls(stub func(string, string, director.OSVersionSlug) (bool, error)) {
	fake.hasReleaseMutex.Lock()
	defer fake.hasReleaseMutex.Unlock()
	fake.HasReleaseStub = stub
}

func (fake *FakeDirector) HasReleaseArgsForCall(i int) (string, string, director.OSVersionSlug) {
	fake.hasReleaseMutex.RLock()
	defer fake.hasReleaseMutex.RUnlock()
	argsForCall := fake.hasReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDirector) HasReleaseReturns(result1 bool, result2 error) {
	fake.hasReleaseMutex.Lock()
	defer fake.hasReleaseMutex.Unlock()
	fake.HasReleaseStub = nil
	fake.hasReleaseReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) HasReleaseReturnsOnCall(i int, result1 bool, result2 error) {
	fake.hasReleaseMutex.Lock()
	defer fake.hasReleaseMutex.Unlock()
	fake.HasReleaseStub = nil
	if fake.hasReleaseReturnsOnCall == nil {
		fake.hasReleaseReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.hasReleaseReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) HasStemcell(arg1 string, arg2 string) (bool, error) {
	fake.hasStemcellMutex.Lock()
	ret, specificReturn := fake.hasStemcellReturnsOnCall[len(fake.hasStemcellArgsForCall)]
	fake.hasStemcellArgsForCall = append(fake.hasStemcellArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("HasStemcell", []interface{}{arg1, arg2})
	fake.hasStemcellMutex.Unlock()
	if fake.HasStemcellStub != nil {
		return fake.HasStemcellStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.hasStemcellReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) HasStemcellCallCount() int {
	fake.hasStemcellMutex.RLock()
	defer fake.hasStemcellMutex.RUnlock()
	return len(fake.hasStemcellArgsForCall)
}

func (fake *FakeDirector) HasStemcellCalls(stub func(string, string) (bool, error)) {
	fake.hasStemcellMutex.Lock()
	defer fake.hasStemcellMutex.Unlock()
	fake.HasStemcellStub = stub
}

func (fake *FakeDirector) HasStemcellArgsForCall(i int) (string, string) {
	fake.hasStemcellMutex.RLock()
	defer fake.hasStemcellMutex.RUnlock()
	argsForCall := fake.hasStemcellArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) HasStemcellReturns(result1 bool, result2 error) {
	fake.hasStemcellMutex.Lock()
	defer fake.hasStemcellMutex.Unlock()
	fake.HasStemcellStub = nil
	fake.hasStemcellReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) HasStemcellReturnsOnCall(i int, result1 bool, result2 error) {
	fake.hasStemcellMutex.Lock()
	defer fake.hasStemcellMutex.Unlock()
	fake.HasStemcellStub = nil
	if fake.hasStemcellReturnsOnCall == nil {
		fake.hasStemcellReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.hasStemcellReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Info() (director.Info, error) {
	fake.infoMutex.Lock()
	ret, specificReturn := fake.infoReturnsOnCall[len(fake.infoArgsForCall)]
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct {
	}{})
	fake.recordInvocation("Info", []interface{}{})
	fake.infoMutex.Unlock()
	if fake.InfoStub != nil {
		return fake.InfoStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.infoReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

func (fake *FakeDirector) InfoCalls(stub func() (director.Info, error)) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = stub
}

func (fake *FakeDirector) InfoReturns(result1 director.Info, result2 error) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = nil
	fake.infoReturns = struct {
		result1 director.Info
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) InfoReturnsOnCall(i int, result1 director.Info, result2 error) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = nil
	if fake.infoReturnsOnCall == nil {
		fake.infoReturnsOnCall = make(map[int]struct {
			result1 director.Info
			result2 error
		})
	}
	fake.infoReturnsOnCall[i] = struct {
		result1 director.Info
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) IsAuthenticated() (bool, error) {
	fake.isAuthenticatedMutex.Lock()
	ret, specificReturn := fake.isAuthenticatedReturnsOnCall[len(fake.isAuthenticatedArgsForCall)]
	fake.isAuthenticatedArgsForCall = append(fake.isAuthenticatedArgsForCall, struct {
	}{})
	fake.recordInvocation("IsAuthenticated", []interface{}{})
	fake.isAuthenticatedMutex.Unlock()
	if fake.IsAuthenticatedStub != nil {
		return fake.IsAuthenticatedStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.isAuthenticatedReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) IsAuthenticatedCallCount() int {
	fake.isAuthenticatedMutex.RLock()
	defer fake.isAuthenticatedMutex.RUnlock()
	return len(fake.isAuthenticatedArgsForCall)
}

func (fake *FakeDirector) IsAuthenticatedCalls(stub func() (bool, error)) {
	fake.isAuthenticatedMutex.Lock()
	defer fake.isAuthenticatedMutex.Unlock()
	fake.IsAuthenticatedStub = stub
}

func (fake *FakeDirector) IsAuthenticatedReturns(result1 bool, result2 error) {
	fake.isAuthenticatedMutex.Lock()
	defer fake.isAuthenticatedMutex.Unlock()
	fake.IsAuthenticatedStub = nil
	fake.isAuthenticatedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) IsAuthenticatedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isAuthenticatedMutex.Lock()
	defer fake.isAuthenticatedMutex.Unlock()
	fake.IsAuthenticatedStub = nil
	if fake.isAuthenticatedReturnsOnCall == nil {
		fake.isAuthenticatedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isAuthenticatedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestCPIConfig() (director.CPIConfig, error) {
	fake.latestCPIConfigMutex.Lock()
	ret, specificReturn := fake.latestCPIConfigReturnsOnCall[len(fake.latestCPIConfigArgsForCall)]
	fake.latestCPIConfigArgsForCall = append(fake.latestCPIConfigArgsForCall, struct {
	}{})
	fake.recordInvocation("LatestCPIConfig", []interface{}{})
	fake.latestCPIConfigMutex.Unlock()
	if fake.LatestCPIConfigStub != nil {
		return fake.LatestCPIConfigStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.latestCPIConfigReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) LatestCPIConfigCallCount() int {
	fake.latestCPIConfigMutex.RLock()
	defer fake.latestCPIConfigMutex.RUnlock()
	return len(fake.latestCPIConfigArgsForCall)
}

func (fake *FakeDirector) LatestCPIConfigCalls(stub func() (director.CPIConfig, error)) {
	fake.latestCPIConfigMutex.Lock()
	defer fake.latestCPIConfigMutex.Unlock()
	fake.LatestCPIConfigStub = stub
}

func (fake *FakeDirector) LatestCPIConfigReturns(result1 director.CPIConfig, result2 error) {
	fake.latestCPIConfigMutex.Lock()
	defer fake.latestCPIConfigMutex.Unlock()
	fake.LatestCPIConfigStub = nil
	fake.latestCPIConfigReturns = struct {
		result1 director.CPIConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestCPIConfigReturnsOnCall(i int, result1 director.CPIConfig, result2 error) {
	fake.latestCPIConfigMutex.Lock()
	defer fake.latestCPIConfigMutex.Unlock()
	fake.LatestCPIConfigStub = nil
	if fake.latestCPIConfigReturnsOnCall == nil {
		fake.latestCPIConfigReturnsOnCall = make(map[int]struct {
			result1 director.CPIConfig
			result2 error
		})
	}
	fake.latestCPIConfigReturnsOnCall[i] = struct {
		result1 director.CPIConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestCloudConfig() (director.CloudConfig, error) {
	fake.latestCloudConfigMutex.Lock()
	ret, specificReturn := fake.latestCloudConfigReturnsOnCall[len(fake.latestCloudConfigArgsForCall)]
	fake.latestCloudConfigArgsForCall = append(fake.latestCloudConfigArgsForCall, struct {
	}{})
	fake.recordInvocation("LatestCloudConfig", []interface{}{})
	fake.latestCloudConfigMutex.Unlock()
	if fake.LatestCloudConfigStub != nil {
		return fake.LatestCloudConfigStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.latestCloudConfigReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) LatestCloudConfigCallCount() int {
	fake.latestCloudConfigMutex.RLock()
	defer fake.latestCloudConfigMutex.RUnlock()
	return len(fake.latestCloudConfigArgsForCall)
}

func (fake *FakeDirector) LatestCloudConfigCalls(stub func() (director.CloudConfig, error)) {
	fake.latestCloudConfigMutex.Lock()
	defer fake.latestCloudConfigMutex.Unlock()
	fake.LatestCloudConfigStub = stub
}

func (fake *FakeDirector) LatestCloudConfigReturns(result1 director.CloudConfig, result2 error) {
	fake.latestCloudConfigMutex.Lock()
	defer fake.latestCloudConfigMutex.Unlock()
	fake.LatestCloudConfigStub = nil
	fake.latestCloudConfigReturns = struct {
		result1 director.CloudConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestCloudConfigReturnsOnCall(i int, result1 director.CloudConfig, result2 error) {
	fake.latestCloudConfigMutex.Lock()
	defer fake.latestCloudConfigMutex.Unlock()
	fake.LatestCloudConfigStub = nil
	if fake.latestCloudConfigReturnsOnCall == nil {
		fake.latestCloudConfigReturnsOnCall = make(map[int]struct {
			result1 director.CloudConfig
			result2 error
		})
	}
	fake.latestCloudConfigReturnsOnCall[i] = struct {
		result1 director.CloudConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestConfig(arg1 string, arg2 string) (director.Config, error) {
	fake.latestConfigMutex.Lock()
	ret, specificReturn := fake.latestConfigReturnsOnCall[len(fake.latestConfigArgsForCall)]
	fake.latestConfigArgsForCall = append(fake.latestConfigArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("LatestConfig", []interface{}{arg1, arg2})
	fake.latestConfigMutex.Unlock()
	if fake.LatestConfigStub != nil {
		return fake.LatestConfigStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.latestConfigReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) LatestConfigCallCount() int {
	fake.latestConfigMutex.RLock()
	defer fake.latestConfigMutex.RUnlock()
	return len(fake.latestConfigArgsForCall)
}

func (fake *FakeDirector) LatestConfigCalls(stub func(string, string) (director.Config, error)) {
	fake.latestConfigMutex.Lock()
	defer fake.latestConfigMutex.Unlock()
	fake.LatestConfigStub = stub
}

func (fake *FakeDirector) LatestConfigArgsForCall(i int) (string, string) {
	fake.latestConfigMutex.RLock()
	defer fake.latestConfigMutex.RUnlock()
	argsForCall := fake.latestConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) LatestConfigReturns(result1 director.Config, result2 error) {
	fake.latestConfigMutex.Lock()
	defer fake.latestConfigMutex.Unlock()
	fake.LatestConfigStub = nil
	fake.latestConfigReturns = struct {
		result1 director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestConfigReturnsOnCall(i int, result1 director.Config, result2 error) {
	fake.latestConfigMutex.Lock()
	defer fake.latestConfigMutex.Unlock()
	fake.LatestConfigStub = nil
	if fake.latestConfigReturnsOnCall == nil {
		fake.latestConfigReturnsOnCall = make(map[int]struct {
			result1 director.Config
			result2 error
		})
	}
	fake.latestConfigReturnsOnCall[i] = struct {
		result1 director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestConfigByID(arg1 string) (director.Config, error) {
	fake.latestConfigByIDMutex.Lock()
	ret, specificReturn := fake.latestConfigByIDReturnsOnCall[len(fake.latestConfigByIDArgsForCall)]
	fake.latestConfigByIDArgsForCall = append(fake.latestConfigByIDArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("LatestConfigByID", []interface{}{arg1})
	fake.latestConfigByIDMutex.Unlock()
	if fake.LatestConfigByIDStub != nil {
		return fake.LatestConfigByIDStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.latestConfigByIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) LatestConfigByIDCallCount() int {
	fake.latestConfigByIDMutex.RLock()
	defer fake.latestConfigByIDMutex.RUnlock()
	return len(fake.latestConfigByIDArgsForCall)
}

func (fake *FakeDirector) LatestConfigByIDCalls(stub func(string) (director.Config, error)) {
	fake.latestConfigByIDMutex.Lock()
	defer fake.latestConfigByIDMutex.Unlock()
	fake.LatestConfigByIDStub = stub
}

func (fake *FakeDirector) LatestConfigByIDArgsForCall(i int) string {
	fake.latestConfigByIDMutex.RLock()
	defer fake.latestConfigByIDMutex.RUnlock()
	argsForCall := fake.latestConfigByIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) LatestConfigByIDReturns(result1 director.Config, result2 error) {
	fake.latestConfigByIDMutex.Lock()
	defer fake.latestConfigByIDMutex.Unlock()
	fake.LatestConfigByIDStub = nil
	fake.latestConfigByIDReturns = struct {
		result1 director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestConfigByIDReturnsOnCall(i int, result1 director.Config, result2 error) {
	fake.latestConfigByIDMutex.Lock()
	defer fake.latestConfigByIDMutex.Unlock()
	fake.LatestConfigByIDStub = nil
	if fake.latestConfigByIDReturnsOnCall == nil {
		fake.latestConfigByIDReturnsOnCall = make(map[int]struct {
			result1 director.Config
			result2 error
		})
	}
	fake.latestConfigByIDReturnsOnCall[i] = struct {
		result1 director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestRuntimeConfig(arg1 string) (director.RuntimeConfig, error) {
	fake.latestRuntimeConfigMutex.Lock()
	ret, specificReturn := fake.latestRuntimeConfigReturnsOnCall[len(fake.latestRuntimeConfigArgsForCall)]
	fake.latestRuntimeConfigArgsForCall = append(fake.latestRuntimeConfigArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("LatestRuntimeConfig", []interface{}{arg1})
	fake.latestRuntimeConfigMutex.Unlock()
	if fake.LatestRuntimeConfigStub != nil {
		return fake.LatestRuntimeConfigStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.latestRuntimeConfigReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) LatestRuntimeConfigCallCount() int {
	fake.latestRuntimeConfigMutex.RLock()
	defer fake.latestRuntimeConfigMutex.RUnlock()
	return len(fake.latestRuntimeConfigArgsForCall)
}

func (fake *FakeDirector) LatestRuntimeConfigCalls(stub func(string) (director.RuntimeConfig, error)) {
	fake.latestRuntimeConfigMutex.Lock()
	defer fake.latestRuntimeConfigMutex.Unlock()
	fake.LatestRuntimeConfigStub = stub
}

func (fake *FakeDirector) LatestRuntimeConfigArgsForCall(i int) string {
	fake.latestRuntimeConfigMutex.RLock()
	defer fake.latestRuntimeConfigMutex.RUnlock()
	argsForCall := fake.latestRuntimeConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) LatestRuntimeConfigReturns(result1 director.RuntimeConfig, result2 error) {
	fake.latestRuntimeConfigMutex.Lock()
	defer fake.latestRuntimeConfigMutex.Unlock()
	fake.LatestRuntimeConfigStub = nil
	fake.latestRuntimeConfigReturns = struct {
		result1 director.RuntimeConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LatestRuntimeConfigReturnsOnCall(i int, result1 director.RuntimeConfig, result2 error) {
	fake.latestRuntimeConfigMutex.Lock()
	defer fake.latestRuntimeConfigMutex.Unlock()
	fake.LatestRuntimeConfigStub = nil
	if fake.latestRuntimeConfigReturnsOnCall == nil {
		fake.latestRuntimeConfigReturnsOnCall = make(map[int]struct {
			result1 director.RuntimeConfig
			result2 error
		})
	}
	fake.latestRuntimeConfigReturnsOnCall[i] = struct {
		result1 director.RuntimeConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) ListConfigs(arg1 int, arg2 director.ConfigsFilter) ([]director.Config, error) {
	fake.listConfigsMutex.Lock()
	ret, specificReturn := fake.listConfigsReturnsOnCall[len(fake.listConfigsArgsForCall)]
	fake.listConfigsArgsForCall = append(fake.listConfigsArgsForCall, struct {
		arg1 int
		arg2 director.ConfigsFilter
	}{arg1, arg2})
	fake.recordInvocation("ListConfigs", []interface{}{arg1, arg2})
	fake.listConfigsMutex.Unlock()
	if fake.ListConfigsStub != nil {
		return fake.ListConfigsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listConfigsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) ListConfigsCallCount() int {
	fake.listConfigsMutex.RLock()
	defer fake.listConfigsMutex.RUnlock()
	return len(fake.listConfigsArgsForCall)
}

func (fake *FakeDirector) ListConfigsCalls(stub func(int, director.ConfigsFilter) ([]director.Config, error)) {
	fake.listConfigsMutex.Lock()
	defer fake.listConfigsMutex.Unlock()
	fake.ListConfigsStub = stub
}

func (fake *FakeDirector) ListConfigsArgsForCall(i int) (int, director.ConfigsFilter) {
	fake.listConfigsMutex.RLock()
	defer fake.listConfigsMutex.RUnlock()
	argsForCall := fake.listConfigsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) ListConfigsReturns(result1 []director.Config, result2 error) {
	fake.listConfigsMutex.Lock()
	defer fake.listConfigsMutex.Unlock()
	fake.ListConfigsStub = nil
	fake.listConfigsReturns = struct {
		result1 []director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) ListConfigsReturnsOnCall(i int, result1 []director.Config, result2 error) {
	fake.listConfigsMutex.Lock()
	defer fake.listConfigsMutex.Unlock()
	fake.ListConfigsStub = nil
	if fake.listConfigsReturnsOnCall == nil {
		fake.listConfigsReturnsOnCall = make(map[int]struct {
			result1 []director.Config
			result2 error
		})
	}
	fake.listConfigsReturnsOnCall[i] = struct {
		result1 []director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) ListDeploymentConfigs(arg1 string) (director.DeploymentConfigs, error) {
	fake.listDeploymentConfigsMutex.Lock()
	ret, specificReturn := fake.listDeploymentConfigsReturnsOnCall[len(fake.listDeploymentConfigsArgsForCall)]
	fake.listDeploymentConfigsArgsForCall = append(fake.listDeploymentConfigsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ListDeploymentConfigs", []interface{}{arg1})
	fake.listDeploymentConfigsMutex.Unlock()
	if fake.ListDeploymentConfigsStub != nil {
		return fake.ListDeploymentConfigsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listDeploymentConfigsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) ListDeploymentConfigsCallCount() int {
	fake.listDeploymentConfigsMutex.RLock()
	defer fake.listDeploymentConfigsMutex.RUnlock()
	return len(fake.listDeploymentConfigsArgsForCall)
}

func (fake *FakeDirector) ListDeploymentConfigsCalls(stub func(string) (director.DeploymentConfigs, error)) {
	fake.listDeploymentConfigsMutex.Lock()
	defer fake.listDeploymentConfigsMutex.Unlock()
	fake.ListDeploymentConfigsStub = stub
}

func (fake *FakeDirector) ListDeploymentConfigsArgsForCall(i int) string {
	fake.listDeploymentConfigsMutex.RLock()
	defer fake.listDeploymentConfigsMutex.RUnlock()
	argsForCall := fake.listDeploymentConfigsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) ListDeploymentConfigsReturns(result1 director.DeploymentConfigs, result2 error) {
	fake.listDeploymentConfigsMutex.Lock()
	defer fake.listDeploymentConfigsMutex.Unlock()
	fake.ListDeploymentConfigsStub = nil
	fake.listDeploymentConfigsReturns = struct {
		result1 director.DeploymentConfigs
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) ListDeploymentConfigsReturnsOnCall(i int, result1 director.DeploymentConfigs, result2 error) {
	fake.listDeploymentConfigsMutex.Lock()
	defer fake.listDeploymentConfigsMutex.Unlock()
	fake.ListDeploymentConfigsStub = nil
	if fake.listDeploymentConfigsReturnsOnCall == nil {
		fake.listDeploymentConfigsReturnsOnCall = make(map[int]struct {
			result1 director.DeploymentConfigs
			result2 error
		})
	}
	fake.listDeploymentConfigsReturnsOnCall[i] = struct {
		result1 director.DeploymentConfigs
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) ListDeployments() ([]director.DeploymentResp, error) {
	fake.listDeploymentsMutex.Lock()
	ret, specificReturn := fake.listDeploymentsReturnsOnCall[len(fake.listDeploymentsArgsForCall)]
	fake.listDeploymentsArgsForCall = append(fake.listDeploymentsArgsForCall, struct {
	}{})
	fake.recordInvocation("ListDeployments", []interface{}{})
	fake.listDeploymentsMutex.Unlock()
	if fake.ListDeploymentsStub != nil {
		return fake.ListDeploymentsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listDeploymentsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) ListDeploymentsCallCount() int {
	fake.listDeploymentsMutex.RLock()
	defer fake.listDeploymentsMutex.RUnlock()
	return len(fake.listDeploymentsArgsForCall)
}

func (fake *FakeDirector) ListDeploymentsCalls(stub func() ([]director.DeploymentResp, error)) {
	fake.listDeploymentsMutex.Lock()
	defer fake.listDeploymentsMutex.Unlock()
	fake.ListDeploymentsStub = stub
}

func (fake *FakeDirector) ListDeploymentsReturns(result1 []director.DeploymentResp, result2 error) {
	fake.listDeploymentsMutex.Lock()
	defer fake.listDeploymentsMutex.Unlock()
	fake.ListDeploymentsStub = nil
	fake.listDeploymentsReturns = struct {
		result1 []director.DeploymentResp
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) ListDeploymentsReturnsOnCall(i int, result1 []director.DeploymentResp, result2 error) {
	fake.listDeploymentsMutex.Lock()
	defer fake.listDeploymentsMutex.Unlock()
	fake.ListDeploymentsStub = nil
	if fake.listDeploymentsReturnsOnCall == nil {
		fake.listDeploymentsReturnsOnCall = make(map[int]struct {
			result1 []director.DeploymentResp
			result2 error
		})
	}
	fake.listDeploymentsReturnsOnCall[i] = struct {
		result1 []director.DeploymentResp
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Locks() ([]director.Lock, error) {
	fake.locksMutex.Lock()
	ret, specificReturn := fake.locksReturnsOnCall[len(fake.locksArgsForCall)]
	fake.locksArgsForCall = append(fake.locksArgsForCall, struct {
	}{})
	fake.recordInvocation("Locks", []interface{}{})
	fake.locksMutex.Unlock()
	if fake.LocksStub != nil {
		return fake.LocksStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.locksReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) LocksCallCount() int {
	fake.locksMutex.RLock()
	defer fake.locksMutex.RUnlock()
	return len(fake.locksArgsForCall)
}

func (fake *FakeDirector) LocksCalls(stub func() ([]director.Lock, error)) {
	fake.locksMutex.Lock()
	defer fake.locksMutex.Unlock()
	fake.LocksStub = stub
}

func (fake *FakeDirector) LocksReturns(result1 []director.Lock, result2 error) {
	fake.locksMutex.Lock()
	defer fake.locksMutex.Unlock()
	fake.LocksStub = nil
	fake.locksReturns = struct {
		result1 []director.Lock
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) LocksReturnsOnCall(i int, result1 []director.Lock, result2 error) {
	fake.locksMutex.Lock()
	defer fake.locksMutex.Unlock()
	fake.LocksStub = nil
	if fake.locksReturnsOnCall == nil {
		fake.locksReturnsOnCall = make(map[int]struct {
			result1 []director.Lock
			result2 error
		})
	}
	fake.locksReturnsOnCall[i] = struct {
		result1 []director.Lock
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) MatchPackages(arg1 interface{}, arg2 bool) ([]string, error) {
	fake.matchPackagesMutex.Lock()
	ret, specificReturn := fake.matchPackagesReturnsOnCall[len(fake.matchPackagesArgsForCall)]
	fake.matchPackagesArgsForCall = append(fake.matchPackagesArgsForCall, struct {
		arg1 interface{}
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("MatchPackages", []interface{}{arg1, arg2})
	fake.matchPackagesMutex.Unlock()
	if fake.MatchPackagesStub != nil {
		return fake.MatchPackagesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.matchPackagesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) MatchPackagesCallCount() int {
	fake.matchPackagesMutex.RLock()
	defer fake.matchPackagesMutex.RUnlock()
	return len(fake.matchPackagesArgsForCall)
}

func (fake *FakeDirector) MatchPackagesCalls(stub func(interface{}, bool) ([]string, error)) {
	fake.matchPackagesMutex.Lock()
	defer fake.matchPackagesMutex.Unlock()
	fake.MatchPackagesStub = stub
}

func (fake *FakeDirector) MatchPackagesArgsForCall(i int) (interface{}, bool) {
	fake.matchPackagesMutex.RLock()
	defer fake.matchPackagesMutex.RUnlock()
	argsForCall := fake.matchPackagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) MatchPackagesReturns(result1 []string, result2 error) {
	fake.matchPackagesMutex.Lock()
	defer fake.matchPackagesMutex.Unlock()
	fake.MatchPackagesStub = nil
	fake.matchPackagesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) MatchPackagesReturnsOnCall(i int, result1 []string, result2 error) {
	fake.matchPackagesMutex.Lock()
	defer fake.matchPackagesMutex.Unlock()
	fake.MatchPackagesStub = nil
	if fake.matchPackagesReturnsOnCall == nil {
		fake.matchPackagesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.matchPackagesReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) OrphanDisk(arg1 string) error {
	fake.orphanDiskMutex.Lock()
	ret, specificReturn := fake.orphanDiskReturnsOnCall[len(fake.orphanDiskArgsForCall)]
	fake.orphanDiskArgsForCall = append(fake.orphanDiskArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("OrphanDisk", []interface{}{arg1})
	fake.orphanDiskMutex.Unlock()
	if fake.OrphanDiskStub != nil {
		return fake.OrphanDiskStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.orphanDiskReturns
	return fakeReturns.result1
}

func (fake *FakeDirector) OrphanDiskCallCount() int {
	fake.orphanDiskMutex.RLock()
	defer fake.orphanDiskMutex.RUnlock()
	return len(fake.orphanDiskArgsForCall)
}

func (fake *FakeDirector) OrphanDiskCalls(stub func(string) error) {
	fake.orphanDiskMutex.Lock()
	defer fake.orphanDiskMutex.Unlock()
	fake.OrphanDiskStub = stub
}

func (fake *FakeDirector) OrphanDiskArgsForCall(i int) string {
	fake.orphanDiskMutex.RLock()
	defer fake.orphanDiskMutex.RUnlock()
	argsForCall := fake.orphanDiskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) OrphanDiskReturns(result1 error) {
	fake.orphanDiskMutex.Lock()
	defer fake.orphanDiskMutex.Unlock()
	fake.OrphanDiskStub = nil
	fake.orphanDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) OrphanDiskReturnsOnCall(i int, result1 error) {
	fake.orphanDiskMutex.Lock()
	defer fake.orphanDiskMutex.Unlock()
	fake.OrphanDiskStub = nil
	if fake.orphanDiskReturnsOnCall == nil {
		fake.orphanDiskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.orphanDiskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) OrphanDisks() ([]director.OrphanDisk, error) {
	fake.orphanDisksMutex.Lock()
	ret, specificReturn := fake.orphanDisksReturnsOnCall[len(fake.orphanDisksArgsForCall)]
	fake.orphanDisksArgsForCall = append(fake.orphanDisksArgsForCall, struct {
	}{})
	fake.recordInvocation("OrphanDisks", []interface{}{})
	fake.orphanDisksMutex.Unlock()
	if fake.OrphanDisksStub != nil {
		return fake.OrphanDisksStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.orphanDisksReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) OrphanDisksCallCount() int {
	fake.orphanDisksMutex.RLock()
	defer fake.orphanDisksMutex.RUnlock()
	return len(fake.orphanDisksArgsForCall)
}

func (fake *FakeDirector) OrphanDisksCalls(stub func() ([]director.OrphanDisk, error)) {
	fake.orphanDisksMutex.Lock()
	defer fake.orphanDisksMutex.Unlock()
	fake.OrphanDisksStub = stub
}

func (fake *FakeDirector) OrphanDisksReturns(result1 []director.OrphanDisk, result2 error) {
	fake.orphanDisksMutex.Lock()
	defer fake.orphanDisksMutex.Unlock()
	fake.OrphanDisksStub = nil
	fake.orphanDisksReturns = struct {
		result1 []director.OrphanDisk
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) OrphanDisksReturnsOnCall(i int, result1 []director.OrphanDisk, result2 error) {
	fake.orphanDisksMutex.Lock()
	defer fake.orphanDisksMutex.Unlock()
	fake.OrphanDisksStub = nil
	if fake.orphanDisksReturnsOnCall == nil {
		fake.orphanDisksReturnsOnCall = make(map[int]struct {
			result1 []director.OrphanDisk
			result2 error
		})
	}
	fake.orphanDisksReturnsOnCall[i] = struct {
		result1 []director.OrphanDisk
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) OrphanNetworks() ([]director.OrphanNetwork, error) {
	fake.orphanNetworksMutex.Lock()
	ret, specificReturn := fake.orphanNetworksReturnsOnCall[len(fake.orphanNetworksArgsForCall)]
	fake.orphanNetworksArgsForCall = append(fake.orphanNetworksArgsForCall, struct {
	}{})
	fake.recordInvocation("OrphanNetworks", []interface{}{})
	fake.orphanNetworksMutex.Unlock()
	if fake.OrphanNetworksStub != nil {
		return fake.OrphanNetworksStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.orphanNetworksReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) OrphanNetworksCallCount() int {
	fake.orphanNetworksMutex.RLock()
	defer fake.orphanNetworksMutex.RUnlock()
	return len(fake.orphanNetworksArgsForCall)
}

func (fake *FakeDirector) OrphanNetworksCalls(stub func() ([]director.OrphanNetwork, error)) {
	fake.orphanNetworksMutex.Lock()
	defer fake.orphanNetworksMutex.Unlock()
	fake.OrphanNetworksStub = stub
}

func (fake *FakeDirector) OrphanNetworksReturns(result1 []director.OrphanNetwork, result2 error) {
	fake.orphanNetworksMutex.Lock()
	defer fake.orphanNetworksMutex.Unlock()
	fake.OrphanNetworksStub = nil
	fake.orphanNetworksReturns = struct {
		result1 []director.OrphanNetwork
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) OrphanNetworksReturnsOnCall(i int, result1 []director.OrphanNetwork, result2 error) {
	fake.orphanNetworksMutex.Lock()
	defer fake.orphanNetworksMutex.Unlock()
	fake.OrphanNetworksStub = nil
	if fake.orphanNetworksReturnsOnCall == nil {
		fake.orphanNetworksReturnsOnCall = make(map[int]struct {
			result1 []director.OrphanNetwork
			result2 error
		})
	}
	fake.orphanNetworksReturnsOnCall[i] = struct {
		result1 []director.OrphanNetwork
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) OrphanedVMs() ([]director.OrphanedVM, error) {
	fake.orphanedVMsMutex.Lock()
	ret, specificReturn := fake.orphanedVMsReturnsOnCall[len(fake.orphanedVMsArgsForCall)]
	fake.orphanedVMsArgsForCall = append(fake.orphanedVMsArgsForCall, struct {
	}{})
	fake.recordInvocation("OrphanedVMs", []interface{}{})
	fake.orphanedVMsMutex.Unlock()
	if fake.OrphanedVMsStub != nil {
		return fake.OrphanedVMsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.orphanedVMsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) OrphanedVMsCallCount() int {
	fake.orphanedVMsMutex.RLock()
	defer fake.orphanedVMsMutex.RUnlock()
	return len(fake.orphanedVMsArgsForCall)
}

func (fake *FakeDirector) OrphanedVMsCalls(stub func() ([]director.OrphanedVM, error)) {
	fake.orphanedVMsMutex.Lock()
	defer fake.orphanedVMsMutex.Unlock()
	fake.OrphanedVMsStub = stub
}

func (fake *FakeDirector) OrphanedVMsReturns(result1 []director.OrphanedVM, result2 error) {
	fake.orphanedVMsMutex.Lock()
	defer fake.orphanedVMsMutex.Unlock()
	fake.OrphanedVMsStub = nil
	fake.orphanedVMsReturns = struct {
		result1 []director.OrphanedVM
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) OrphanedVMsReturnsOnCall(i int, result1 []director.OrphanedVM, result2 error) {
	fake.orphanedVMsMutex.Lock()
	defer fake.orphanedVMsMutex.Unlock()
	fake.OrphanedVMsStub = nil
	if fake.orphanedVMsReturnsOnCall == nil {
		fake.orphanedVMsReturnsOnCall = make(map[int]struct {
			result1 []director.OrphanedVM
			result2 error
		})
	}
	fake.orphanedVMsReturnsOnCall[i] = struct {
		result1 []director.OrphanedVM
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) RecentTasks(arg1 int, arg2 director.TasksFilter) ([]director.Task, error) {
	fake.recentTasksMutex.Lock()
	ret, specificReturn := fake.recentTasksReturnsOnCall[len(fake.recentTasksArgsForCall)]
	fake.recentTasksArgsForCall = append(fake.recentTasksArgsForCall, struct {
		arg1 int
		arg2 director.TasksFilter
	}{arg1, arg2})
	fake.recordInvocation("RecentTasks", []interface{}{arg1, arg2})
	fake.recentTasksMutex.Unlock()
	if fake.RecentTasksStub != nil {
		return fake.RecentTasksStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.recentTasksReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) RecentTasksCallCount() int {
	fake.recentTasksMutex.RLock()
	defer fake.recentTasksMutex.RUnlock()
	return len(fake.recentTasksArgsForCall)
}

func (fake *FakeDirector) RecentTasksCalls(stub func(int, director.TasksFilter) ([]director.Task, error)) {
	fake.recentTasksMutex.Lock()
	defer fake.recentTasksMutex.Unlock()
	fake.RecentTasksStub = stub
}

func (fake *FakeDirector) RecentTasksArgsForCall(i int) (int, director.TasksFilter) {
	fake.recentTasksMutex.RLock()
	defer fake.recentTasksMutex.RUnlock()
	argsForCall := fake.recentTasksArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) RecentTasksReturns(result1 []director.Task, result2 error) {
	fake.recentTasksMutex.Lock()
	defer fake.recentTasksMutex.Unlock()
	fake.RecentTasksStub = nil
	fake.recentTasksReturns = struct {
		result1 []director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) RecentTasksReturnsOnCall(i int, result1 []director.Task, result2 error) {
	fake.recentTasksMutex.Lock()
	defer fake.recentTasksMutex.Unlock()
	fake.RecentTasksStub = nil
	if fake.recentTasksReturnsOnCall == nil {
		fake.recentTasksReturnsOnCall = make(map[int]struct {
			result1 []director.Task
			result2 error
		})
	}
	fake.recentTasksReturnsOnCall[i] = struct {
		result1 []director.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) Releases() ([]director.Release, error) {
	fake.releasesMutex.Lock()
	ret, specificReturn := fake.releasesReturnsOnCall[len(fake.releasesArgsForCall)]
	fake.releasesArgsForCall = append(fake.releasesArgsForCall, struct {
	}{})
	fake.recordInvocation("Releases", []interface{}{})
	fake.releasesMutex.Unlock()
	if fake.ReleasesStub != nil {
		return fake.ReleasesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.releasesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) ReleasesCallCount() int {
	fake.releasesMutex.RLock()
	defer fake.releasesMutex.RUnlock()
	return len(fake.releasesArgsForCall)
}

func (fake *FakeDirector) ReleasesCalls(stub func() ([]director.Release, error)) {
	fake.releasesMutex.Lock()
	defer fake.releasesMutex.Unlock()
	fake.ReleasesStub = stub
}

func (fake *FakeDirector) ReleasesReturns(result1 []director.Release, result2 error) {
	fake.releasesMutex.Lock()
	defer fake.releasesMutex.Unlock()
	fake.ReleasesStub = nil
	fake.releasesReturns = struct {
		result1 []director.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) ReleasesReturnsOnCall(i int, result1 []director.Release, result2 error) {
	fake.releasesMutex.Lock()
	defer fake.releasesMutex.Unlock()
	fake.ReleasesStub = nil
	if fake.releasesReturnsOnCall == nil {
		fake.releasesReturnsOnCall = make(map[int]struct {
			result1 []director.Release
			result2 error
		})
	}
	fake.releasesReturnsOnCall[i] = struct {
		result1 []director.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) StemcellNeedsUpload(arg1 director.StemcellInfo) (bool, bool, error) {
	fake.stemcellNeedsUploadMutex.Lock()
	ret, specificReturn := fake.stemcellNeedsUploadReturnsOnCall[len(fake.stemcellNeedsUploadArgsForCall)]
	fake.stemcellNeedsUploadArgsForCall = append(fake.stemcellNeedsUploadArgsForCall, struct {
		arg1 director.StemcellInfo
	}{arg1})
	fake.recordInvocation("StemcellNeedsUpload", []interface{}{arg1})
	fake.stemcellNeedsUploadMutex.Unlock()
	if fake.StemcellNeedsUploadStub != nil {
		return fake.StemcellNeedsUploadStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.stemcellNeedsUploadReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeDirector) StemcellNeedsUploadCallCount() int {
	fake.stemcellNeedsUploadMutex.RLock()
	defer fake.stemcellNeedsUploadMutex.RUnlock()
	return len(fake.stemcellNeedsUploadArgsForCall)
}

func (fake *FakeDirector) StemcellNeedsUploadCalls(stub func(director.StemcellInfo) (bool, bool, error)) {
	fake.stemcellNeedsUploadMutex.Lock()
	defer fake.stemcellNeedsUploadMutex.Unlock()
	fake.StemcellNeedsUploadStub = stub
}

func (fake *FakeDirector) StemcellNeedsUploadArgsForCall(i int) director.StemcellInfo {
	fake.stemcellNeedsUploadMutex.RLock()
	defer fake.stemcellNeedsUploadMutex.RUnlock()
	argsForCall := fake.stemcellNeedsUploadArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) StemcellNeedsUploadReturns(result1 bool, result2 bool, result3 error) {
	fake.stemcellNeedsUploadMutex.Lock()
	defer fake.stemcellNeedsUploadMutex.Unlock()
	fake.StemcellNeedsUploadStub = nil
	fake.stemcellNeedsUploadReturns = struct {
		result1 bool
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDirector) StemcellNeedsUploadReturnsOnCall(i int, result1 bool, result2 bool, result3 error) {
	fake.stemcellNeedsUploadMutex.Lock()
	defer fake.stemcellNeedsUploadMutex.Unlock()
	fake.StemcellNeedsUploadStub = nil
	if fake.stemcellNeedsUploadReturnsOnCall == nil {
		fake.stemcellNeedsUploadReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 bool
			result3 error
		})
	}
	fake.stemcellNeedsUploadReturnsOnCall[i] = struct {
		result1 bool
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDirector) Stemcells() ([]director.Stemcell, error) {
	fake.stemcellsMutex.Lock()
	ret, specificReturn := fake.stemcellsReturnsOnCall[len(fake.stemcellsArgsForCall)]
	fake.stemcellsArgsForCall = append(fake.stemcellsArgsForCall, struct {
	}{})
	fake.recordInvocation("Stemcells", []interface{}{})
	fake.stemcellsMutex.Unlock()
	if fake.StemcellsStub != nil {
		return fake.StemcellsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.stemcellsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) StemcellsCallCount() int {
	fake.stemcellsMutex.RLock()
	defer fake.stemcellsMutex.RUnlock()
	return len(fake.stemcellsArgsForCall)
}

func (fake *FakeDirector) StemcellsCalls(stub func() ([]director.Stemcell, error)) {
	fake.stemcellsMutex.Lock()
	defer fake.stemcellsMutex.Unlock()
	fake.StemcellsStub = stub
}

func (fake *FakeDirector) StemcellsReturns(result1 []director.Stemcell, result2 error) {
	fake.stemcellsMutex.Lock()
	defer fake.stemcellsMutex.Unlock()
	fake.StemcellsStub = nil
	fake.stemcellsReturns = struct {
		result1 []director.Stemcell
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) StemcellsReturnsOnCall(i int, result1 []director.Stemcell, result2 error) {
	fake.stemcellsMutex.Lock()
	defer fake.stemcellsMutex.Unlock()
	fake.StemcellsStub = nil
	if fake.stemcellsReturnsOnCall == nil {
		fake.stemcellsReturnsOnCall = make(map[int]struct {
			result1 []director.Stemcell
			result2 error
		})
	}
	fake.stemcellsReturnsOnCall[i] = struct {
		result1 []director.Stemcell
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) UpdateCPIConfig(arg1 []byte) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.updateCPIConfigMutex.Lock()
	ret, specificReturn := fake.updateCPIConfigReturnsOnCall[len(fake.updateCPIConfigArgsForCall)]
	fake.updateCPIConfigArgsForCall = append(fake.updateCPIConfigArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	fake.recordInvocation("UpdateCPIConfig", []interface{}{arg1Copy})
	fake.updateCPIConfigMutex.Unlock()
	if fake.UpdateCPIConfigStub != nil {
		return fake.UpdateCPIConfigStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateCPIConfigReturns
	return fakeReturns.result1
}

func (fake *FakeDirector) UpdateCPIConfigCallCount() int {
	fake.updateCPIConfigMutex.RLock()
	defer fake.updateCPIConfigMutex.RUnlock()
	return len(fake.updateCPIConfigArgsForCall)
}

func (fake *FakeDirector) UpdateCPIConfigCalls(stub func([]byte) error) {
	fake.updateCPIConfigMutex.Lock()
	defer fake.updateCPIConfigMutex.Unlock()
	fake.UpdateCPIConfigStub = stub
}

func (fake *FakeDirector) UpdateCPIConfigArgsForCall(i int) []byte {
	fake.updateCPIConfigMutex.RLock()
	defer fake.updateCPIConfigMutex.RUnlock()
	argsForCall := fake.updateCPIConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) UpdateCPIConfigReturns(result1 error) {
	fake.updateCPIConfigMutex.Lock()
	defer fake.updateCPIConfigMutex.Unlock()
	fake.UpdateCPIConfigStub = nil
	fake.updateCPIConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UpdateCPIConfigReturnsOnCall(i int, result1 error) {
	fake.updateCPIConfigMutex.Lock()
	defer fake.updateCPIConfigMutex.Unlock()
	fake.UpdateCPIConfigStub = nil
	if fake.updateCPIConfigReturnsOnCall == nil {
		fake.updateCPIConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateCPIConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UpdateCloudConfig(arg1 []byte) error {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.updateCloudConfigMutex.Lock()
	ret, specificReturn := fake.updateCloudConfigReturnsOnCall[len(fake.updateCloudConfigArgsForCall)]
	fake.updateCloudConfigArgsForCall = append(fake.updateCloudConfigArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	fake.recordInvocation("UpdateCloudConfig", []interface{}{arg1Copy})
	fake.updateCloudConfigMutex.Unlock()
	if fake.UpdateCloudConfigStub != nil {
		return fake.UpdateCloudConfigStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateCloudConfigReturns
	return fakeReturns.result1
}

func (fake *FakeDirector) UpdateCloudConfigCallCount() int {
	fake.updateCloudConfigMutex.RLock()
	defer fake.updateCloudConfigMutex.RUnlock()
	return len(fake.updateCloudConfigArgsForCall)
}

func (fake *FakeDirector) UpdateCloudConfigCalls(stub func([]byte) error) {
	fake.updateCloudConfigMutex.Lock()
	defer fake.updateCloudConfigMutex.Unlock()
	fake.UpdateCloudConfigStub = stub
}

func (fake *FakeDirector) UpdateCloudConfigArgsForCall(i int) []byte {
	fake.updateCloudConfigMutex.RLock()
	defer fake.updateCloudConfigMutex.RUnlock()
	argsForCall := fake.updateCloudConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) UpdateCloudConfigReturns(result1 error) {
	fake.updateCloudConfigMutex.Lock()
	defer fake.updateCloudConfigMutex.Unlock()
	fake.UpdateCloudConfigStub = nil
	fake.updateCloudConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UpdateCloudConfigReturnsOnCall(i int, result1 error) {
	fake.updateCloudConfigMutex.Lock()
	defer fake.updateCloudConfigMutex.Unlock()
	fake.UpdateCloudConfigStub = nil
	if fake.updateCloudConfigReturnsOnCall == nil {
		fake.updateCloudConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateCloudConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UpdateConfig(arg1 string, arg2 string, arg3 string, arg4 []byte) (director.Config, error) {
	var arg4Copy []byte
	if arg4 != nil {
		arg4Copy = make([]byte, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.updateConfigMutex.Lock()
	ret, specificReturn := fake.updateConfigReturnsOnCall[len(fake.updateConfigArgsForCall)]
	fake.updateConfigArgsForCall = append(fake.updateConfigArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 []byte
	}{arg1, arg2, arg3, arg4Copy})
	fake.recordInvocation("UpdateConfig", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.updateConfigMutex.Unlock()
	if fake.UpdateConfigStub != nil {
		return fake.UpdateConfigStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateConfigReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDirector) UpdateConfigCallCount() int {
	fake.updateConfigMutex.RLock()
	defer fake.updateConfigMutex.RUnlock()
	return len(fake.updateConfigArgsForCall)
}

func (fake *FakeDirector) UpdateConfigCalls(stub func(string, string, string, []byte) (director.Config, error)) {
	fake.updateConfigMutex.Lock()
	defer fake.updateConfigMutex.Unlock()
	fake.UpdateConfigStub = stub
}

func (fake *FakeDirector) UpdateConfigArgsForCall(i int) (string, string, string, []byte) {
	fake.updateConfigMutex.RLock()
	defer fake.updateConfigMutex.RUnlock()
	argsForCall := fake.updateConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeDirector) UpdateConfigReturns(result1 director.Config, result2 error) {
	fake.updateConfigMutex.Lock()
	defer fake.updateConfigMutex.Unlock()
	fake.UpdateConfigStub = nil
	fake.updateConfigReturns = struct {
		result1 director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) UpdateConfigReturnsOnCall(i int, result1 director.Config, result2 error) {
	fake.updateConfigMutex.Lock()
	defer fake.updateConfigMutex.Unlock()
	fake.UpdateConfigStub = nil
	if fake.updateConfigReturnsOnCall == nil {
		fake.updateConfigReturnsOnCall = make(map[int]struct {
			result1 director.Config
			result2 error
		})
	}
	fake.updateConfigReturnsOnCall[i] = struct {
		result1 director.Config
		result2 error
	}{result1, result2}
}

func (fake *FakeDirector) UpdateRuntimeConfig(arg1 string, arg2 []byte) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.updateRuntimeConfigMutex.Lock()
	ret, specificReturn := fake.updateRuntimeConfigReturnsOnCall[len(fake.updateRuntimeConfigArgsForCall)]
	fake.updateRuntimeConfigArgsForCall = append(fake.updateRuntimeConfigArgsForCall, struct {
		arg1 string
		arg2 []byte
	}{arg1, arg2Copy})
	fake.recordInvocation("UpdateRuntimeConfig", []interface{}{arg1, arg2Copy})
	fake.updateRuntimeConfigMutex.Unlock()
	if fake.UpdateRuntimeConfigStub != nil {
		return fake.UpdateRuntimeConfigStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateRuntimeConfigReturns
	return fakeReturns.result1
}

func (fake *FakeDirector) UpdateRuntimeConfigCallCount() int {
	fake.updateRuntimeConfigMutex.RLock()
	defer fake.updateRuntimeConfigMutex.RUnlock()
	return len(fake.updateRuntimeConfigArgsForCall)
}

func (fake *FakeDirector) UpdateRuntimeConfigCalls(stub func(string, []byte) error) {
	fake.updateRuntimeConfigMutex.Lock()
	defer fake.updateRuntimeConfigMutex.Unlock()
	fake.UpdateRuntimeConfigStub = stub
}

func (fake *FakeDirector) UpdateRuntimeConfigArgsForCall(i int) (string, []byte) {
	fake.updateRuntimeConfigMutex.RLock()
	defer fake.updateRuntimeConfigMutex.RUnlock()
	argsForCall := fake.updateRuntimeConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) UpdateRuntimeConfigReturns(result1 error) {
	fake.updateRuntimeConfigMutex.Lock()
	defer fake.updateRuntimeConfigMutex.Unlock()
	fake.UpdateRuntimeConfigStub = nil
	fake.updateRuntimeConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UpdateRuntimeConfigReturnsOnCall(i int, result1 error) {
	fake.updateRuntimeConfigMutex.Lock()
	defer fake.updateRuntimeConfigMutex.Unlock()
	fake.UpdateRuntimeConfigStub = nil
	if fake.updateRuntimeConfigReturnsOnCall == nil {
		fake.updateRuntimeConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateRuntimeConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadReleaseFile(arg1 director.UploadFile, arg2 bool, arg3 bool) error {
	fake.uploadReleaseFileMutex.Lock()
	ret, specificReturn := fake.uploadReleaseFileReturnsOnCall[len(fake.uploadReleaseFileArgsForCall)]
	fake.uploadReleaseFileArgsForCall = append(fake.uploadReleaseFileArgsForCall, struct {
		arg1 director.UploadFile
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	fake.recordInvocation("UploadReleaseFile", []interface{}{arg1, arg2, arg3})
	fake.uploadReleaseFileMutex.Unlock()
	if fake.UploadReleaseFileStub != nil {
		return fake.UploadReleaseFileStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uploadReleaseFileReturns
	return fakeReturns.result1
}

func (fake *FakeDirector) UploadReleaseFileCallCount() int {
	fake.uploadReleaseFileMutex.RLock()
	defer fake.uploadReleaseFileMutex.RUnlock()
	return len(fake.uploadReleaseFileArgsForCall)
}

func (fake *FakeDirector) UploadReleaseFileCalls(stub func(director.UploadFile, bool, bool) error) {
	fake.uploadReleaseFileMutex.Lock()
	defer fake.uploadReleaseFileMutex.Unlock()
	fake.UploadReleaseFileStub = stub
}

func (fake *FakeDirector) UploadReleaseFileArgsForCall(i int) (director.UploadFile, bool, bool) {
	fake.uploadReleaseFileMutex.RLock()
	defer fake.uploadReleaseFileMutex.RUnlock()
	argsForCall := fake.uploadReleaseFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDirector) UploadReleaseFileReturns(result1 error) {
	fake.uploadReleaseFileMutex.Lock()
	defer fake.uploadReleaseFileMutex.Unlock()
	fake.UploadReleaseFileStub = nil
	fake.uploadReleaseFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadReleaseFileReturnsOnCall(i int, result1 error) {
	fake.uploadReleaseFileMutex.Lock()
	defer fake.uploadReleaseFileMutex.Unlock()
	fake.UploadReleaseFileStub = nil
	if fake.uploadReleaseFileReturnsOnCall == nil {
		fake.uploadReleaseFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadReleaseFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadReleaseURL(arg1 string, arg2 string, arg3 bool, arg4 bool) error {
	fake.uploadReleaseURLMutex.Lock()
	ret, specificReturn := fake.uploadReleaseURLReturnsOnCall[len(fake.uploadReleaseURLArgsForCall)]
	fake.uploadReleaseURLArgsForCall = append(fake.uploadReleaseURLArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 bool
		arg4 bool
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("UploadReleaseURL", []interface{}{arg1, arg2, arg3, arg4})
	fake.uploadReleaseURLMutex.Unlock()
	if fake.UploadReleaseURLStub != nil {
		return fake.UploadReleaseURLStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uploadReleaseURLReturns
	return fakeReturns.result1
}

func (fake *FakeDirector) UploadReleaseURLCallCount() int {
	fake.uploadReleaseURLMutex.RLock()
	defer fake.uploadReleaseURLMutex.RUnlock()
	return len(fake.uploadReleaseURLArgsForCall)
}

func (fake *FakeDirector) UploadReleaseURLCalls(stub func(string, string, bool, bool) error) {
	fake.uploadReleaseURLMutex.Lock()
	defer fake.uploadReleaseURLMutex.Unlock()
	fake.UploadReleaseURLStub = stub
}

func (fake *FakeDirector) UploadReleaseURLArgsForCall(i int) (string, string, bool, bool) {
	fake.uploadReleaseURLMutex.RLock()
	defer fake.uploadReleaseURLMutex.RUnlock()
	argsForCall := fake.uploadReleaseURLArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeDirector) UploadReleaseURLReturns(result1 error) {
	fake.uploadReleaseURLMutex.Lock()
	defer fake.uploadReleaseURLMutex.Unlock()
	fake.UploadReleaseURLStub = nil
	fake.uploadReleaseURLReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadReleaseURLReturnsOnCall(i int, result1 error) {
	fake.uploadReleaseURLMutex.Lock()
	defer fake.uploadReleaseURLMutex.Unlock()
	fake.UploadReleaseURLStub = nil
	if fake.uploadReleaseURLReturnsOnCall == nil {
		fake.uploadReleaseURLReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadReleaseURLReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadStemcellFile(arg1 director.UploadFile, arg2 bool) error {
	fake.uploadStemcellFileMutex.Lock()
	ret, specificReturn := fake.uploadStemcellFileReturnsOnCall[len(fake.uploadStemcellFileArgsForCall)]
	fake.uploadStemcellFileArgsForCall = append(fake.uploadStemcellFileArgsForCall, struct {
		arg1 director.UploadFile
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("UploadStemcellFile", []interface{}{arg1, arg2})
	fake.uploadStemcellFileMutex.Unlock()
	if fake.UploadStemcellFileStub != nil {
		return fake.UploadStemcellFileStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uploadStemcellFileReturns
	return fakeReturns.result1
}

func (fake *FakeDirector) UploadStemcellFileCallCount() int {
	fake.uploadStemcellFileMutex.RLock()
	defer fake.uploadStemcellFileMutex.RUnlock()
	return len(fake.uploadStemcellFileArgsForCall)
}

func (fake *FakeDirector) UploadStemcellFileCalls(stub func(director.UploadFile, bool) error) {
	fake.uploadStemcellFileMutex.Lock()
	defer fake.uploadStemcellFileMutex.Unlock()
	fake.UploadStemcellFileStub = stub
}

func (fake *FakeDirector) UploadStemcellFileArgsForCall(i int) (director.UploadFile, bool) {
	fake.uploadStemcellFileMutex.RLock()
	defer fake.uploadStemcellFileMutex.RUnlock()
	argsForCall := fake.uploadStemcellFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDirector) UploadStemcellFileReturns(result1 error) {
	fake.uploadStemcellFileMutex.Lock()
	defer fake.uploadStemcellFileMutex.Unlock()
	fake.UploadStemcellFileStub = nil
	fake.uploadStemcellFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadStemcellFileReturnsOnCall(i int, result1 error) {
	fake.uploadStemcellFileMutex.Lock()
	defer fake.uploadStemcellFileMutex.Unlock()
	fake.UploadStemcellFileStub = nil
	if fake.uploadStemcellFileReturnsOnCall == nil {
		fake.uploadStemcellFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadStemcellFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadStemcellURL(arg1 string, arg2 string, arg3 bool) error {
	fake.uploadStemcellURLMutex.Lock()
	ret, specificReturn := fake.uploadStemcellURLReturnsOnCall[len(fake.uploadStemcellURLArgsForCall)]
	fake.uploadStemcellURLArgsForCall = append(fake.uploadStemcellURLArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 bool
	}{arg1, arg2, arg3})
	fake.recordInvocation("UploadStemcellURL", []interface{}{arg1, arg2, arg3})
	fake.uploadStemcellURLMutex.Unlock()
	if fake.UploadStemcellURLStub != nil {
		return fake.UploadStemcellURLStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uploadStemcellURLReturns
	return fakeReturns.result1
}

func (fake *FakeDirector) UploadStemcellURLCallCount() int {
	fake.uploadStemcellURLMutex.RLock()
	defer fake.uploadStemcellURLMutex.RUnlock()
	return len(fake.uploadStemcellURLArgsForCall)
}

func (fake *FakeDirector) UploadStemcellURLCalls(stub func(string, string, bool) error) {
	fake.uploadStemcellURLMutex.Lock()
	defer fake.uploadStemcellURLMutex.Unlock()
	fake.UploadStemcellURLStub = stub
}

func (fake *FakeDirector) UploadStemcellURLArgsForCall(i int) (string, string, bool) {
	fake.uploadStemcellURLMutex.RLock()
	defer fake.uploadStemcellURLMutex.RUnlock()
	argsForCall := fake.uploadStemcellURLArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDirector) UploadStemcellURLReturns(result1 error) {
	fake.uploadStemcellURLMutex.Lock()
	defer fake.uploadStemcellURLMutex.Unlock()
	fake.UploadStemcellURLStub = nil
	fake.uploadStemcellURLReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) UploadStemcellURLReturnsOnCall(i int, result1 error) {
	fake.uploadStemcellURLMutex.Lock()
	defer fake.uploadStemcellURLMutex.Unlock()
	fake.UploadStemcellURLStub = nil
	if fake.uploadStemcellURLReturnsOnCall == nil {
		fake.uploadStemcellURLReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadStemcellURLReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDirector) WithContext(arg1 string) director.Director {
	fake.withContextMutex.Lock()
	ret, specificReturn := fake.withContextReturnsOnCall[len(fake.withContextArgsForCall)]
	fake.withContextArgsForCall = append(fake.withContextArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("WithContext", []interface{}{arg1})
	fake.withContextMutex.Unlock()
	if fake.WithContextStub != nil {
		return fake.WithContextStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.withContextReturns
	return fakeReturns.result1
}

func (fake *FakeDirector) WithContextCallCount() int {
	fake.withContextMutex.RLock()
	defer fake.withContextMutex.RUnlock()
	return len(fake.withContextArgsForCall)
}

func (fake *FakeDirector) WithContextCalls(stub func(string) director.Director) {
	fake.withContextMutex.Lock()
	defer fake.withContextMutex.Unlock()
	fake.WithContextStub = stub
}

func (fake *FakeDirector) WithContextArgsForCall(i int) string {
	fake.withContextMutex.RLock()
	defer fake.withContextMutex.RUnlock()
	argsForCall := fake.withContextArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDirector) WithContextReturns(result1 director.Director) {
	fake.withContextMutex.Lock()
	defer fake.withContextMutex.Unlock()
	fake.WithContextStub = nil
	fake.withContextReturns = struct {
		result1 director.Director
	}{result1}
}

func (fake *FakeDirector) WithContextReturnsOnCall(i int, result1 director.Director) {
	fake.withContextMutex.Lock()
	defer fake.withContextMutex.Unlock()
	fake.WithContextStub = nil
	if fake.withContextReturnsOnCall == nil {
		fake.withContextReturnsOnCall = make(map[int]struct {
			result1 director.Director
		})
	}
	fake.withContextReturnsOnCall[i] = struct {
		result1 director.Director
	}{result1}
}

func (fake *FakeDirector) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cancelTasksMutex.RLock()
	defer fake.cancelTasksMutex.RUnlock()
	fake.certificateExpiryMutex.RLock()
	defer fake.certificateExpiryMutex.RUnlock()
	fake.cleanUpMutex.RLock()
	defer fake.cleanUpMutex.RUnlock()
	fake.currentTasksMutex.RLock()
	defer fake.currentTasksMutex.RUnlock()
	fake.deleteConfigMutex.RLock()
	defer fake.deleteConfigMutex.RUnlock()
	fake.deleteConfigByIDMutex.RLock()
	defer fake.deleteConfigByIDMutex.RUnlock()
	fake.deploymentsMutex.RLock()
	defer fake.deploymentsMutex.RUnlock()
	fake.diffCPIConfigMutex.RLock()
	defer fake.diffCPIConfigMutex.RUnlock()
	fake.diffCloudConfigMutex.RLock()
	defer fake.diffCloudConfigMutex.RUnlock()
	fake.diffConfigMutex.RLock()
	defer fake.diffConfigMutex.RUnlock()
	fake.diffConfigByIDOrContentMutex.RLock()
	defer fake.diffConfigByIDOrContentMutex.RUnlock()
	fake.diffRuntimeConfigMutex.RLock()
	defer fake.diffRuntimeConfigMutex.RUnlock()
	fake.downloadResourceUncheckedMutex.RLock()
	defer fake.downloadResourceUncheckedMutex.RUnlock()
	fake.enableResurrectionMutex.RLock()
	defer fake.enableResurrectionMutex.RUnlock()
	fake.eventMutex.RLock()
	defer fake.eventMutex.RUnlock()
	fake.eventsMutex.RLock()
	defer fake.eventsMutex.RUnlock()
	fake.findDeploymentMutex.RLock()
	defer fake.findDeploymentMutex.RUnlock()
	fake.findOrphanDiskMutex.RLock()
	defer fake.findOrphanDiskMutex.RUnlock()
	fake.findOrphanNetworkMutex.RLock()
	defer fake.findOrphanNetworkMutex.RUnlock()
	fake.findReleaseMutex.RLock()
	defer fake.findReleaseMutex.RUnlock()
	fake.findReleaseSeriesMutex.RLock()
	defer fake.findReleaseSeriesMutex.RUnlock()
	fake.findStemcellMutex.RLock()
	defer fake.findStemcellMutex.RUnlock()
	fake.findTaskMutex.RLock()
	defer fake.findTaskMutex.RUnlock()
	fake.findTasksByContextIdMutex.RLock()
	defer fake.findTasksByContextIdMutex.RUnlock()
	fake.hasReleaseMutex.RLock()
	defer fake.hasReleaseMutex.RUnlock()
	fake.hasStemcellMutex.RLock()
	defer fake.hasStemcellMutex.RUnlock()
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	fake.isAuthenticatedMutex.RLock()
	defer fake.isAuthenticatedMutex.RUnlock()
	fake.latestCPIConfigMutex.RLock()
	defer fake.latestCPIConfigMutex.RUnlock()
	fake.latestCloudConfigMutex.RLock()
	defer fake.latestCloudConfigMutex.RUnlock()
	fake.latestConfigMutex.RLock()
	defer fake.latestConfigMutex.RUnlock()
	fake.latestConfigByIDMutex.RLock()
	defer fake.latestConfigByIDMutex.RUnlock()
	fake.latestRuntimeConfigMutex.RLock()
	defer fake.latestRuntimeConfigMutex.RUnlock()
	fake.listConfigsMutex.RLock()
	defer fake.listConfigsMutex.RUnlock()
	fake.listDeploymentConfigsMutex.RLock()
	defer fake.listDeploymentConfigsMutex.RUnlock()
	fake.listDeploymentsMutex.RLock()
	defer fake.listDeploymentsMutex.RUnlock()
	fake.locksMutex.RLock()
	defer fake.locksMutex.RUnlock()
	fake.matchPackagesMutex.RLock()
	defer fake.matchPackagesMutex.RUnlock()
	fake.orphanDiskMutex.RLock()
	defer fake.orphanDiskMutex.RUnlock()
	fake.orphanDisksMutex.RLock()
	defer fake.orphanDisksMutex.RUnlock()
	fake.orphanNetworksMutex.RLock()
	defer fake.orphanNetworksMutex.RUnlock()
	fake.orphanedVMsMutex.RLock()
	defer fake.orphanedVMsMutex.RUnlock()
	fake.recentTasksMutex.RLock()
	defer fake.recentTasksMutex.RUnlock()
	fake.releasesMutex.RLock()
	defer fake.releasesMutex.RUnlock()
	fake.stemcellNeedsUploadMutex.RLock()
	defer fake.stemcellNeedsUploadMutex.RUnlock()
	fake.stemcellsMutex.RLock()
	defer fake.stemcellsMutex.RUnlock()
	fake.updateCPIConfigMutex.RLock()
	defer fake.updateCPIConfigMutex.RUnlock()
	fake.updateCloudConfigMutex.RLock()
	defer fake.updateCloudConfigMutex.RUnlock()
	fake.updateConfigMutex.RLock()
	defer fake.updateConfigMutex.RUnlock()
	fake.updateRuntimeConfigMutex.RLock()
	defer fake.updateRuntimeConfigMutex.RUnlock()
	fake.uploadReleaseFileMutex.RLock()
	defer fake.uploadReleaseFileMutex.RUnlock()
	fake.uploadReleaseURLMutex.RLock()
	defer fake.uploadReleaseURLMutex.RUnlock()
	fake.uploadStemcellFileMutex.RLock()
	defer fake.uploadStemcellFileMutex.RUnlock()
	fake.uploadStemcellURLMutex.RLock()
	defer fake.uploadStemcellURLMutex.RUnlock()
	fake.withContextMutex.RLock()
	defer fake.withContextMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDirector) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ director.Director = new(FakeDirector)
