// Code generated by counterfeiter. DO NOT EDIT.
package directorfakes

import (
	"sync"
	"time"

	"github.com/cloudfoundry/bosh-cli/director"
)

type FakeTask struct {
	CPIOutputStub        func(director.TaskReporter) error
	cPIOutputMutex       sync.RWMutex
	cPIOutputArgsForCall []struct {
		arg1 director.TaskReporter
	}
	cPIOutputReturns struct {
		result1 error
	}
	cPIOutputReturnsOnCall map[int]struct {
		result1 error
	}
	CancelStub        func() error
	cancelMutex       sync.RWMutex
	cancelArgsForCall []struct {
	}
	cancelReturns struct {
		result1 error
	}
	cancelReturnsOnCall map[int]struct {
		result1 error
	}
	ContextIDStub        func() string
	contextIDMutex       sync.RWMutex
	contextIDArgsForCall []struct {
	}
	contextIDReturns struct {
		result1 string
	}
	contextIDReturnsOnCall map[int]struct {
		result1 string
	}
	DebugOutputStub        func(director.TaskReporter) error
	debugOutputMutex       sync.RWMutex
	debugOutputArgsForCall []struct {
		arg1 director.TaskReporter
	}
	debugOutputReturns struct {
		result1 error
	}
	debugOutputReturnsOnCall map[int]struct {
		result1 error
	}
	DeploymentNameStub        func() string
	deploymentNameMutex       sync.RWMutex
	deploymentNameArgsForCall []struct {
	}
	deploymentNameReturns struct {
		result1 string
	}
	deploymentNameReturnsOnCall map[int]struct {
		result1 string
	}
	DescriptionStub        func() string
	descriptionMutex       sync.RWMutex
	descriptionArgsForCall []struct {
	}
	descriptionReturns struct {
		result1 string
	}
	descriptionReturnsOnCall map[int]struct {
		result1 string
	}
	EventOutputStub        func(director.TaskReporter) error
	eventOutputMutex       sync.RWMutex
	eventOutputArgsForCall []struct {
		arg1 director.TaskReporter
	}
	eventOutputReturns struct {
		result1 error
	}
	eventOutputReturnsOnCall map[int]struct {
		result1 error
	}
	FinishedAtStub        func() time.Time
	finishedAtMutex       sync.RWMutex
	finishedAtArgsForCall []struct {
	}
	finishedAtReturns struct {
		result1 time.Time
	}
	finishedAtReturnsOnCall map[int]struct {
		result1 time.Time
	}
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	IsErrorStub        func() bool
	isErrorMutex       sync.RWMutex
	isErrorArgsForCall []struct {
	}
	isErrorReturns struct {
		result1 bool
	}
	isErrorReturnsOnCall map[int]struct {
		result1 bool
	}
	ResultStub        func() string
	resultMutex       sync.RWMutex
	resultArgsForCall []struct {
	}
	resultReturns struct {
		result1 string
	}
	resultReturnsOnCall map[int]struct {
		result1 string
	}
	ResultOutputStub        func(director.TaskReporter) error
	resultOutputMutex       sync.RWMutex
	resultOutputArgsForCall []struct {
		arg1 director.TaskReporter
	}
	resultOutputReturns struct {
		result1 error
	}
	resultOutputReturnsOnCall map[int]struct {
		result1 error
	}
	StartedAtStub        func() time.Time
	startedAtMutex       sync.RWMutex
	startedAtArgsForCall []struct {
	}
	startedAtReturns struct {
		result1 time.Time
	}
	startedAtReturnsOnCall map[int]struct {
		result1 time.Time
	}
	StateStub        func() string
	stateMutex       sync.RWMutex
	stateArgsForCall []struct {
	}
	stateReturns struct {
		result1 string
	}
	stateReturnsOnCall map[int]struct {
		result1 string
	}
	UserStub        func() string
	userMutex       sync.RWMutex
	userArgsForCall []struct {
	}
	userReturns struct {
		result1 string
	}
	userReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTask) CPIOutput(arg1 director.TaskReporter) error {
	fake.cPIOutputMutex.Lock()
	ret, specificReturn := fake.cPIOutputReturnsOnCall[len(fake.cPIOutputArgsForCall)]
	fake.cPIOutputArgsForCall = append(fake.cPIOutputArgsForCall, struct {
		arg1 director.TaskReporter
	}{arg1})
	stub := fake.CPIOutputStub
	fakeReturns := fake.cPIOutputReturns
	fake.recordInvocation("CPIOutput", []interface{}{arg1})
	fake.cPIOutputMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTask) CPIOutputCallCount() int {
	fake.cPIOutputMutex.RLock()
	defer fake.cPIOutputMutex.RUnlock()
	return len(fake.cPIOutputArgsForCall)
}

func (fake *FakeTask) CPIOutputCalls(stub func(director.TaskReporter) error) {
	fake.cPIOutputMutex.Lock()
	defer fake.cPIOutputMutex.Unlock()
	fake.CPIOutputStub = stub
}

func (fake *FakeTask) CPIOutputArgsForCall(i int) director.TaskReporter {
	fake.cPIOutputMutex.RLock()
	defer fake.cPIOutputMutex.RUnlock()
	argsForCall := fake.cPIOutputArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTask) CPIOutputReturns(result1 error) {
	fake.cPIOutputMutex.Lock()
	defer fake.cPIOutputMutex.Unlock()
	fake.CPIOutputStub = nil
	fake.cPIOutputReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) CPIOutputReturnsOnCall(i int, result1 error) {
	fake.cPIOutputMutex.Lock()
	defer fake.cPIOutputMutex.Unlock()
	fake.CPIOutputStub = nil
	if fake.cPIOutputReturnsOnCall == nil {
		fake.cPIOutputReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cPIOutputReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) Cancel() error {
	fake.cancelMutex.Lock()
	ret, specificReturn := fake.cancelReturnsOnCall[len(fake.cancelArgsForCall)]
	fake.cancelArgsForCall = append(fake.cancelArgsForCall, struct {
	}{})
	stub := fake.CancelStub
	fakeReturns := fake.cancelReturns
	fake.recordInvocation("Cancel", []interface{}{})
	fake.cancelMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTask) CancelCallCount() int {
	fake.cancelMutex.RLock()
	defer fake.cancelMutex.RUnlock()
	return len(fake.cancelArgsForCall)
}

func (fake *FakeTask) CancelCalls(stub func() error) {
	fake.cancelMutex.Lock()
	defer fake.cancelMutex.Unlock()
	fake.CancelStub = stub
}

func (fake *FakeTask) CancelReturns(result1 error) {
	fake.cancelMutex.Lock()
	defer fake.cancelMutex.Unlock()
	fake.CancelStub = nil
	fake.cancelReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) CancelReturnsOnCall(i int, result1 error) {
	fake.cancelMutex.Lock()
	defer fake.cancelMutex.Unlock()
	fake.CancelStub = nil
	if fake.cancelReturnsOnCall == nil {
		fake.cancelReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) ContextID() string {
	fake.contextIDMutex.Lock()
	ret, specificReturn := fake.contextIDReturnsOnCall[len(fake.contextIDArgsForCall)]
	fake.contextIDArgsForCall = append(fake.contextIDArgsForCall, struct {
	}{})
	stub := fake.ContextIDStub
	fakeReturns := fake.contextIDReturns
	fake.recordInvocation("ContextID", []interface{}{})
	fake.contextIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTask) ContextIDCallCount() int {
	fake.contextIDMutex.RLock()
	defer fake.contextIDMutex.RUnlock()
	return len(fake.contextIDArgsForCall)
}

func (fake *FakeTask) ContextIDCalls(stub func() string) {
	fake.contextIDMutex.Lock()
	defer fake.contextIDMutex.Unlock()
	fake.ContextIDStub = stub
}

func (fake *FakeTask) ContextIDReturns(result1 string) {
	fake.contextIDMutex.Lock()
	defer fake.contextIDMutex.Unlock()
	fake.ContextIDStub = nil
	fake.contextIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) ContextIDReturnsOnCall(i int, result1 string) {
	fake.contextIDMutex.Lock()
	defer fake.contextIDMutex.Unlock()
	fake.ContextIDStub = nil
	if fake.contextIDReturnsOnCall == nil {
		fake.contextIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.contextIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) DebugOutput(arg1 director.TaskReporter) error {
	fake.debugOutputMutex.Lock()
	ret, specificReturn := fake.debugOutputReturnsOnCall[len(fake.debugOutputArgsForCall)]
	fake.debugOutputArgsForCall = append(fake.debugOutputArgsForCall, struct {
		arg1 director.TaskReporter
	}{arg1})
	stub := fake.DebugOutputStub
	fakeReturns := fake.debugOutputReturns
	fake.recordInvocation("DebugOutput", []interface{}{arg1})
	fake.debugOutputMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTask) DebugOutputCallCount() int {
	fake.debugOutputMutex.RLock()
	defer fake.debugOutputMutex.RUnlock()
	return len(fake.debugOutputArgsForCall)
}

func (fake *FakeTask) DebugOutputCalls(stub func(director.TaskReporter) error) {
	fake.debugOutputMutex.Lock()
	defer fake.debugOutputMutex.Unlock()
	fake.DebugOutputStub = stub
}

func (fake *FakeTask) DebugOutputArgsForCall(i int) director.TaskReporter {
	fake.debugOutputMutex.RLock()
	defer fake.debugOutputMutex.RUnlock()
	argsForCall := fake.debugOutputArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTask) DebugOutputReturns(result1 error) {
	fake.debugOutputMutex.Lock()
	defer fake.debugOutputMutex.Unlock()
	fake.DebugOutputStub = nil
	fake.debugOutputReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) DebugOutputReturnsOnCall(i int, result1 error) {
	fake.debugOutputMutex.Lock()
	defer fake.debugOutputMutex.Unlock()
	fake.DebugOutputStub = nil
	if fake.debugOutputReturnsOnCall == nil {
		fake.debugOutputReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.debugOutputReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) DeploymentName() string {
	fake.deploymentNameMutex.Lock()
	ret, specificReturn := fake.deploymentNameReturnsOnCall[len(fake.deploymentNameArgsForCall)]
	fake.deploymentNameArgsForCall = append(fake.deploymentNameArgsForCall, struct {
	}{})
	stub := fake.DeploymentNameStub
	fakeReturns := fake.deploymentNameReturns
	fake.recordInvocation("DeploymentName", []interface{}{})
	fake.deploymentNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTask) DeploymentNameCallCount() int {
	fake.deploymentNameMutex.RLock()
	defer fake.deploymentNameMutex.RUnlock()
	return len(fake.deploymentNameArgsForCall)
}

func (fake *FakeTask) DeploymentNameCalls(stub func() string) {
	fake.deploymentNameMutex.Lock()
	defer fake.deploymentNameMutex.Unlock()
	fake.DeploymentNameStub = stub
}

func (fake *FakeTask) DeploymentNameReturns(result1 string) {
	fake.deploymentNameMutex.Lock()
	defer fake.deploymentNameMutex.Unlock()
	fake.DeploymentNameStub = nil
	fake.deploymentNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) DeploymentNameReturnsOnCall(i int, result1 string) {
	fake.deploymentNameMutex.Lock()
	defer fake.deploymentNameMutex.Unlock()
	fake.DeploymentNameStub = nil
	if fake.deploymentNameReturnsOnCall == nil {
		fake.deploymentNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.deploymentNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) Description() string {
	fake.descriptionMutex.Lock()
	ret, specificReturn := fake.descriptionReturnsOnCall[len(fake.descriptionArgsForCall)]
	fake.descriptionArgsForCall = append(fake.descriptionArgsForCall, struct {
	}{})
	stub := fake.DescriptionStub
	fakeReturns := fake.descriptionReturns
	fake.recordInvocation("Description", []interface{}{})
	fake.descriptionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTask) DescriptionCallCount() int {
	fake.descriptionMutex.RLock()
	defer fake.descriptionMutex.RUnlock()
	return len(fake.descriptionArgsForCall)
}

func (fake *FakeTask) DescriptionCalls(stub func() string) {
	fake.descriptionMutex.Lock()
	defer fake.descriptionMutex.Unlock()
	fake.DescriptionStub = stub
}

func (fake *FakeTask) DescriptionReturns(result1 string) {
	fake.descriptionMutex.Lock()
	defer fake.descriptionMutex.Unlock()
	fake.DescriptionStub = nil
	fake.descriptionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) DescriptionReturnsOnCall(i int, result1 string) {
	fake.descriptionMutex.Lock()
	defer fake.descriptionMutex.Unlock()
	fake.DescriptionStub = nil
	if fake.descriptionReturnsOnCall == nil {
		fake.descriptionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.descriptionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) EventOutput(arg1 director.TaskReporter) error {
	fake.eventOutputMutex.Lock()
	ret, specificReturn := fake.eventOutputReturnsOnCall[len(fake.eventOutputArgsForCall)]
	fake.eventOutputArgsForCall = append(fake.eventOutputArgsForCall, struct {
		arg1 director.TaskReporter
	}{arg1})
	stub := fake.EventOutputStub
	fakeReturns := fake.eventOutputReturns
	fake.recordInvocation("EventOutput", []interface{}{arg1})
	fake.eventOutputMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTask) EventOutputCallCount() int {
	fake.eventOutputMutex.RLock()
	defer fake.eventOutputMutex.RUnlock()
	return len(fake.eventOutputArgsForCall)
}

func (fake *FakeTask) EventOutputCalls(stub func(director.TaskReporter) error) {
	fake.eventOutputMutex.Lock()
	defer fake.eventOutputMutex.Unlock()
	fake.EventOutputStub = stub
}

func (fake *FakeTask) EventOutputArgsForCall(i int) director.TaskReporter {
	fake.eventOutputMutex.RLock()
	defer fake.eventOutputMutex.RUnlock()
	argsForCall := fake.eventOutputArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTask) EventOutputReturns(result1 error) {
	fake.eventOutputMutex.Lock()
	defer fake.eventOutputMutex.Unlock()
	fake.EventOutputStub = nil
	fake.eventOutputReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) EventOutputReturnsOnCall(i int, result1 error) {
	fake.eventOutputMutex.Lock()
	defer fake.eventOutputMutex.Unlock()
	fake.EventOutputStub = nil
	if fake.eventOutputReturnsOnCall == nil {
		fake.eventOutputReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.eventOutputReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) FinishedAt() time.Time {
	fake.finishedAtMutex.Lock()
	ret, specificReturn := fake.finishedAtReturnsOnCall[len(fake.finishedAtArgsForCall)]
	fake.finishedAtArgsForCall = append(fake.finishedAtArgsForCall, struct {
	}{})
	stub := fake.FinishedAtStub
	fakeReturns := fake.finishedAtReturns
	fake.recordInvocation("FinishedAt", []interface{}{})
	fake.finishedAtMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTask) FinishedAtCallCount() int {
	fake.finishedAtMutex.RLock()
	defer fake.finishedAtMutex.RUnlock()
	return len(fake.finishedAtArgsForCall)
}

func (fake *FakeTask) FinishedAtCalls(stub func() time.Time) {
	fake.finishedAtMutex.Lock()
	defer fake.finishedAtMutex.Unlock()
	fake.FinishedAtStub = stub
}

func (fake *FakeTask) FinishedAtReturns(result1 time.Time) {
	fake.finishedAtMutex.Lock()
	defer fake.finishedAtMutex.Unlock()
	fake.FinishedAtStub = nil
	fake.finishedAtReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeTask) FinishedAtReturnsOnCall(i int, result1 time.Time) {
	fake.finishedAtMutex.Lock()
	defer fake.finishedAtMutex.Unlock()
	fake.FinishedAtStub = nil
	if fake.finishedAtReturnsOnCall == nil {
		fake.finishedAtReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.finishedAtReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeTask) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	stub := fake.IDStub
	fakeReturns := fake.iDReturns
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTask) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeTask) IDCalls(stub func() int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakeTask) IDReturns(result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeTask) IDReturnsOnCall(i int, result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeTask) IsError() bool {
	fake.isErrorMutex.Lock()
	ret, specificReturn := fake.isErrorReturnsOnCall[len(fake.isErrorArgsForCall)]
	fake.isErrorArgsForCall = append(fake.isErrorArgsForCall, struct {
	}{})
	stub := fake.IsErrorStub
	fakeReturns := fake.isErrorReturns
	fake.recordInvocation("IsError", []interface{}{})
	fake.isErrorMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTask) IsErrorCallCount() int {
	fake.isErrorMutex.RLock()
	defer fake.isErrorMutex.RUnlock()
	return len(fake.isErrorArgsForCall)
}

func (fake *FakeTask) IsErrorCalls(stub func() bool) {
	fake.isErrorMutex.Lock()
	defer fake.isErrorMutex.Unlock()
	fake.IsErrorStub = stub
}

func (fake *FakeTask) IsErrorReturns(result1 bool) {
	fake.isErrorMutex.Lock()
	defer fake.isErrorMutex.Unlock()
	fake.IsErrorStub = nil
	fake.isErrorReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeTask) IsErrorReturnsOnCall(i int, result1 bool) {
	fake.isErrorMutex.Lock()
	defer fake.isErrorMutex.Unlock()
	fake.IsErrorStub = nil
	if fake.isErrorReturnsOnCall == nil {
		fake.isErrorReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isErrorReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeTask) Result() string {
	fake.resultMutex.Lock()
	ret, specificReturn := fake.resultReturnsOnCall[len(fake.resultArgsForCall)]
	fake.resultArgsForCall = append(fake.resultArgsForCall, struct {
	}{})
	stub := fake.ResultStub
	fakeReturns := fake.resultReturns
	fake.recordInvocation("Result", []interface{}{})
	fake.resultMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTask) ResultCallCount() int {
	fake.resultMutex.RLock()
	defer fake.resultMutex.RUnlock()
	return len(fake.resultArgsForCall)
}

func (fake *FakeTask) ResultCalls(stub func() string) {
	fake.resultMutex.Lock()
	defer fake.resultMutex.Unlock()
	fake.ResultStub = stub
}

func (fake *FakeTask) ResultReturns(result1 string) {
	fake.resultMutex.Lock()
	defer fake.resultMutex.Unlock()
	fake.ResultStub = nil
	fake.resultReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) ResultReturnsOnCall(i int, result1 string) {
	fake.resultMutex.Lock()
	defer fake.resultMutex.Unlock()
	fake.ResultStub = nil
	if fake.resultReturnsOnCall == nil {
		fake.resultReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.resultReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) ResultOutput(arg1 director.TaskReporter) error {
	fake.resultOutputMutex.Lock()
	ret, specificReturn := fake.resultOutputReturnsOnCall[len(fake.resultOutputArgsForCall)]
	fake.resultOutputArgsForCall = append(fake.resultOutputArgsForCall, struct {
		arg1 director.TaskReporter
	}{arg1})
	stub := fake.ResultOutputStub
	fakeReturns := fake.resultOutputReturns
	fake.recordInvocation("ResultOutput", []interface{}{arg1})
	fake.resultOutputMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTask) ResultOutputCallCount() int {
	fake.resultOutputMutex.RLock()
	defer fake.resultOutputMutex.RUnlock()
	return len(fake.resultOutputArgsForCall)
}

func (fake *FakeTask) ResultOutputCalls(stub func(director.TaskReporter) error) {
	fake.resultOutputMutex.Lock()
	defer fake.resultOutputMutex.Unlock()
	fake.ResultOutputStub = stub
}

func (fake *FakeTask) ResultOutputArgsForCall(i int) director.TaskReporter {
	fake.resultOutputMutex.RLock()
	defer fake.resultOutputMutex.RUnlock()
	argsForCall := fake.resultOutputArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTask) ResultOutputReturns(result1 error) {
	fake.resultOutputMutex.Lock()
	defer fake.resultOutputMutex.Unlock()
	fake.ResultOutputStub = nil
	fake.resultOutputReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) ResultOutputReturnsOnCall(i int, result1 error) {
	fake.resultOutputMutex.Lock()
	defer fake.resultOutputMutex.Unlock()
	fake.ResultOutputStub = nil
	if fake.resultOutputReturnsOnCall == nil {
		fake.resultOutputReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resultOutputReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTask) StartedAt() time.Time {
	fake.startedAtMutex.Lock()
	ret, specificReturn := fake.startedAtReturnsOnCall[len(fake.startedAtArgsForCall)]
	fake.startedAtArgsForCall = append(fake.startedAtArgsForCall, struct {
	}{})
	stub := fake.StartedAtStub
	fakeReturns := fake.startedAtReturns
	fake.recordInvocation("StartedAt", []interface{}{})
	fake.startedAtMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTask) StartedAtCallCount() int {
	fake.startedAtMutex.RLock()
	defer fake.startedAtMutex.RUnlock()
	return len(fake.startedAtArgsForCall)
}

func (fake *FakeTask) StartedAtCalls(stub func() time.Time) {
	fake.startedAtMutex.Lock()
	defer fake.startedAtMutex.Unlock()
	fake.StartedAtStub = stub
}

func (fake *FakeTask) StartedAtReturns(result1 time.Time) {
	fake.startedAtMutex.Lock()
	defer fake.startedAtMutex.Unlock()
	fake.StartedAtStub = nil
	fake.startedAtReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeTask) StartedAtReturnsOnCall(i int, result1 time.Time) {
	fake.startedAtMutex.Lock()
	defer fake.startedAtMutex.Unlock()
	fake.StartedAtStub = nil
	if fake.startedAtReturnsOnCall == nil {
		fake.startedAtReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.startedAtReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeTask) State() string {
	fake.stateMutex.Lock()
	ret, specificReturn := fake.stateReturnsOnCall[len(fake.stateArgsForCall)]
	fake.stateArgsForCall = append(fake.stateArgsForCall, struct {
	}{})
	stub := fake.StateStub
	fakeReturns := fake.stateReturns
	fake.recordInvocation("State", []interface{}{})
	fake.stateMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTask) StateCallCount() int {
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	return len(fake.stateArgsForCall)
}

func (fake *FakeTask) StateCalls(stub func() string) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = stub
}

func (fake *FakeTask) StateReturns(result1 string) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = nil
	fake.stateReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) StateReturnsOnCall(i int, result1 string) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = nil
	if fake.stateReturnsOnCall == nil {
		fake.stateReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.stateReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) User() string {
	fake.userMutex.Lock()
	ret, specificReturn := fake.userReturnsOnCall[len(fake.userArgsForCall)]
	fake.userArgsForCall = append(fake.userArgsForCall, struct {
	}{})
	stub := fake.UserStub
	fakeReturns := fake.userReturns
	fake.recordInvocation("User", []interface{}{})
	fake.userMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTask) UserCallCount() int {
	fake.userMutex.RLock()
	defer fake.userMutex.RUnlock()
	return len(fake.userArgsForCall)
}

func (fake *FakeTask) UserCalls(stub func() string) {
	fake.userMutex.Lock()
	defer fake.userMutex.Unlock()
	fake.UserStub = stub
}

func (fake *FakeTask) UserReturns(result1 string) {
	fake.userMutex.Lock()
	defer fake.userMutex.Unlock()
	fake.UserStub = nil
	fake.userReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) UserReturnsOnCall(i int, result1 string) {
	fake.userMutex.Lock()
	defer fake.userMutex.Unlock()
	fake.UserStub = nil
	if fake.userReturnsOnCall == nil {
		fake.userReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.userReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTask) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cPIOutputMutex.RLock()
	defer fake.cPIOutputMutex.RUnlock()
	fake.cancelMutex.RLock()
	defer fake.cancelMutex.RUnlock()
	fake.contextIDMutex.RLock()
	defer fake.contextIDMutex.RUnlock()
	fake.debugOutputMutex.RLock()
	defer fake.debugOutputMutex.RUnlock()
	fake.deploymentNameMutex.RLock()
	defer fake.deploymentNameMutex.RUnlock()
	fake.descriptionMutex.RLock()
	defer fake.descriptionMutex.RUnlock()
	fake.eventOutputMutex.RLock()
	defer fake.eventOutputMutex.RUnlock()
	fake.finishedAtMutex.RLock()
	defer fake.finishedAtMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.isErrorMutex.RLock()
	defer fake.isErrorMutex.RUnlock()
	fake.resultMutex.RLock()
	defer fake.resultMutex.RUnlock()
	fake.resultOutputMutex.RLock()
	defer fake.resultOutputMutex.RUnlock()
	fake.startedAtMutex.RLock()
	defer fake.startedAtMutex.RUnlock()
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	fake.userMutex.RLock()
	defer fake.userMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTask) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ director.Task = new(FakeTask)
