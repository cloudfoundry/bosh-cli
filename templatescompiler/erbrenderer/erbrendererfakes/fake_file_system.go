// Code generated by counterfeiter. DO NOT EDIT.
package erbrendererfakes

import (
	"os"
	"path/filepath"
	"sync"

	"github.com/cloudfoundry/bosh-utils/system"
)

type FakeFileSystem struct {
	ChangeTempRootStub        func(string) error
	changeTempRootMutex       sync.RWMutex
	changeTempRootArgsForCall []struct {
		arg1 string
	}
	changeTempRootReturns struct {
		result1 error
	}
	changeTempRootReturnsOnCall map[int]struct {
		result1 error
	}
	ChmodStub        func(string, os.FileMode) error
	chmodMutex       sync.RWMutex
	chmodArgsForCall []struct {
		arg1 string
		arg2 os.FileMode
	}
	chmodReturns struct {
		result1 error
	}
	chmodReturnsOnCall map[int]struct {
		result1 error
	}
	ChownStub        func(string, string) error
	chownMutex       sync.RWMutex
	chownArgsForCall []struct {
		arg1 string
		arg2 string
	}
	chownReturns struct {
		result1 error
	}
	chownReturnsOnCall map[int]struct {
		result1 error
	}
	ConvergeFileContentsStub        func(string, []byte, ...system.ConvergeFileContentsOpts) (bool, error)
	convergeFileContentsMutex       sync.RWMutex
	convergeFileContentsArgsForCall []struct {
		arg1 string
		arg2 []byte
		arg3 []system.ConvergeFileContentsOpts
	}
	convergeFileContentsReturns struct {
		result1 bool
		result2 error
	}
	convergeFileContentsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CopyDirStub        func(string, string) error
	copyDirMutex       sync.RWMutex
	copyDirArgsForCall []struct {
		arg1 string
		arg2 string
	}
	copyDirReturns struct {
		result1 error
	}
	copyDirReturnsOnCall map[int]struct {
		result1 error
	}
	CopyFileStub        func(string, string) error
	copyFileMutex       sync.RWMutex
	copyFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	copyFileReturns struct {
		result1 error
	}
	copyFileReturnsOnCall map[int]struct {
		result1 error
	}
	ExpandPathStub        func(string) (string, error)
	expandPathMutex       sync.RWMutex
	expandPathArgsForCall []struct {
		arg1 string
	}
	expandPathReturns struct {
		result1 string
		result2 error
	}
	expandPathReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	FileExistsStub        func(string) bool
	fileExistsMutex       sync.RWMutex
	fileExistsArgsForCall []struct {
		arg1 string
	}
	fileExistsReturns struct {
		result1 bool
	}
	fileExistsReturnsOnCall map[int]struct {
		result1 bool
	}
	GlobStub        func(string) ([]string, error)
	globMutex       sync.RWMutex
	globArgsForCall []struct {
		arg1 string
	}
	globReturns struct {
		result1 []string
		result2 error
	}
	globReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	HomeDirStub        func(string) (string, error)
	homeDirMutex       sync.RWMutex
	homeDirArgsForCall []struct {
		arg1 string
	}
	homeDirReturns struct {
		result1 string
		result2 error
	}
	homeDirReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	LstatStub        func(string) (os.FileInfo, error)
	lstatMutex       sync.RWMutex
	lstatArgsForCall []struct {
		arg1 string
	}
	lstatReturns struct {
		result1 os.FileInfo
		result2 error
	}
	lstatReturnsOnCall map[int]struct {
		result1 os.FileInfo
		result2 error
	}
	MkdirAllStub        func(string, os.FileMode) error
	mkdirAllMutex       sync.RWMutex
	mkdirAllArgsForCall []struct {
		arg1 string
		arg2 os.FileMode
	}
	mkdirAllReturns struct {
		result1 error
	}
	mkdirAllReturnsOnCall map[int]struct {
		result1 error
	}
	OpenFileStub        func(string, int, os.FileMode) (system.File, error)
	openFileMutex       sync.RWMutex
	openFileArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 os.FileMode
	}
	openFileReturns struct {
		result1 system.File
		result2 error
	}
	openFileReturnsOnCall map[int]struct {
		result1 system.File
		result2 error
	}
	ReadAndFollowLinkStub        func(string) (string, error)
	readAndFollowLinkMutex       sync.RWMutex
	readAndFollowLinkArgsForCall []struct {
		arg1 string
	}
	readAndFollowLinkReturns struct {
		result1 string
		result2 error
	}
	readAndFollowLinkReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ReadFileStub        func(string) ([]byte, error)
	readFileMutex       sync.RWMutex
	readFileArgsForCall []struct {
		arg1 string
	}
	readFileReturns struct {
		result1 []byte
		result2 error
	}
	readFileReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ReadFileStringStub        func(string) (string, error)
	readFileStringMutex       sync.RWMutex
	readFileStringArgsForCall []struct {
		arg1 string
	}
	readFileStringReturns struct {
		result1 string
		result2 error
	}
	readFileStringReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ReadFileWithOptsStub        func(string, system.ReadOpts) ([]byte, error)
	readFileWithOptsMutex       sync.RWMutex
	readFileWithOptsArgsForCall []struct {
		arg1 string
		arg2 system.ReadOpts
	}
	readFileWithOptsReturns struct {
		result1 []byte
		result2 error
	}
	readFileWithOptsReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ReadlinkStub        func(string) (string, error)
	readlinkMutex       sync.RWMutex
	readlinkArgsForCall []struct {
		arg1 string
	}
	readlinkReturns struct {
		result1 string
		result2 error
	}
	readlinkReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	RecursiveGlobStub        func(string) ([]string, error)
	recursiveGlobMutex       sync.RWMutex
	recursiveGlobArgsForCall []struct {
		arg1 string
	}
	recursiveGlobReturns struct {
		result1 []string
		result2 error
	}
	recursiveGlobReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	RemoveAllStub        func(string) error
	removeAllMutex       sync.RWMutex
	removeAllArgsForCall []struct {
		arg1 string
	}
	removeAllReturns struct {
		result1 error
	}
	removeAllReturnsOnCall map[int]struct {
		result1 error
	}
	RenameStub        func(string, string) error
	renameMutex       sync.RWMutex
	renameArgsForCall []struct {
		arg1 string
		arg2 string
	}
	renameReturns struct {
		result1 error
	}
	renameReturnsOnCall map[int]struct {
		result1 error
	}
	StatStub        func(string) (os.FileInfo, error)
	statMutex       sync.RWMutex
	statArgsForCall []struct {
		arg1 string
	}
	statReturns struct {
		result1 os.FileInfo
		result2 error
	}
	statReturnsOnCall map[int]struct {
		result1 os.FileInfo
		result2 error
	}
	StatWithOptsStub        func(string, system.StatOpts) (os.FileInfo, error)
	statWithOptsMutex       sync.RWMutex
	statWithOptsArgsForCall []struct {
		arg1 string
		arg2 system.StatOpts
	}
	statWithOptsReturns struct {
		result1 os.FileInfo
		result2 error
	}
	statWithOptsReturnsOnCall map[int]struct {
		result1 os.FileInfo
		result2 error
	}
	SymlinkStub        func(string, string) error
	symlinkMutex       sync.RWMutex
	symlinkArgsForCall []struct {
		arg1 string
		arg2 string
	}
	symlinkReturns struct {
		result1 error
	}
	symlinkReturnsOnCall map[int]struct {
		result1 error
	}
	TempDirStub        func(string) (string, error)
	tempDirMutex       sync.RWMutex
	tempDirArgsForCall []struct {
		arg1 string
	}
	tempDirReturns struct {
		result1 string
		result2 error
	}
	tempDirReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	TempFileStub        func(string) (system.File, error)
	tempFileMutex       sync.RWMutex
	tempFileArgsForCall []struct {
		arg1 string
	}
	tempFileReturns struct {
		result1 system.File
		result2 error
	}
	tempFileReturnsOnCall map[int]struct {
		result1 system.File
		result2 error
	}
	WalkStub        func(string, filepath.WalkFunc) error
	walkMutex       sync.RWMutex
	walkArgsForCall []struct {
		arg1 string
		arg2 filepath.WalkFunc
	}
	walkReturns struct {
		result1 error
	}
	walkReturnsOnCall map[int]struct {
		result1 error
	}
	WriteFileStub        func(string, []byte) error
	writeFileMutex       sync.RWMutex
	writeFileArgsForCall []struct {
		arg1 string
		arg2 []byte
	}
	writeFileReturns struct {
		result1 error
	}
	writeFileReturnsOnCall map[int]struct {
		result1 error
	}
	WriteFileQuietlyStub        func(string, []byte) error
	writeFileQuietlyMutex       sync.RWMutex
	writeFileQuietlyArgsForCall []struct {
		arg1 string
		arg2 []byte
	}
	writeFileQuietlyReturns struct {
		result1 error
	}
	writeFileQuietlyReturnsOnCall map[int]struct {
		result1 error
	}
	WriteFileStringStub        func(string, string) error
	writeFileStringMutex       sync.RWMutex
	writeFileStringArgsForCall []struct {
		arg1 string
		arg2 string
	}
	writeFileStringReturns struct {
		result1 error
	}
	writeFileStringReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeFileSystem) ChangeTempRoot(arg1 string) error {
	fake.changeTempRootMutex.Lock()
	ret, specificReturn := fake.changeTempRootReturnsOnCall[len(fake.changeTempRootArgsForCall)]
	fake.changeTempRootArgsForCall = append(fake.changeTempRootArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ChangeTempRootStub
	fakeReturns := fake.changeTempRootReturns
	fake.recordInvocation("ChangeTempRoot", []interface{}{arg1})
	fake.changeTempRootMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFileSystem) ChangeTempRootCallCount() int {
	fake.changeTempRootMutex.RLock()
	defer fake.changeTempRootMutex.RUnlock()
	return len(fake.changeTempRootArgsForCall)
}

func (fake *FakeFileSystem) ChangeTempRootCalls(stub func(string) error) {
	fake.changeTempRootMutex.Lock()
	defer fake.changeTempRootMutex.Unlock()
	fake.ChangeTempRootStub = stub
}

func (fake *FakeFileSystem) ChangeTempRootArgsForCall(i int) string {
	fake.changeTempRootMutex.RLock()
	defer fake.changeTempRootMutex.RUnlock()
	argsForCall := fake.changeTempRootArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFileSystem) ChangeTempRootReturns(result1 error) {
	fake.changeTempRootMutex.Lock()
	defer fake.changeTempRootMutex.Unlock()
	fake.ChangeTempRootStub = nil
	fake.changeTempRootReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) ChangeTempRootReturnsOnCall(i int, result1 error) {
	fake.changeTempRootMutex.Lock()
	defer fake.changeTempRootMutex.Unlock()
	fake.ChangeTempRootStub = nil
	if fake.changeTempRootReturnsOnCall == nil {
		fake.changeTempRootReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.changeTempRootReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) Chmod(arg1 string, arg2 os.FileMode) error {
	fake.chmodMutex.Lock()
	ret, specificReturn := fake.chmodReturnsOnCall[len(fake.chmodArgsForCall)]
	fake.chmodArgsForCall = append(fake.chmodArgsForCall, struct {
		arg1 string
		arg2 os.FileMode
	}{arg1, arg2})
	stub := fake.ChmodStub
	fakeReturns := fake.chmodReturns
	fake.recordInvocation("Chmod", []interface{}{arg1, arg2})
	fake.chmodMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFileSystem) ChmodCallCount() int {
	fake.chmodMutex.RLock()
	defer fake.chmodMutex.RUnlock()
	return len(fake.chmodArgsForCall)
}

func (fake *FakeFileSystem) ChmodCalls(stub func(string, os.FileMode) error) {
	fake.chmodMutex.Lock()
	defer fake.chmodMutex.Unlock()
	fake.ChmodStub = stub
}

func (fake *FakeFileSystem) ChmodArgsForCall(i int) (string, os.FileMode) {
	fake.chmodMutex.RLock()
	defer fake.chmodMutex.RUnlock()
	argsForCall := fake.chmodArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFileSystem) ChmodReturns(result1 error) {
	fake.chmodMutex.Lock()
	defer fake.chmodMutex.Unlock()
	fake.ChmodStub = nil
	fake.chmodReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) ChmodReturnsOnCall(i int, result1 error) {
	fake.chmodMutex.Lock()
	defer fake.chmodMutex.Unlock()
	fake.ChmodStub = nil
	if fake.chmodReturnsOnCall == nil {
		fake.chmodReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chmodReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) Chown(arg1 string, arg2 string) error {
	fake.chownMutex.Lock()
	ret, specificReturn := fake.chownReturnsOnCall[len(fake.chownArgsForCall)]
	fake.chownArgsForCall = append(fake.chownArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.ChownStub
	fakeReturns := fake.chownReturns
	fake.recordInvocation("Chown", []interface{}{arg1, arg2})
	fake.chownMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFileSystem) ChownCallCount() int {
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	return len(fake.chownArgsForCall)
}

func (fake *FakeFileSystem) ChownCalls(stub func(string, string) error) {
	fake.chownMutex.Lock()
	defer fake.chownMutex.Unlock()
	fake.ChownStub = stub
}

func (fake *FakeFileSystem) ChownArgsForCall(i int) (string, string) {
	fake.chownMutex.RLock()
	defer fake.chownMutex.RUnlock()
	argsForCall := fake.chownArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFileSystem) ChownReturns(result1 error) {
	fake.chownMutex.Lock()
	defer fake.chownMutex.Unlock()
	fake.ChownStub = nil
	fake.chownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) ChownReturnsOnCall(i int, result1 error) {
	fake.chownMutex.Lock()
	defer fake.chownMutex.Unlock()
	fake.ChownStub = nil
	if fake.chownReturnsOnCall == nil {
		fake.chownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.chownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) ConvergeFileContents(arg1 string, arg2 []byte, arg3 ...system.ConvergeFileContentsOpts) (bool, error) {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.convergeFileContentsMutex.Lock()
	ret, specificReturn := fake.convergeFileContentsReturnsOnCall[len(fake.convergeFileContentsArgsForCall)]
	fake.convergeFileContentsArgsForCall = append(fake.convergeFileContentsArgsForCall, struct {
		arg1 string
		arg2 []byte
		arg3 []system.ConvergeFileContentsOpts
	}{arg1, arg2Copy, arg3})
	stub := fake.ConvergeFileContentsStub
	fakeReturns := fake.convergeFileContentsReturns
	fake.recordInvocation("ConvergeFileContents", []interface{}{arg1, arg2Copy, arg3})
	fake.convergeFileContentsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) ConvergeFileContentsCallCount() int {
	fake.convergeFileContentsMutex.RLock()
	defer fake.convergeFileContentsMutex.RUnlock()
	return len(fake.convergeFileContentsArgsForCall)
}

func (fake *FakeFileSystem) ConvergeFileContentsCalls(stub func(string, []byte, ...system.ConvergeFileContentsOpts) (bool, error)) {
	fake.convergeFileContentsMutex.Lock()
	defer fake.convergeFileContentsMutex.Unlock()
	fake.ConvergeFileContentsStub = stub
}

func (fake *FakeFileSystem) ConvergeFileContentsArgsForCall(i int) (string, []byte, []system.ConvergeFileContentsOpts) {
	fake.convergeFileContentsMutex.RLock()
	defer fake.convergeFileContentsMutex.RUnlock()
	argsForCall := fake.convergeFileContentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFileSystem) ConvergeFileContentsReturns(result1 bool, result2 error) {
	fake.convergeFileContentsMutex.Lock()
	defer fake.convergeFileContentsMutex.Unlock()
	fake.ConvergeFileContentsStub = nil
	fake.convergeFileContentsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) ConvergeFileContentsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.convergeFileContentsMutex.Lock()
	defer fake.convergeFileContentsMutex.Unlock()
	fake.ConvergeFileContentsStub = nil
	if fake.convergeFileContentsReturnsOnCall == nil {
		fake.convergeFileContentsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.convergeFileContentsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) CopyDir(arg1 string, arg2 string) error {
	fake.copyDirMutex.Lock()
	ret, specificReturn := fake.copyDirReturnsOnCall[len(fake.copyDirArgsForCall)]
	fake.copyDirArgsForCall = append(fake.copyDirArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CopyDirStub
	fakeReturns := fake.copyDirReturns
	fake.recordInvocation("CopyDir", []interface{}{arg1, arg2})
	fake.copyDirMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFileSystem) CopyDirCallCount() int {
	fake.copyDirMutex.RLock()
	defer fake.copyDirMutex.RUnlock()
	return len(fake.copyDirArgsForCall)
}

func (fake *FakeFileSystem) CopyDirCalls(stub func(string, string) error) {
	fake.copyDirMutex.Lock()
	defer fake.copyDirMutex.Unlock()
	fake.CopyDirStub = stub
}

func (fake *FakeFileSystem) CopyDirArgsForCall(i int) (string, string) {
	fake.copyDirMutex.RLock()
	defer fake.copyDirMutex.RUnlock()
	argsForCall := fake.copyDirArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFileSystem) CopyDirReturns(result1 error) {
	fake.copyDirMutex.Lock()
	defer fake.copyDirMutex.Unlock()
	fake.CopyDirStub = nil
	fake.copyDirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) CopyDirReturnsOnCall(i int, result1 error) {
	fake.copyDirMutex.Lock()
	defer fake.copyDirMutex.Unlock()
	fake.CopyDirStub = nil
	if fake.copyDirReturnsOnCall == nil {
		fake.copyDirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.copyDirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) CopyFile(arg1 string, arg2 string) error {
	fake.copyFileMutex.Lock()
	ret, specificReturn := fake.copyFileReturnsOnCall[len(fake.copyFileArgsForCall)]
	fake.copyFileArgsForCall = append(fake.copyFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CopyFileStub
	fakeReturns := fake.copyFileReturns
	fake.recordInvocation("CopyFile", []interface{}{arg1, arg2})
	fake.copyFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFileSystem) CopyFileCallCount() int {
	fake.copyFileMutex.RLock()
	defer fake.copyFileMutex.RUnlock()
	return len(fake.copyFileArgsForCall)
}

func (fake *FakeFileSystem) CopyFileCalls(stub func(string, string) error) {
	fake.copyFileMutex.Lock()
	defer fake.copyFileMutex.Unlock()
	fake.CopyFileStub = stub
}

func (fake *FakeFileSystem) CopyFileArgsForCall(i int) (string, string) {
	fake.copyFileMutex.RLock()
	defer fake.copyFileMutex.RUnlock()
	argsForCall := fake.copyFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFileSystem) CopyFileReturns(result1 error) {
	fake.copyFileMutex.Lock()
	defer fake.copyFileMutex.Unlock()
	fake.CopyFileStub = nil
	fake.copyFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) CopyFileReturnsOnCall(i int, result1 error) {
	fake.copyFileMutex.Lock()
	defer fake.copyFileMutex.Unlock()
	fake.CopyFileStub = nil
	if fake.copyFileReturnsOnCall == nil {
		fake.copyFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.copyFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) ExpandPath(arg1 string) (string, error) {
	fake.expandPathMutex.Lock()
	ret, specificReturn := fake.expandPathReturnsOnCall[len(fake.expandPathArgsForCall)]
	fake.expandPathArgsForCall = append(fake.expandPathArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ExpandPathStub
	fakeReturns := fake.expandPathReturns
	fake.recordInvocation("ExpandPath", []interface{}{arg1})
	fake.expandPathMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) ExpandPathCallCount() int {
	fake.expandPathMutex.RLock()
	defer fake.expandPathMutex.RUnlock()
	return len(fake.expandPathArgsForCall)
}

func (fake *FakeFileSystem) ExpandPathCalls(stub func(string) (string, error)) {
	fake.expandPathMutex.Lock()
	defer fake.expandPathMutex.Unlock()
	fake.ExpandPathStub = stub
}

func (fake *FakeFileSystem) ExpandPathArgsForCall(i int) string {
	fake.expandPathMutex.RLock()
	defer fake.expandPathMutex.RUnlock()
	argsForCall := fake.expandPathArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFileSystem) ExpandPathReturns(result1 string, result2 error) {
	fake.expandPathMutex.Lock()
	defer fake.expandPathMutex.Unlock()
	fake.ExpandPathStub = nil
	fake.expandPathReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) ExpandPathReturnsOnCall(i int, result1 string, result2 error) {
	fake.expandPathMutex.Lock()
	defer fake.expandPathMutex.Unlock()
	fake.ExpandPathStub = nil
	if fake.expandPathReturnsOnCall == nil {
		fake.expandPathReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.expandPathReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) FileExists(arg1 string) bool {
	fake.fileExistsMutex.Lock()
	ret, specificReturn := fake.fileExistsReturnsOnCall[len(fake.fileExistsArgsForCall)]
	fake.fileExistsArgsForCall = append(fake.fileExistsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FileExistsStub
	fakeReturns := fake.fileExistsReturns
	fake.recordInvocation("FileExists", []interface{}{arg1})
	fake.fileExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFileSystem) FileExistsCallCount() int {
	fake.fileExistsMutex.RLock()
	defer fake.fileExistsMutex.RUnlock()
	return len(fake.fileExistsArgsForCall)
}

func (fake *FakeFileSystem) FileExistsCalls(stub func(string) bool) {
	fake.fileExistsMutex.Lock()
	defer fake.fileExistsMutex.Unlock()
	fake.FileExistsStub = stub
}

func (fake *FakeFileSystem) FileExistsArgsForCall(i int) string {
	fake.fileExistsMutex.RLock()
	defer fake.fileExistsMutex.RUnlock()
	argsForCall := fake.fileExistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFileSystem) FileExistsReturns(result1 bool) {
	fake.fileExistsMutex.Lock()
	defer fake.fileExistsMutex.Unlock()
	fake.FileExistsStub = nil
	fake.fileExistsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeFileSystem) FileExistsReturnsOnCall(i int, result1 bool) {
	fake.fileExistsMutex.Lock()
	defer fake.fileExistsMutex.Unlock()
	fake.FileExistsStub = nil
	if fake.fileExistsReturnsOnCall == nil {
		fake.fileExistsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.fileExistsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeFileSystem) Glob(arg1 string) ([]string, error) {
	fake.globMutex.Lock()
	ret, specificReturn := fake.globReturnsOnCall[len(fake.globArgsForCall)]
	fake.globArgsForCall = append(fake.globArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GlobStub
	fakeReturns := fake.globReturns
	fake.recordInvocation("Glob", []interface{}{arg1})
	fake.globMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) GlobCallCount() int {
	fake.globMutex.RLock()
	defer fake.globMutex.RUnlock()
	return len(fake.globArgsForCall)
}

func (fake *FakeFileSystem) GlobCalls(stub func(string) ([]string, error)) {
	fake.globMutex.Lock()
	defer fake.globMutex.Unlock()
	fake.GlobStub = stub
}

func (fake *FakeFileSystem) GlobArgsForCall(i int) string {
	fake.globMutex.RLock()
	defer fake.globMutex.RUnlock()
	argsForCall := fake.globArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFileSystem) GlobReturns(result1 []string, result2 error) {
	fake.globMutex.Lock()
	defer fake.globMutex.Unlock()
	fake.GlobStub = nil
	fake.globReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) GlobReturnsOnCall(i int, result1 []string, result2 error) {
	fake.globMutex.Lock()
	defer fake.globMutex.Unlock()
	fake.GlobStub = nil
	if fake.globReturnsOnCall == nil {
		fake.globReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.globReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) HomeDir(arg1 string) (string, error) {
	fake.homeDirMutex.Lock()
	ret, specificReturn := fake.homeDirReturnsOnCall[len(fake.homeDirArgsForCall)]
	fake.homeDirArgsForCall = append(fake.homeDirArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.HomeDirStub
	fakeReturns := fake.homeDirReturns
	fake.recordInvocation("HomeDir", []interface{}{arg1})
	fake.homeDirMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) HomeDirCallCount() int {
	fake.homeDirMutex.RLock()
	defer fake.homeDirMutex.RUnlock()
	return len(fake.homeDirArgsForCall)
}

func (fake *FakeFileSystem) HomeDirCalls(stub func(string) (string, error)) {
	fake.homeDirMutex.Lock()
	defer fake.homeDirMutex.Unlock()
	fake.HomeDirStub = stub
}

func (fake *FakeFileSystem) HomeDirArgsForCall(i int) string {
	fake.homeDirMutex.RLock()
	defer fake.homeDirMutex.RUnlock()
	argsForCall := fake.homeDirArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFileSystem) HomeDirReturns(result1 string, result2 error) {
	fake.homeDirMutex.Lock()
	defer fake.homeDirMutex.Unlock()
	fake.HomeDirStub = nil
	fake.homeDirReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) HomeDirReturnsOnCall(i int, result1 string, result2 error) {
	fake.homeDirMutex.Lock()
	defer fake.homeDirMutex.Unlock()
	fake.HomeDirStub = nil
	if fake.homeDirReturnsOnCall == nil {
		fake.homeDirReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.homeDirReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) Lstat(arg1 string) (os.FileInfo, error) {
	fake.lstatMutex.Lock()
	ret, specificReturn := fake.lstatReturnsOnCall[len(fake.lstatArgsForCall)]
	fake.lstatArgsForCall = append(fake.lstatArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.LstatStub
	fakeReturns := fake.lstatReturns
	fake.recordInvocation("Lstat", []interface{}{arg1})
	fake.lstatMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) LstatCallCount() int {
	fake.lstatMutex.RLock()
	defer fake.lstatMutex.RUnlock()
	return len(fake.lstatArgsForCall)
}

func (fake *FakeFileSystem) LstatCalls(stub func(string) (os.FileInfo, error)) {
	fake.lstatMutex.Lock()
	defer fake.lstatMutex.Unlock()
	fake.LstatStub = stub
}

func (fake *FakeFileSystem) LstatArgsForCall(i int) string {
	fake.lstatMutex.RLock()
	defer fake.lstatMutex.RUnlock()
	argsForCall := fake.lstatArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFileSystem) LstatReturns(result1 os.FileInfo, result2 error) {
	fake.lstatMutex.Lock()
	defer fake.lstatMutex.Unlock()
	fake.LstatStub = nil
	fake.lstatReturns = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) LstatReturnsOnCall(i int, result1 os.FileInfo, result2 error) {
	fake.lstatMutex.Lock()
	defer fake.lstatMutex.Unlock()
	fake.LstatStub = nil
	if fake.lstatReturnsOnCall == nil {
		fake.lstatReturnsOnCall = make(map[int]struct {
			result1 os.FileInfo
			result2 error
		})
	}
	fake.lstatReturnsOnCall[i] = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) MkdirAll(arg1 string, arg2 os.FileMode) error {
	fake.mkdirAllMutex.Lock()
	ret, specificReturn := fake.mkdirAllReturnsOnCall[len(fake.mkdirAllArgsForCall)]
	fake.mkdirAllArgsForCall = append(fake.mkdirAllArgsForCall, struct {
		arg1 string
		arg2 os.FileMode
	}{arg1, arg2})
	stub := fake.MkdirAllStub
	fakeReturns := fake.mkdirAllReturns
	fake.recordInvocation("MkdirAll", []interface{}{arg1, arg2})
	fake.mkdirAllMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFileSystem) MkdirAllCallCount() int {
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	return len(fake.mkdirAllArgsForCall)
}

func (fake *FakeFileSystem) MkdirAllCalls(stub func(string, os.FileMode) error) {
	fake.mkdirAllMutex.Lock()
	defer fake.mkdirAllMutex.Unlock()
	fake.MkdirAllStub = stub
}

func (fake *FakeFileSystem) MkdirAllArgsForCall(i int) (string, os.FileMode) {
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	argsForCall := fake.mkdirAllArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFileSystem) MkdirAllReturns(result1 error) {
	fake.mkdirAllMutex.Lock()
	defer fake.mkdirAllMutex.Unlock()
	fake.MkdirAllStub = nil
	fake.mkdirAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) MkdirAllReturnsOnCall(i int, result1 error) {
	fake.mkdirAllMutex.Lock()
	defer fake.mkdirAllMutex.Unlock()
	fake.MkdirAllStub = nil
	if fake.mkdirAllReturnsOnCall == nil {
		fake.mkdirAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mkdirAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) OpenFile(arg1 string, arg2 int, arg3 os.FileMode) (system.File, error) {
	fake.openFileMutex.Lock()
	ret, specificReturn := fake.openFileReturnsOnCall[len(fake.openFileArgsForCall)]
	fake.openFileArgsForCall = append(fake.openFileArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 os.FileMode
	}{arg1, arg2, arg3})
	stub := fake.OpenFileStub
	fakeReturns := fake.openFileReturns
	fake.recordInvocation("OpenFile", []interface{}{arg1, arg2, arg3})
	fake.openFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) OpenFileCallCount() int {
	fake.openFileMutex.RLock()
	defer fake.openFileMutex.RUnlock()
	return len(fake.openFileArgsForCall)
}

func (fake *FakeFileSystem) OpenFileCalls(stub func(string, int, os.FileMode) (system.File, error)) {
	fake.openFileMutex.Lock()
	defer fake.openFileMutex.Unlock()
	fake.OpenFileStub = stub
}

func (fake *FakeFileSystem) OpenFileArgsForCall(i int) (string, int, os.FileMode) {
	fake.openFileMutex.RLock()
	defer fake.openFileMutex.RUnlock()
	argsForCall := fake.openFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeFileSystem) OpenFileReturns(result1 system.File, result2 error) {
	fake.openFileMutex.Lock()
	defer fake.openFileMutex.Unlock()
	fake.OpenFileStub = nil
	fake.openFileReturns = struct {
		result1 system.File
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) OpenFileReturnsOnCall(i int, result1 system.File, result2 error) {
	fake.openFileMutex.Lock()
	defer fake.openFileMutex.Unlock()
	fake.OpenFileStub = nil
	if fake.openFileReturnsOnCall == nil {
		fake.openFileReturnsOnCall = make(map[int]struct {
			result1 system.File
			result2 error
		})
	}
	fake.openFileReturnsOnCall[i] = struct {
		result1 system.File
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) ReadAndFollowLink(arg1 string) (string, error) {
	fake.readAndFollowLinkMutex.Lock()
	ret, specificReturn := fake.readAndFollowLinkReturnsOnCall[len(fake.readAndFollowLinkArgsForCall)]
	fake.readAndFollowLinkArgsForCall = append(fake.readAndFollowLinkArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReadAndFollowLinkStub
	fakeReturns := fake.readAndFollowLinkReturns
	fake.recordInvocation("ReadAndFollowLink", []interface{}{arg1})
	fake.readAndFollowLinkMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) ReadAndFollowLinkCallCount() int {
	fake.readAndFollowLinkMutex.RLock()
	defer fake.readAndFollowLinkMutex.RUnlock()
	return len(fake.readAndFollowLinkArgsForCall)
}

func (fake *FakeFileSystem) ReadAndFollowLinkCalls(stub func(string) (string, error)) {
	fake.readAndFollowLinkMutex.Lock()
	defer fake.readAndFollowLinkMutex.Unlock()
	fake.ReadAndFollowLinkStub = stub
}

func (fake *FakeFileSystem) ReadAndFollowLinkArgsForCall(i int) string {
	fake.readAndFollowLinkMutex.RLock()
	defer fake.readAndFollowLinkMutex.RUnlock()
	argsForCall := fake.readAndFollowLinkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFileSystem) ReadAndFollowLinkReturns(result1 string, result2 error) {
	fake.readAndFollowLinkMutex.Lock()
	defer fake.readAndFollowLinkMutex.Unlock()
	fake.ReadAndFollowLinkStub = nil
	fake.readAndFollowLinkReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) ReadAndFollowLinkReturnsOnCall(i int, result1 string, result2 error) {
	fake.readAndFollowLinkMutex.Lock()
	defer fake.readAndFollowLinkMutex.Unlock()
	fake.ReadAndFollowLinkStub = nil
	if fake.readAndFollowLinkReturnsOnCall == nil {
		fake.readAndFollowLinkReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.readAndFollowLinkReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) ReadFile(arg1 string) ([]byte, error) {
	fake.readFileMutex.Lock()
	ret, specificReturn := fake.readFileReturnsOnCall[len(fake.readFileArgsForCall)]
	fake.readFileArgsForCall = append(fake.readFileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReadFileStub
	fakeReturns := fake.readFileReturns
	fake.recordInvocation("ReadFile", []interface{}{arg1})
	fake.readFileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) ReadFileCallCount() int {
	fake.readFileMutex.RLock()
	defer fake.readFileMutex.RUnlock()
	return len(fake.readFileArgsForCall)
}

func (fake *FakeFileSystem) ReadFileCalls(stub func(string) ([]byte, error)) {
	fake.readFileMutex.Lock()
	defer fake.readFileMutex.Unlock()
	fake.ReadFileStub = stub
}

func (fake *FakeFileSystem) ReadFileArgsForCall(i int) string {
	fake.readFileMutex.RLock()
	defer fake.readFileMutex.RUnlock()
	argsForCall := fake.readFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFileSystem) ReadFileReturns(result1 []byte, result2 error) {
	fake.readFileMutex.Lock()
	defer fake.readFileMutex.Unlock()
	fake.ReadFileStub = nil
	fake.readFileReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) ReadFileReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.readFileMutex.Lock()
	defer fake.readFileMutex.Unlock()
	fake.ReadFileStub = nil
	if fake.readFileReturnsOnCall == nil {
		fake.readFileReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.readFileReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) ReadFileString(arg1 string) (string, error) {
	fake.readFileStringMutex.Lock()
	ret, specificReturn := fake.readFileStringReturnsOnCall[len(fake.readFileStringArgsForCall)]
	fake.readFileStringArgsForCall = append(fake.readFileStringArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReadFileStringStub
	fakeReturns := fake.readFileStringReturns
	fake.recordInvocation("ReadFileString", []interface{}{arg1})
	fake.readFileStringMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) ReadFileStringCallCount() int {
	fake.readFileStringMutex.RLock()
	defer fake.readFileStringMutex.RUnlock()
	return len(fake.readFileStringArgsForCall)
}

func (fake *FakeFileSystem) ReadFileStringCalls(stub func(string) (string, error)) {
	fake.readFileStringMutex.Lock()
	defer fake.readFileStringMutex.Unlock()
	fake.ReadFileStringStub = stub
}

func (fake *FakeFileSystem) ReadFileStringArgsForCall(i int) string {
	fake.readFileStringMutex.RLock()
	defer fake.readFileStringMutex.RUnlock()
	argsForCall := fake.readFileStringArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFileSystem) ReadFileStringReturns(result1 string, result2 error) {
	fake.readFileStringMutex.Lock()
	defer fake.readFileStringMutex.Unlock()
	fake.ReadFileStringStub = nil
	fake.readFileStringReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) ReadFileStringReturnsOnCall(i int, result1 string, result2 error) {
	fake.readFileStringMutex.Lock()
	defer fake.readFileStringMutex.Unlock()
	fake.ReadFileStringStub = nil
	if fake.readFileStringReturnsOnCall == nil {
		fake.readFileStringReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.readFileStringReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) ReadFileWithOpts(arg1 string, arg2 system.ReadOpts) ([]byte, error) {
	fake.readFileWithOptsMutex.Lock()
	ret, specificReturn := fake.readFileWithOptsReturnsOnCall[len(fake.readFileWithOptsArgsForCall)]
	fake.readFileWithOptsArgsForCall = append(fake.readFileWithOptsArgsForCall, struct {
		arg1 string
		arg2 system.ReadOpts
	}{arg1, arg2})
	stub := fake.ReadFileWithOptsStub
	fakeReturns := fake.readFileWithOptsReturns
	fake.recordInvocation("ReadFileWithOpts", []interface{}{arg1, arg2})
	fake.readFileWithOptsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) ReadFileWithOptsCallCount() int {
	fake.readFileWithOptsMutex.RLock()
	defer fake.readFileWithOptsMutex.RUnlock()
	return len(fake.readFileWithOptsArgsForCall)
}

func (fake *FakeFileSystem) ReadFileWithOptsCalls(stub func(string, system.ReadOpts) ([]byte, error)) {
	fake.readFileWithOptsMutex.Lock()
	defer fake.readFileWithOptsMutex.Unlock()
	fake.ReadFileWithOptsStub = stub
}

func (fake *FakeFileSystem) ReadFileWithOptsArgsForCall(i int) (string, system.ReadOpts) {
	fake.readFileWithOptsMutex.RLock()
	defer fake.readFileWithOptsMutex.RUnlock()
	argsForCall := fake.readFileWithOptsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFileSystem) ReadFileWithOptsReturns(result1 []byte, result2 error) {
	fake.readFileWithOptsMutex.Lock()
	defer fake.readFileWithOptsMutex.Unlock()
	fake.ReadFileWithOptsStub = nil
	fake.readFileWithOptsReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) ReadFileWithOptsReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.readFileWithOptsMutex.Lock()
	defer fake.readFileWithOptsMutex.Unlock()
	fake.ReadFileWithOptsStub = nil
	if fake.readFileWithOptsReturnsOnCall == nil {
		fake.readFileWithOptsReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.readFileWithOptsReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) Readlink(arg1 string) (string, error) {
	fake.readlinkMutex.Lock()
	ret, specificReturn := fake.readlinkReturnsOnCall[len(fake.readlinkArgsForCall)]
	fake.readlinkArgsForCall = append(fake.readlinkArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReadlinkStub
	fakeReturns := fake.readlinkReturns
	fake.recordInvocation("Readlink", []interface{}{arg1})
	fake.readlinkMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) ReadlinkCallCount() int {
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	return len(fake.readlinkArgsForCall)
}

func (fake *FakeFileSystem) ReadlinkCalls(stub func(string) (string, error)) {
	fake.readlinkMutex.Lock()
	defer fake.readlinkMutex.Unlock()
	fake.ReadlinkStub = stub
}

func (fake *FakeFileSystem) ReadlinkArgsForCall(i int) string {
	fake.readlinkMutex.RLock()
	defer fake.readlinkMutex.RUnlock()
	argsForCall := fake.readlinkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFileSystem) ReadlinkReturns(result1 string, result2 error) {
	fake.readlinkMutex.Lock()
	defer fake.readlinkMutex.Unlock()
	fake.ReadlinkStub = nil
	fake.readlinkReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) ReadlinkReturnsOnCall(i int, result1 string, result2 error) {
	fake.readlinkMutex.Lock()
	defer fake.readlinkMutex.Unlock()
	fake.ReadlinkStub = nil
	if fake.readlinkReturnsOnCall == nil {
		fake.readlinkReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.readlinkReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) RecursiveGlob(arg1 string) ([]string, error) {
	fake.recursiveGlobMutex.Lock()
	ret, specificReturn := fake.recursiveGlobReturnsOnCall[len(fake.recursiveGlobArgsForCall)]
	fake.recursiveGlobArgsForCall = append(fake.recursiveGlobArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RecursiveGlobStub
	fakeReturns := fake.recursiveGlobReturns
	fake.recordInvocation("RecursiveGlob", []interface{}{arg1})
	fake.recursiveGlobMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) RecursiveGlobCallCount() int {
	fake.recursiveGlobMutex.RLock()
	defer fake.recursiveGlobMutex.RUnlock()
	return len(fake.recursiveGlobArgsForCall)
}

func (fake *FakeFileSystem) RecursiveGlobCalls(stub func(string) ([]string, error)) {
	fake.recursiveGlobMutex.Lock()
	defer fake.recursiveGlobMutex.Unlock()
	fake.RecursiveGlobStub = stub
}

func (fake *FakeFileSystem) RecursiveGlobArgsForCall(i int) string {
	fake.recursiveGlobMutex.RLock()
	defer fake.recursiveGlobMutex.RUnlock()
	argsForCall := fake.recursiveGlobArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFileSystem) RecursiveGlobReturns(result1 []string, result2 error) {
	fake.recursiveGlobMutex.Lock()
	defer fake.recursiveGlobMutex.Unlock()
	fake.RecursiveGlobStub = nil
	fake.recursiveGlobReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) RecursiveGlobReturnsOnCall(i int, result1 []string, result2 error) {
	fake.recursiveGlobMutex.Lock()
	defer fake.recursiveGlobMutex.Unlock()
	fake.RecursiveGlobStub = nil
	if fake.recursiveGlobReturnsOnCall == nil {
		fake.recursiveGlobReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.recursiveGlobReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) RemoveAll(arg1 string) error {
	fake.removeAllMutex.Lock()
	ret, specificReturn := fake.removeAllReturnsOnCall[len(fake.removeAllArgsForCall)]
	fake.removeAllArgsForCall = append(fake.removeAllArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveAllStub
	fakeReturns := fake.removeAllReturns
	fake.recordInvocation("RemoveAll", []interface{}{arg1})
	fake.removeAllMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFileSystem) RemoveAllCallCount() int {
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	return len(fake.removeAllArgsForCall)
}

func (fake *FakeFileSystem) RemoveAllCalls(stub func(string) error) {
	fake.removeAllMutex.Lock()
	defer fake.removeAllMutex.Unlock()
	fake.RemoveAllStub = stub
}

func (fake *FakeFileSystem) RemoveAllArgsForCall(i int) string {
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	argsForCall := fake.removeAllArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFileSystem) RemoveAllReturns(result1 error) {
	fake.removeAllMutex.Lock()
	defer fake.removeAllMutex.Unlock()
	fake.RemoveAllStub = nil
	fake.removeAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) RemoveAllReturnsOnCall(i int, result1 error) {
	fake.removeAllMutex.Lock()
	defer fake.removeAllMutex.Unlock()
	fake.RemoveAllStub = nil
	if fake.removeAllReturnsOnCall == nil {
		fake.removeAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) Rename(arg1 string, arg2 string) error {
	fake.renameMutex.Lock()
	ret, specificReturn := fake.renameReturnsOnCall[len(fake.renameArgsForCall)]
	fake.renameArgsForCall = append(fake.renameArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.RenameStub
	fakeReturns := fake.renameReturns
	fake.recordInvocation("Rename", []interface{}{arg1, arg2})
	fake.renameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFileSystem) RenameCallCount() int {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return len(fake.renameArgsForCall)
}

func (fake *FakeFileSystem) RenameCalls(stub func(string, string) error) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = stub
}

func (fake *FakeFileSystem) RenameArgsForCall(i int) (string, string) {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	argsForCall := fake.renameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFileSystem) RenameReturns(result1 error) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = nil
	fake.renameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) RenameReturnsOnCall(i int, result1 error) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = nil
	if fake.renameReturnsOnCall == nil {
		fake.renameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) Stat(arg1 string) (os.FileInfo, error) {
	fake.statMutex.Lock()
	ret, specificReturn := fake.statReturnsOnCall[len(fake.statArgsForCall)]
	fake.statArgsForCall = append(fake.statArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.StatStub
	fakeReturns := fake.statReturns
	fake.recordInvocation("Stat", []interface{}{arg1})
	fake.statMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) StatCallCount() int {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	return len(fake.statArgsForCall)
}

func (fake *FakeFileSystem) StatCalls(stub func(string) (os.FileInfo, error)) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = stub
}

func (fake *FakeFileSystem) StatArgsForCall(i int) string {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	argsForCall := fake.statArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFileSystem) StatReturns(result1 os.FileInfo, result2 error) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = nil
	fake.statReturns = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) StatReturnsOnCall(i int, result1 os.FileInfo, result2 error) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = nil
	if fake.statReturnsOnCall == nil {
		fake.statReturnsOnCall = make(map[int]struct {
			result1 os.FileInfo
			result2 error
		})
	}
	fake.statReturnsOnCall[i] = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) StatWithOpts(arg1 string, arg2 system.StatOpts) (os.FileInfo, error) {
	fake.statWithOptsMutex.Lock()
	ret, specificReturn := fake.statWithOptsReturnsOnCall[len(fake.statWithOptsArgsForCall)]
	fake.statWithOptsArgsForCall = append(fake.statWithOptsArgsForCall, struct {
		arg1 string
		arg2 system.StatOpts
	}{arg1, arg2})
	stub := fake.StatWithOptsStub
	fakeReturns := fake.statWithOptsReturns
	fake.recordInvocation("StatWithOpts", []interface{}{arg1, arg2})
	fake.statWithOptsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) StatWithOptsCallCount() int {
	fake.statWithOptsMutex.RLock()
	defer fake.statWithOptsMutex.RUnlock()
	return len(fake.statWithOptsArgsForCall)
}

func (fake *FakeFileSystem) StatWithOptsCalls(stub func(string, system.StatOpts) (os.FileInfo, error)) {
	fake.statWithOptsMutex.Lock()
	defer fake.statWithOptsMutex.Unlock()
	fake.StatWithOptsStub = stub
}

func (fake *FakeFileSystem) StatWithOptsArgsForCall(i int) (string, system.StatOpts) {
	fake.statWithOptsMutex.RLock()
	defer fake.statWithOptsMutex.RUnlock()
	argsForCall := fake.statWithOptsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFileSystem) StatWithOptsReturns(result1 os.FileInfo, result2 error) {
	fake.statWithOptsMutex.Lock()
	defer fake.statWithOptsMutex.Unlock()
	fake.StatWithOptsStub = nil
	fake.statWithOptsReturns = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) StatWithOptsReturnsOnCall(i int, result1 os.FileInfo, result2 error) {
	fake.statWithOptsMutex.Lock()
	defer fake.statWithOptsMutex.Unlock()
	fake.StatWithOptsStub = nil
	if fake.statWithOptsReturnsOnCall == nil {
		fake.statWithOptsReturnsOnCall = make(map[int]struct {
			result1 os.FileInfo
			result2 error
		})
	}
	fake.statWithOptsReturnsOnCall[i] = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) Symlink(arg1 string, arg2 string) error {
	fake.symlinkMutex.Lock()
	ret, specificReturn := fake.symlinkReturnsOnCall[len(fake.symlinkArgsForCall)]
	fake.symlinkArgsForCall = append(fake.symlinkArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.SymlinkStub
	fakeReturns := fake.symlinkReturns
	fake.recordInvocation("Symlink", []interface{}{arg1, arg2})
	fake.symlinkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFileSystem) SymlinkCallCount() int {
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	return len(fake.symlinkArgsForCall)
}

func (fake *FakeFileSystem) SymlinkCalls(stub func(string, string) error) {
	fake.symlinkMutex.Lock()
	defer fake.symlinkMutex.Unlock()
	fake.SymlinkStub = stub
}

func (fake *FakeFileSystem) SymlinkArgsForCall(i int) (string, string) {
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	argsForCall := fake.symlinkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFileSystem) SymlinkReturns(result1 error) {
	fake.symlinkMutex.Lock()
	defer fake.symlinkMutex.Unlock()
	fake.SymlinkStub = nil
	fake.symlinkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) SymlinkReturnsOnCall(i int, result1 error) {
	fake.symlinkMutex.Lock()
	defer fake.symlinkMutex.Unlock()
	fake.SymlinkStub = nil
	if fake.symlinkReturnsOnCall == nil {
		fake.symlinkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.symlinkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) TempDir(arg1 string) (string, error) {
	fake.tempDirMutex.Lock()
	ret, specificReturn := fake.tempDirReturnsOnCall[len(fake.tempDirArgsForCall)]
	fake.tempDirArgsForCall = append(fake.tempDirArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.TempDirStub
	fakeReturns := fake.tempDirReturns
	fake.recordInvocation("TempDir", []interface{}{arg1})
	fake.tempDirMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) TempDirCallCount() int {
	fake.tempDirMutex.RLock()
	defer fake.tempDirMutex.RUnlock()
	return len(fake.tempDirArgsForCall)
}

func (fake *FakeFileSystem) TempDirCalls(stub func(string) (string, error)) {
	fake.tempDirMutex.Lock()
	defer fake.tempDirMutex.Unlock()
	fake.TempDirStub = stub
}

func (fake *FakeFileSystem) TempDirArgsForCall(i int) string {
	fake.tempDirMutex.RLock()
	defer fake.tempDirMutex.RUnlock()
	argsForCall := fake.tempDirArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFileSystem) TempDirReturns(result1 string, result2 error) {
	fake.tempDirMutex.Lock()
	defer fake.tempDirMutex.Unlock()
	fake.TempDirStub = nil
	fake.tempDirReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) TempDirReturnsOnCall(i int, result1 string, result2 error) {
	fake.tempDirMutex.Lock()
	defer fake.tempDirMutex.Unlock()
	fake.TempDirStub = nil
	if fake.tempDirReturnsOnCall == nil {
		fake.tempDirReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.tempDirReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) TempFile(arg1 string) (system.File, error) {
	fake.tempFileMutex.Lock()
	ret, specificReturn := fake.tempFileReturnsOnCall[len(fake.tempFileArgsForCall)]
	fake.tempFileArgsForCall = append(fake.tempFileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.TempFileStub
	fakeReturns := fake.tempFileReturns
	fake.recordInvocation("TempFile", []interface{}{arg1})
	fake.tempFileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeFileSystem) TempFileCallCount() int {
	fake.tempFileMutex.RLock()
	defer fake.tempFileMutex.RUnlock()
	return len(fake.tempFileArgsForCall)
}

func (fake *FakeFileSystem) TempFileCalls(stub func(string) (system.File, error)) {
	fake.tempFileMutex.Lock()
	defer fake.tempFileMutex.Unlock()
	fake.TempFileStub = stub
}

func (fake *FakeFileSystem) TempFileArgsForCall(i int) string {
	fake.tempFileMutex.RLock()
	defer fake.tempFileMutex.RUnlock()
	argsForCall := fake.tempFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeFileSystem) TempFileReturns(result1 system.File, result2 error) {
	fake.tempFileMutex.Lock()
	defer fake.tempFileMutex.Unlock()
	fake.TempFileStub = nil
	fake.tempFileReturns = struct {
		result1 system.File
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) TempFileReturnsOnCall(i int, result1 system.File, result2 error) {
	fake.tempFileMutex.Lock()
	defer fake.tempFileMutex.Unlock()
	fake.TempFileStub = nil
	if fake.tempFileReturnsOnCall == nil {
		fake.tempFileReturnsOnCall = make(map[int]struct {
			result1 system.File
			result2 error
		})
	}
	fake.tempFileReturnsOnCall[i] = struct {
		result1 system.File
		result2 error
	}{result1, result2}
}

func (fake *FakeFileSystem) Walk(arg1 string, arg2 filepath.WalkFunc) error {
	fake.walkMutex.Lock()
	ret, specificReturn := fake.walkReturnsOnCall[len(fake.walkArgsForCall)]
	fake.walkArgsForCall = append(fake.walkArgsForCall, struct {
		arg1 string
		arg2 filepath.WalkFunc
	}{arg1, arg2})
	stub := fake.WalkStub
	fakeReturns := fake.walkReturns
	fake.recordInvocation("Walk", []interface{}{arg1, arg2})
	fake.walkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFileSystem) WalkCallCount() int {
	fake.walkMutex.RLock()
	defer fake.walkMutex.RUnlock()
	return len(fake.walkArgsForCall)
}

func (fake *FakeFileSystem) WalkCalls(stub func(string, filepath.WalkFunc) error) {
	fake.walkMutex.Lock()
	defer fake.walkMutex.Unlock()
	fake.WalkStub = stub
}

func (fake *FakeFileSystem) WalkArgsForCall(i int) (string, filepath.WalkFunc) {
	fake.walkMutex.RLock()
	defer fake.walkMutex.RUnlock()
	argsForCall := fake.walkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFileSystem) WalkReturns(result1 error) {
	fake.walkMutex.Lock()
	defer fake.walkMutex.Unlock()
	fake.WalkStub = nil
	fake.walkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) WalkReturnsOnCall(i int, result1 error) {
	fake.walkMutex.Lock()
	defer fake.walkMutex.Unlock()
	fake.WalkStub = nil
	if fake.walkReturnsOnCall == nil {
		fake.walkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.walkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) WriteFile(arg1 string, arg2 []byte) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.writeFileMutex.Lock()
	ret, specificReturn := fake.writeFileReturnsOnCall[len(fake.writeFileArgsForCall)]
	fake.writeFileArgsForCall = append(fake.writeFileArgsForCall, struct {
		arg1 string
		arg2 []byte
	}{arg1, arg2Copy})
	stub := fake.WriteFileStub
	fakeReturns := fake.writeFileReturns
	fake.recordInvocation("WriteFile", []interface{}{arg1, arg2Copy})
	fake.writeFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFileSystem) WriteFileCallCount() int {
	fake.writeFileMutex.RLock()
	defer fake.writeFileMutex.RUnlock()
	return len(fake.writeFileArgsForCall)
}

func (fake *FakeFileSystem) WriteFileCalls(stub func(string, []byte) error) {
	fake.writeFileMutex.Lock()
	defer fake.writeFileMutex.Unlock()
	fake.WriteFileStub = stub
}

func (fake *FakeFileSystem) WriteFileArgsForCall(i int) (string, []byte) {
	fake.writeFileMutex.RLock()
	defer fake.writeFileMutex.RUnlock()
	argsForCall := fake.writeFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFileSystem) WriteFileReturns(result1 error) {
	fake.writeFileMutex.Lock()
	defer fake.writeFileMutex.Unlock()
	fake.WriteFileStub = nil
	fake.writeFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) WriteFileReturnsOnCall(i int, result1 error) {
	fake.writeFileMutex.Lock()
	defer fake.writeFileMutex.Unlock()
	fake.WriteFileStub = nil
	if fake.writeFileReturnsOnCall == nil {
		fake.writeFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writeFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) WriteFileQuietly(arg1 string, arg2 []byte) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.writeFileQuietlyMutex.Lock()
	ret, specificReturn := fake.writeFileQuietlyReturnsOnCall[len(fake.writeFileQuietlyArgsForCall)]
	fake.writeFileQuietlyArgsForCall = append(fake.writeFileQuietlyArgsForCall, struct {
		arg1 string
		arg2 []byte
	}{arg1, arg2Copy})
	stub := fake.WriteFileQuietlyStub
	fakeReturns := fake.writeFileQuietlyReturns
	fake.recordInvocation("WriteFileQuietly", []interface{}{arg1, arg2Copy})
	fake.writeFileQuietlyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFileSystem) WriteFileQuietlyCallCount() int {
	fake.writeFileQuietlyMutex.RLock()
	defer fake.writeFileQuietlyMutex.RUnlock()
	return len(fake.writeFileQuietlyArgsForCall)
}

func (fake *FakeFileSystem) WriteFileQuietlyCalls(stub func(string, []byte) error) {
	fake.writeFileQuietlyMutex.Lock()
	defer fake.writeFileQuietlyMutex.Unlock()
	fake.WriteFileQuietlyStub = stub
}

func (fake *FakeFileSystem) WriteFileQuietlyArgsForCall(i int) (string, []byte) {
	fake.writeFileQuietlyMutex.RLock()
	defer fake.writeFileQuietlyMutex.RUnlock()
	argsForCall := fake.writeFileQuietlyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFileSystem) WriteFileQuietlyReturns(result1 error) {
	fake.writeFileQuietlyMutex.Lock()
	defer fake.writeFileQuietlyMutex.Unlock()
	fake.WriteFileQuietlyStub = nil
	fake.writeFileQuietlyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) WriteFileQuietlyReturnsOnCall(i int, result1 error) {
	fake.writeFileQuietlyMutex.Lock()
	defer fake.writeFileQuietlyMutex.Unlock()
	fake.WriteFileQuietlyStub = nil
	if fake.writeFileQuietlyReturnsOnCall == nil {
		fake.writeFileQuietlyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writeFileQuietlyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) WriteFileString(arg1 string, arg2 string) error {
	fake.writeFileStringMutex.Lock()
	ret, specificReturn := fake.writeFileStringReturnsOnCall[len(fake.writeFileStringArgsForCall)]
	fake.writeFileStringArgsForCall = append(fake.writeFileStringArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.WriteFileStringStub
	fakeReturns := fake.writeFileStringReturns
	fake.recordInvocation("WriteFileString", []interface{}{arg1, arg2})
	fake.writeFileStringMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeFileSystem) WriteFileStringCallCount() int {
	fake.writeFileStringMutex.RLock()
	defer fake.writeFileStringMutex.RUnlock()
	return len(fake.writeFileStringArgsForCall)
}

func (fake *FakeFileSystem) WriteFileStringCalls(stub func(string, string) error) {
	fake.writeFileStringMutex.Lock()
	defer fake.writeFileStringMutex.Unlock()
	fake.WriteFileStringStub = stub
}

func (fake *FakeFileSystem) WriteFileStringArgsForCall(i int) (string, string) {
	fake.writeFileStringMutex.RLock()
	defer fake.writeFileStringMutex.RUnlock()
	argsForCall := fake.writeFileStringArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeFileSystem) WriteFileStringReturns(result1 error) {
	fake.writeFileStringMutex.Lock()
	defer fake.writeFileStringMutex.Unlock()
	fake.WriteFileStringStub = nil
	fake.writeFileStringReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) WriteFileStringReturnsOnCall(i int, result1 error) {
	fake.writeFileStringMutex.Lock()
	defer fake.writeFileStringMutex.Unlock()
	fake.WriteFileStringStub = nil
	if fake.writeFileStringReturnsOnCall == nil {
		fake.writeFileStringReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writeFileStringReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeFileSystem) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeFileSystem) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ system.FileSystem = new(FakeFileSystem)
